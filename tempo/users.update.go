package tempo

// GENERATED BY POGO. DO NOT EDIT.

import (
	"errors"
	"strings"

	"github.com/satori/go.uuid"
)

// Update the User by the Primary Key
func (u *Users) Update(uu *User, id *uuid.UUID) (user User, err error) {
	fields := u.getFields(uu)

	// first check if we have the primary key
	if id == nil {
		return user, errors.New(`primary key "id" must be non-nil`)
	}

	// don't update the primary key
	delete(fields, "id")

	// prepare the slices
	c, i, v := querySlices(fields, 1)

	// sql query
	sqlstr := `UPDATE public.users SET (` +
		strings.Join(c, ", ") + `) = (` +
		strings.Join(i, ", ") + `)
		WHERE "id" = $1
		RETURNING "id", "role", "email", "stripe_id", "active", "github_access_token", "scope", "free_events", "cost_per_event", "total_events", "paid_events", "token", "created_at", "updated_at", "free_tasks"`

	// run query
	values := append([]interface{}{id}, v...)
	DBLog(sqlstr, values...)

	row := u.DB.QueryRow(sqlstr, values...)
	err = row.Scan(&user.ID, &user.Role, &user.Email, &user.StripeID, &user.Active, &user.GithubAccessToken, &user.Scope, &user.FreeEvents, &user.CostPerEvent, &user.TotalEvents, &user.PaidEvents, &user.Token, &user.CreatedAt, &user.UpdatedAt, &user.FreeTasks)
	if err != nil {
		return user, err
	}

	return user, nil
}

// UpdateByEmail find a User
func (u *Users) UpdateByEmail(uu *User, email *string) (user User, err error) {
	fields := u.getFields(uu)

	// first check if we have all the keys we need
	if email == nil {
		return user, errors.New(`email must be non-nil`)
	}

	// don't update the keys
	delete(fields, "email")

	// prepare the slices
	c, i, v := querySlices(fields, 1)

	// sql query
	sqlstr := `UPDATE public.users SET (` +
		strings.Join(c, ", ") + `) = (` +
		strings.Join(i, ", ") + `) ` +
		`WHERE "email" = $1 ` +
		`RETURNING "id", "role", "email", "stripe_id", "active", "github_access_token", "scope", "free_events", "cost_per_event", "total_events", "paid_events", "token", "created_at", "updated_at", "free_tasks"`

	// run query
	values := []interface{}{}
	values = append(values, email)

	values = append(values, v...)
	DBLog(sqlstr, values...)

	row := u.DB.QueryRow(sqlstr, values...)
	err = row.Scan(&user.ID, &user.Role, &user.Email, &user.StripeID, &user.Active, &user.GithubAccessToken, &user.Scope, &user.FreeEvents, &user.CostPerEvent, &user.TotalEvents, &user.PaidEvents, &user.Token, &user.CreatedAt, &user.UpdatedAt, &user.FreeTasks)
	if err != nil {
		return user, err
	}

	return user, nil
}

// UpdateByGithubAccessToken find a User
func (u *Users) UpdateByGithubAccessToken(uu *User, githubaccesstoken *string) (user User, err error) {
	fields := u.getFields(uu)

	// first check if we have all the keys we need
	if githubaccesstoken == nil {
		return user, errors.New(`github_access_token must be non-nil`)
	}

	// don't update the keys
	delete(fields, "githubaccesstoken")

	// prepare the slices
	c, i, v := querySlices(fields, 1)

	// sql query
	sqlstr := `UPDATE public.users SET (` +
		strings.Join(c, ", ") + `) = (` +
		strings.Join(i, ", ") + `) ` +
		`WHERE "github_access_token" = $1 ` +
		`RETURNING "id", "role", "email", "stripe_id", "active", "github_access_token", "scope", "free_events", "cost_per_event", "total_events", "paid_events", "token", "created_at", "updated_at", "free_tasks"`

	// run query
	values := []interface{}{}
	values = append(values, githubaccesstoken)

	values = append(values, v...)
	DBLog(sqlstr, values...)

	row := u.DB.QueryRow(sqlstr, values...)
	err = row.Scan(&user.ID, &user.Role, &user.Email, &user.StripeID, &user.Active, &user.GithubAccessToken, &user.Scope, &user.FreeEvents, &user.CostPerEvent, &user.TotalEvents, &user.PaidEvents, &user.Token, &user.CreatedAt, &user.UpdatedAt, &user.FreeTasks)
	if err != nil {
		return user, err
	}

	return user, nil
}

// UpdateByToken find a User
func (u *Users) UpdateByToken(uu *User, token *uuid.UUID) (user User, err error) {
	fields := u.getFields(uu)

	// first check if we have all the keys we need
	if token == nil {
		return user, errors.New(`token must be non-nil`)
	}

	// don't update the keys
	delete(fields, "token")

	// prepare the slices
	c, i, v := querySlices(fields, 1)

	// sql query
	sqlstr := `UPDATE public.users SET (` +
		strings.Join(c, ", ") + `) = (` +
		strings.Join(i, ", ") + `) ` +
		`WHERE "token" = $1 ` +
		`RETURNING "id", "role", "email", "stripe_id", "active", "github_access_token", "scope", "free_events", "cost_per_event", "total_events", "paid_events", "token", "created_at", "updated_at", "free_tasks"`

	// run query
	values := []interface{}{}
	values = append(values, token)

	values = append(values, v...)
	DBLog(sqlstr, values...)

	row := u.DB.QueryRow(sqlstr, values...)
	err = row.Scan(&user.ID, &user.Role, &user.Email, &user.StripeID, &user.Active, &user.GithubAccessToken, &user.Scope, &user.FreeEvents, &user.CostPerEvent, &user.TotalEvents, &user.PaidEvents, &user.Token, &user.CreatedAt, &user.UpdatedAt, &user.FreeTasks)
	if err != nil {
		return user, err
	}

	return user, nil
}

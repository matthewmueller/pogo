{{/*************************************************************************/}}
{{/* Variables */}}
{{/*************************************************************************/}}

{{ $t := tablename .Schema .Table }}
{{ $tn := .Table.Name }}
{{ $c := map (split "_" $tn) mcapitalize | join "" }}
{{ $cv := $c | lower }}
{{ $m := map (split "_" $tn) msingular | join "" }}
{{ $mv := $m | lower }}
{{ $co := colnames .Table.Columns }}
{{ $idxs := idxnames .Table.Indexes }}
{{ $cof := map $co (mprintf "\"%s\"") | join ", " }}
{{ $mvg := print "&" $mv "." }}
{{ $cog := map $co mcapitalize (mprefix $mvg) | join ", " }}
{{ $fkparams := fkparams .Schema .Table }}
{{ $fkwhere := fkwhere .Table.ForeignKeys }}
{{ $fks := fknames .Table.ForeignKeys }}
{{ $fklist := map $fks mcamelize | join ", " }}

{{/*************************************************************************/}}
{{/* Our Package */}}
{{/*************************************************************************/}}

package {{ .Settings.Package }}

{{/*************************************************************************/}}
{{/* Pogo marker */}}
{{/*************************************************************************/}}

// GENERATED BY POGO. DO NOT EDIT.

{{/*************************************************************************/}}
{{/* Errors */}}
{{/*************************************************************************/}}

// Err{{ $m }}NotFound returned if the {{ $mv }} is not found
var Err{{ $m }}NotFound = errors.New("{{ $mv }} not found")

{{/*************************************************************************/}}
{{/* The table we'll attach our CRUD methods onto */}}
{{/*************************************************************************/}}

// {{ $c }} class
type {{ $c }} struct {
  db DB
}

{{/*************************************************************************/}}
{{/* The model that contains all our database fields */}}
{{/*************************************************************************/}}

// {{ $m }} model
type {{ $m }} struct {
  {{ range .Table.Columns }}{{ $t := coerce $.Schema .DataType }}
  {{ .Name | capitalize }} {{ $t }} `json:"{{ .Name }},omitempty"` {{ if .Comment }}// {{ .Comment }}{{ end }}{{ end }}
}

{{/*************************************************************************/}}
{{/* Private class constructor, accessed via pogo.$TABLE */}}
{{/*************************************************************************/}}

// {{ $mv }} constructor
func {{ $mv }}(db DB) *{{ $c }} {
  return &{{ $c }}{db}
}

{{/*************************************************************************/}}
{{/* Private helper to get all the non-nil fields on our model */}}
{{/*************************************************************************/}}

// get all the non-nil fields
func fields({{ $mv }} *{{ $m }}) map[string]interface{} {
  fields := make(map[string]interface{})
  {{ range .Table.Columns }}{{ $field := .Name | capitalize }}
  if {{ $mv }}.{{ $field }} != nil {
    fields["{{ .Name }}"] = {{ $mv }}.{{ $field }}
  }{{ end }}
  
  return fields
}

{{/*************************************************************************/}}
{{/* pogo.$TABLE.Find(): find one row by it's primary key */}}
{{/*************************************************************************/}}

// Find a `{{ $mv }}` by its {{ $fks | join "`, `" | printf "`%s`"}}
func ({{ $cv }} *{{ $c }}) Find({{ $fkparams }}) ({{ $mv }} *{{ $m }}, err error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT {{ $cof }}
	FROM {{ $t }}
	WHERE {{ $fkwhere }}
	`

	Log(sqlstr, {{ $fklist }})
	row := {{ $cv }}.db.QueryRow(sqlstr, {{ $fklist }})
	if e := row.Scan({{ $cog }}); e != nil {
    if e == pgx.ErrNoRows {
      return nil,  Err{{ $m }}NotFound
    }
    return nil, e
  }

	return {{ $mv }}, nil
}

{{/*************************************************************************/}}
{{/* pogo.$TABLE.Insert(): insert a new row into the table */}}
{{/*************************************************************************/}}

// Insert a `{{ $mv }}` into `{{ $t }}`
func ({{ $cv }} *{{ $c }}) Insert({{ $mv }} {{ $m }}) (*{{ $m }}, error) {
	// get all the non-nil fields and prepare them for the query
	_c, _i, _v := slice(fields(&{{ $mv }}), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
	INSERT INTO {{ $t }} (` + strings.Join(_c, ", ") + `)
	VALUES (` + strings.Join(_i, ", ") + `)
	RETURNING {{ $cof }}
  `

	Log(sqlstr, _v...)
	row := {{ $cv }}.db.QueryRow(sqlstr, _v...)
	if e := row.Scan({{ $cog }}); e != nil {
    return nil, e
  }

	return &{{ $mv }}, nil
}

{{/*************************************************************************/}}
{{/* pogo.$TABLE.Update(): update an existing row in the table */}}
{{/*************************************************************************/}}

// Update a `{{ $m }}` by its {{ $fks | join "`, `" | printf "`%s`"}}
func ({{ $cv }} *{{ $c }}) Update({{ $fkparams }}, {{ $mv }} {{ $m }}) (*{{ $m }}, error) {
	fieldset := fields(&{{ $mv }})

	// first check if we have the foreign keys
  {{ range .Table.ForeignKeys }}if {{ .Name | camelize }} == nil {
    return nil, errors.New(`"{{ .Name | camelize }}" must be non-nil`)
  }
  {{ end }}

	// don't update the foreign keys
	{{ range .Table.ForeignKeys }}delete(fieldset, "{{ .Name }}")
  {{ end }}

	// prepare the slices
	_c, _i, _v := slice(fieldset, {{ len .Table.ForeignKeys }})

	// sql query
	sqlstr := `UPDATE {{ $t }} SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `)
		WHERE {{ $fkwhere }}
		RETURNING {{ $cof }}`

	// run query
	values := []interface{}{}
	{{ range .Table.ForeignKeys }}values = append(values, {{ .Name | camelize }})
  {{ end }}
	values = append(values, _v...)
	Log(sqlstr, values...)

	row := {{ $cv }}.db.QueryRow(sqlstr, values...)
	if e := row.Scan({{ $cog }}); e != nil {
    if e == pgx.ErrNoRows {
      return nil, Err{{ $m }}NotFound
    }
    return nil, e
  }

	return &{{ $mv }}, nil
}

{{/*****************************************************************************/}}
{{/* pogo.$TABLE.Delete(): delete a row using its foreign keys */}}
{{/*****************************************************************************/}}

// Delete a `{{ $m }}` by its {{ $fks | join "`, `" | printf "`%s`"}}
func ({{ $cv }} *{{ $c }}) Delete({{ $fkparams }}) error {
	// sql query
	const sqlstr = `
	DELETE FROM {{ $t }}
	WHERE {{ $fkwhere }}
	`

	// run query
	Log(sqlstr, {{ $fklist }})
	if _, e := {{ $cv }}.db.Exec(sqlstr, {{ $fklist }}); e != nil {
    if e == pgx.ErrNoRows {
      return Err{{ $m }}NotFound
    }
    return e
  }

	return nil
}

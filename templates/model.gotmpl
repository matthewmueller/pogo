package {{$.Path.Package}}

import (
  "context"
  "encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/jackc/pgx"
)

// GENERATED BY POGO. DO NOT EDIT.

// Err{{$.Table.Pascal}}NotFound returned if the {{$.Table.Name}} is not found
var Err{{$.Table.Pascal}}NotFound = errors.New("{{$.Table.Camel}} not found")

// {{$.Table.Pascal}} result data for "{{$.Schema.Name}}"."{{$.Table.Name}}"
type {{$.Table.Pascal}} struct {
  {{- range $col := $.Table.Columns }}
  {{$col.Pascal}} {{ if $col.NotNull }}{{$col.Type $.Schema}}{{ else }}*{{$col.Type $.Schema}}{{ end }} `json:"{{$col.Snake}},omitempty"`
  {{- end }}
}

// New "{{$.Schema.Name}}"."{{$.Table.Name}}" input
func New() *Input {
  return &Input{}
}

// Input data for "{{$.Schema.Name}}"."{{$.Table.Name}}"
type Input struct {
  {{- range $col := $.Table.Columns }}
  {{ $col.Camel }} *{{ $col.Type $.Schema }}
  {{- end }}
}

{{ range $col := $.Table.Columns }}
// {{$col.Pascal}} sets the "{{$col.Name}}"
func ({{$.Table.Short}} *Input) {{$col.Pascal}}({{$col.Camel}} {{$col.Type $.Schema}}) *Input {
  {{$.Table.Short}}.{{$col.Camel}} = &{{$col.Camel}}
  return {{$.Table.Short}}
}
{{- end }}

// MarshalJSON marshals the "{{$.Table.Camel}}" into JSON
func ({{$.Table.Short}} *Input) MarshalJSON() ([]byte, error) {
  return json.Marshal({{$.Table.Short}})
}

// UnmarshalJSON unmarshals json to a "{{$.Table.Camel}}"
func ({{$.Table.Short}} *Input) UnmarshalJSON(data []byte) error {
  return json.Unmarshal(data, {{$.Table.Short}})
}

func ({{$.Table.Short}} *Input) String() string {
  return "{{$.Table.Name}}"
}

func ({{$.Table.Short}} *Input) columns() map[string]interface{} {
  columns := make(map[string]interface{})

  {{ range $col := $.Table.Columns }}
  if {{$.Table.Short}}.{{$col.Camel}} != nil {
    columns["{{$col.Name}}"] = *{{$.Table.Short}}.{{$col.Camel}}
  }
  {{ end }}

  return columns
}

// NewFilter creates a new filter
func NewFilter() *Filter {
  return &Filter{}
}

// Filter filters for "{{$.Schema.Name}}"."{{$.Table.Name}}"
type Filter struct {
	formats []string
	values  []interface{}
}

var _ pogo.Condition = (*Filter)(nil)

// Clause fn
func (f *Filter) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "WHERE",
		Format: strings.Join(f.formats, " AND "),
		Params: f.values,
	}
}

// And filter
// func (f *Filter) And(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " AND "))
//   return f
// }

// Or filter
// func (f *Filter) Or(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " OR "))
//   return f
// }

{{ range $filter := $.Table.Filters }}
{{ range $field := $filter.Fields $.Schema }}
// {{ $field.Pascal }} {{ $field.Description }}
func (f *Filter) {{ $field.Pascal }}(v {{ $field.Type $.Schema }}) *Filter {
  f.formats = append(f.formats, `{{ $field.Format }}`)
	f.values = append(f.values, v)
	return f
}
{{- end }}
{{- end }}

// NewOrderBy fn
func NewOrderBy() *OrderBy {
	return &OrderBy{}
}

// OrderBy orders the given fields
type OrderBy struct {
	formats []string
}

// Order specificies the ORDER BY <order>
type Order string

const (
	// Asc sorts by ascending order
	Asc Order = "ASC"

	// Desc sorts by descending order
	Desc Order = "DESC"
)

// Clause fn
func (o *OrderBy) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "ORDER BY",
		Format: strings.Join(o.formats, ", "),
	}
}

{{ range $field := $.Table.OrderBys }}
// {{ $field.Pascal }} orders `{{ $field.Name }}` by a sort expression
func (o *OrderBy) {{ $field.Pascal }}(order Order) *OrderBy {
	o.formats = append(o.formats, fmt.Sprintf(`{{ $field.Format }}`, order))
	return o
}
{{- end }}

// Insert a "{{$.Table.Name}}" into the "{{$.Schema.Name}}"."{{$.Table.Name}}"
func Insert(db pogo.DB, {{$.Table.Camel}} *Input) (*{{$.Table.Pascal}}, error) {
  // get all the non-nil columns and prepare them for the query
  _c, _i, _v := slice({{$.Table.Camel}}.columns(), 0)

  // sql insert query, primary key provided by sequence
  sqlstr := `
    INSERT INTO "{{$.Schema.Name}}"."{{$.Table.Name}}" (` + strings.Join(_c, ", ") + `)
    VALUES (` + strings.Join(_i, ", ") + `)
    RETURNING {{$.Table.Returning}}
  `

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}


{{/* Find a row by a set of conditions */}}
// Find a `{{$.Table.Pascal}}` by some conditions.
func Find(db pogo.DB, conds ...pogo.Condition) (*{{$.Table.Pascal}}, error) {
  _s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

  // sql select query, primary key provided by sequence
  sqlstr := `SELECT {{.Table.Select}} ` +
    `FROM "{{$.Schema.Name}}"."{{$.Table.Name}}" ` +
    _s

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if e == pgx.ErrNoRows {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* FindBy Primary Key */}}
{{ if .Table.PrimaryKey }}
{{ $pk := .Table.PrimaryKey }}
// FindBy{{$pk.Pascal}} a `{{$.Table.Pascal}}` by some conditions.
func FindBy{{$pk.Pascal}}(db pogo.DB, {{$pk.Camel}} {{$pk.Type $.Schema}}) (*{{$.Table.Pascal}}, error) {
  // sql select query, primary key provided by sequence
  sqlstr := `
    SELECT {{.Table.Select}}
    FROM "{{$.Schema.Name}}"."{{$.Table.Name}}"
    WHERE "{{$pk.Name}}" = $1
  `

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, &{{$pk.Camel}})
  }

  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, &{{$pk.Camel}})
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if e == pgx.ErrNoRows {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}
{{ end }}

{{/* FindBy Unique column */}}
{{ range $idx := .Table.Indexes }}
{{- if (and $idx.IsUnique (not $idx.IsPrimary)) }}
// FindBy{{$idx.Method}} find a {{$.Table.Camel}} by {{$idx.Description}}
func FindBy{{$idx.Method}}(db pogo.DB, {{$idx.Params $.Schema}}) (*{{$.Table.Pascal}}, error) {
  // sql select query, primary key provided by sequence
  sqlstr := `
    SELECT {{$.Table.Select}}
    FROM "{{$.Schema.Name}}"."{{$.Table.Name}}"
    WHERE {{$idx.Where}}
  `

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, {{$idx.Variables}})
  }

  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, {{$idx.Variables}})
  err := row.Scan({{$.Table.Scan}})
  if err != nil {
    if err == pgx.ErrNoRows {
      return nil,  Err{{$.Table.Pascal}}NotFound
    }
    return nil, err
  }

  return &_{{$.Table.Camel}}, nil
}
{{- end }}
{{ end }}

{{/* UpdateBy Primary Key */}}
{{ if .Table.PrimaryKey }}
{{ $pk := .Table.PrimaryKey }}
// UpdateBy{{$pk.Pascal}} a "{{$.Table.Camel}}" in "{{$.Schema.Name}}"."{{$.Table.Name}}" by its "{{$pk.Name}}"
func UpdateBy{{$pk.Pascal}}(db pogo.DB, {{$pk.Camel}} {{$pk.Type $.Schema}}, {{$.Table.Camel}} *Input) (*{{$.Table.Pascal}}, error) {
  fields := {{$.Table.Camel}}.columns()

  // don't update the primary key
  delete(fields, "{{$pk.Name}}")

  // prepare the slices
  _c, _i, _v := slice(fields, 1)

  // setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// sql query
	sqlstr := `UPDATE "{{$.Schema.Name}}"."{{$.Table.Name}}" SET` +
		` ` + strings.Join(_u, ", ") + ` ` +
		`WHERE "{{$pk.Name}}" = $1 ` +
		`RETURNING {{$.Table.Returning}}`

  // setup query
  values := append([]interface{}{&{{$pk.Camel}}}, _v...)

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, values...)
  }

  // run the query
  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, values...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if e == pgx.ErrNoRows {
      return nil,  Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}
{{ end }}


{{/*
// WhereClause is a struct to handle where clauses
type WhereClause struct {
  condition string
  params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
  return &WhereClause{
    condition: condition,
    params:    params,
  }
}

// DB is the common interface for database operations that can be used with
// types from schema `{{ $.Schema.Name }}`.
//
// This should work with database/sql.DB and database/sql.Tx.
type DB interface {
	Exec(string, ...interface{}) (pgx.CommandTag, error)
	Query(string, ...interface{}) (*pgx.Rows, error)
	QueryRow(string, ...interface{}) *pgx.Row
}

// Model for {{$.Table.Pascal}}
type Model struct {
  DB DB
  Log func(string, ...interface{})
}

// Insert a "{{$.Table.Camel}}" into the "{{$.Schema.Name}}"."{{$.Table.Name}}"
func (m *Model) Insert(ctx context.Context, {{$.Table.Camel}}Input *Input) (*{{$.Table.Pascal}}, error) {
  // get all the non-nil columns and prepare them for the query
  _c, _i, _v := slice(columns({{$.Table.Camel}}Input), 0)

  // sql insert query, primary key provided by sequence
  sqlstr := `
    INSERT INTO "{{$.Schema.Name}}"."{{$.Table.Name}}" (` + strings.Join(_c, ", ") + `)
    VALUES (` + strings.Join(_i, ", ") + `)
    RETURNING {{$.Table.Returning}}
  `

  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr, _v...)
  }

  var {{$.Table.Camel}} {{$.Table.Pascal}}
  row := m.DB.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    return nil, e
  }

  return &{{$.Table.Camel}}, nil
}

{{ if .Table.PrimaryKey }}
{{ $pk := .Table.PrimaryKey }}
// Find a `{{$.Table.Pascal}}` by it's primary key `{{$pk.Name}}`
func (m *Model) Find(ctx context.Context, {{$pk.Camel}} {{$pk.Type $.Schema}}) (*{{$.Table.Pascal}}, error) {
  // sql select query, primary key provided by sequence
  sqlstr := `
    SELECT {{.Table.Select}}
    FROM "{{$.Schema.Name}}"."{{$.Table.Name}}"
    WHERE "{{$pk.Name}}" = $1
  `

  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr, &{{$pk.Camel}})
  }

  var {{$.Table.Camel}} {{$.Table.Pascal}}
  row := m.DB.QueryRow(sqlstr, &{{$pk.Camel}})
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if e == pgx.ErrNoRows {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &{{$.Table.Camel}}, nil
}
{{ end }}

{{ range $idx := .Table.Indexes }}
{{- if (and $idx.IsUnique (not $idx.IsPrimary)) }}
// FindBy{{$idx.Method}} find a {{$.Table.Camel}} by {{$idx.Description}}
func (m *Model) FindBy{{$idx.Method}}(ctx context.Context, {{$idx.Params $.Schema}}) (*{{$.Table.Pascal}}, error) {
  // sql select query, primary key provided by sequence
  sqlstr := `
    SELECT {{$.Table.Select}}
    FROM "{{$.Schema.Name}}"."{{$.Table.Name}}"
    WHERE {{$idx.Where}}
  `

  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr, {{$idx.Variables}})
  }

  var {{$.Table.Camel}} {{$.Table.Pascal}}
  row := m.DB.QueryRow(sqlstr, {{$idx.Variables}})
  err := row.Scan({{$.Table.Scan}})
  if err != nil {
    if err == pgx.ErrNoRows {
      return nil,  Err{{$.Table.Pascal}}NotFound
    }
    return nil, err
  }

  return &{{$.Table.Camel}}, nil
}
{{- end }}
{{ end }}

// FindOne find one {{$.Table.Camel}} by a condition
func (m *Model) FindOne(ctx context.Context, where *WhereClause) (*{{$.Table.Pascal}}, error) {
  // sql select query, primary key provided by sequence
  sqlstr := `
  SELECT {{.Table.Select}}
  FROM "{{$.Schema.Name}}"."{{$.Table.Name}}"
  WHERE ` + where.condition

  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr, where.params...)
  }

  var {{$.Table.Camel}} {{$.Table.Pascal}}
  row := m.DB.QueryRow(sqlstr, where.params...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if e == pgx.ErrNoRows {
      return nil,  Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &{{$.Table.Camel}}, nil
}	

// FindWhere find many "{{$.Table.Camel}}"'s by a given condition
func (m *Model) FindWhere(ctx context.Context, where *WhereClause) ([]*{{$.Table.Pascal}}, error) {
  {{$.Table.PluralCamel}} := []*{{$.Table.Pascal}}{}

  // sql select query, primary key provided by sequence
  sqlstr := `
  SELECT {{.Table.Select}}
  FROM "{{$.Schema.Name}}"."{{$.Table.Name}}"
  WHERE ` + where.condition

  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr, where.params...)
  }

  rows, err := m.DB.Query(sqlstr, where.params...)
  if err != nil {
    return {{$.Table.PluralCamel}}, err
  }
  defer rows.Close()

  for rows.Next() {
    var {{$.Table.Camel}} {{$.Table.Pascal}}
    if e := rows.Scan({{$.Table.Scan}}); e != nil {
      if e == pgx.ErrNoRows {
        return {{$.Table.PluralCamel}}, Err{{$.Table.Pascal}}NotFound
      }
      return {{$.Table.PluralCamel}}, err
    }
    {{$.Table.PluralCamel}} = append({{$.Table.PluralCamel}}, &{{$.Table.Camel}})
  }
  if rows.Err() != nil {
    return {{$.Table.PluralCamel}}, rows.Err()
  }

  return {{$.Table.PluralCamel}}, nil
}

// FindAll find all "{{$.Table.Camel}}"'s
func (m *Model) FindAll(ctx context.Context) ([]*{{$.Table.Pascal}}, error) {
  {{$.Table.Camel}} := []*{{$.Table.Pascal}}{}

  // sql select query, primary key provided by sequence
  sqlstr := `
  SELECT {{.Table.Select}}
  FROM "{{$.Schema.Name}}"."{{$.Table.Name}}"`

  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr)
  }

  rows, err := m.DB.Query(sqlstr)
  if err != nil {
    return {{$.Table.PluralCamel}}, err
  }
  defer rows.Close()

  for rows.Next() {
    var {{$.Table.Camel}} {{$.Table.Pascal}}
    if e := rows.Scan({{$.Table.Scan}}); e != nil {
      if e == pgx.ErrNoRows {
        return {{$.Table.PluralCamel}}, Err{{$.Table.Pascal}}NotFound
      }
      return {{$.Table.PluralCamel}}, err
    }
    {{$.Table.PluralCamel}} = append({{$.Table.PluralCamel}}, &{{$.Table.Camel}})
  }
  if rows.Err() != nil {
    return {{$.Table.PluralCamel}}, rows.Err()
  }

  return {{$.Table.PluralCamel}}, nil
}

{{ range $idx := .Table.Uniques }}
// UpdateBy{{$idx.Method}} find a {{$.Table.Pascal}}
func (m *Model) UpdateBy{{$idx.Method}}(ctx context.Context, {{$idx.Params $.Schema}}, {{$.Table.Camel}}Input *Input) (*{{$.Table.Pascal}}, error) {
  fields := columns({{$.Table.Camel}}Input)

  // don't update the keys
  {{- range $idx.Columns}}
  delete(fields, "{{.Name}}")
  {{- end }}

  // prepare the slices
  _c, _i, _v := slice(fields, {{len $idx.Columns}})

  // sql query
  sqlstr := `UPDATE "{{$.Schema.Name}}"."{{$.Table.Name}}" SET (` +
    strings.Join(_c, ", ") + `) = (` +
    strings.Join(_i, ", ") + `) ` +
    `WHERE {{$idx.Where}} ` +
    `RETURNING {{$.Table.Returning}}`

  // setup the query
  values := []interface{}{}
  {{- range $col := $idx.Columns}}
  values = append(values, {{$col.Camel}})
  {{- end }}
  values = append(values, _v...)

  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr, values...)
  }

  // run the query
  var {{$.Table.Camel}} {{$.Table.Pascal}}
  row := m.DB.QueryRow(sqlstr, values...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if e == pgx.ErrNoRows {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &{{$.Table.Camel}}, nil
}
{{ end }}

// UpdateWhere rows in "{{$.Schema.Name}}"."{{$.Table.Name}}" by a given condition
func (m *Model) UpdateWhere(ctx context.Context, where *WhereClause, {{$.Table.Camel}}Input *Input) ([]*{{$.Table.Pascal}}, error) {
  {{$.Table.PluralCamel}} := []*{{$.Table.Pascal}}{}

  // prepare the slices
  _c, _i, _v := slice(columns({{$.Table.Camel}}Input), len(where.params))

  // sql query
  sqlstr := `UPDATE "{{$.Schema.Name}}"."{{$.Table.Name}}" SET (` +
    strings.Join(_c, ", ") + `) = (` +
    strings.Join(_i, ", ") + `) ` +
    `WHERE ` + where.condition + ` ` +
    `RETURNING {{$.Table.Returning}}`

  // setup the query
  values := []interface{}{}
  values = append(values, where.params...)
  values = append(values, _v...)

  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr, values...)
  }

  // run query
  rows, err := m.DB.Query(sqlstr, values...)
  if err != nil {
    return {{$.Table.PluralCamel}}, err
  }
  defer rows.Close()

  for rows.Next() {
    var {{$.Table.Camel}} {{$.Table.Pascal}}
    if e := rows.Scan({{$.Table.Scan}}); e != nil {
      if e == pgx.ErrNoRows {
        return {{$.Table.PluralCamel}}, Err{{$.Table.Pascal}}NotFound
      }
      return {{$.Table.PluralCamel}}, err
    }
    {{$.Table.PluralCamel}} = append({{$.Table.PluralCamel}}, &{{$.Table.Camel}})
  }
  if rows.Err() != nil {
    return {{$.Table.PluralCamel}}, rows.Err()
  }

  return {{$.Table.PluralCamel}}, nil
}

{{ if .Table.PrimaryKey }}
{{ $pk := .Table.PrimaryKey }}
// Delete a "{{$.Table.Camel}}" from the "{{$.Schema.Name}}"."{{$.Table.Name}}" table
func (m *Model) Delete(ctx context.Context, {{$pk.Camel}} {{$pk.Type $.Schema}}) error {
  // sql query
  sqlstr := `DELETE FROM "{{$.Schema.Name}}"."{{$.Table.Name}}" WHERE "{{$pk.Name}}" = $1`

  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr, {{$pk.Camel}})
  }

  // run query
  if _, e := m.DB.Exec(sqlstr, {{$pk.Camel}}); e != nil {
    if e == pgx.ErrNoRows {
      return Err{{$.Table.Pascal}}NotFound
    }
    return e
  }

  return nil
}
{{ end }}

{{ range $idx := .Table.Uniques }}
// DeleteBy{{$idx.Method}} deletes a "{{$.Table.Camel}}"
func (m *Model) DeleteBy{{$idx.Method}}(ctx context.Context, {{$idx.Params $.Schema}}) error {
  // sql delete query
  sqlstr := `DELETE FROM "{{$.Schema.Name}}"."{{$.Table.Name}}" WHERE {{$idx.Where}}`
  
  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr, {{$idx.Variables}})
  }

  if _, e := m.DB.Exec(sqlstr, {{$idx.Variables}}); e != nil {
    if e == pgx.ErrNoRows {
      return Err{{$.Table.Pascal}}NotFound
    }
    return e
  }

  return nil
}
{{ end }}

// DeleteWhere delete many "{{$.Table.Camel}}"'s by the given condition
func (m *Model) DeleteWhere(ctx context.Context, where *WhereClause) error {
  // sql select query, primary key provided by sequence
  sqlstr := `DELETE FROM "{{$.Schema.Name}}"."{{$.Table.Name}}" WHERE ` + where.condition
  
  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr, where.params...)
  }

  if _, e := m.DB.Exec(sqlstr, where.params...); e != nil {
    return e
  }

  return nil
}

{{ if .Table.PrimaryKey }}
{{ $pk := .Table.PrimaryKey }}
// Upsert the "{{$.Table.Camel}}" by its "{{$pk.Name}}".
func (m *Model) Upsert(ctx context.Context, {{$.Table.Camel}}Input *Input) (*{{$.Table.Pascal}}, error) {
  // get all the non-nil columns and prepare them for the query
  _c, _i, _v := slice(columns({{$.Table.Camel}}Input), 0)

  // sql query
  sqlstr := `INSERT INTO "{{$.Schema.Name}}"."{{$.Table.Name}}" (` + strings.Join(_c, ", ") + `) ` +
  `VALUES (` + strings.Join(_i, ", ") + `) ` +
  `ON CONFLICT ("{{$pk.Name}}") ` +
  `DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
  `RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr, _v...)
  }

  // run query
  var {{$.Table.Camel}} {{$.Table.Pascal}}
  row := m.DB.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    return nil, e
  }

  return &{{$.Table.Camel}}, nil
}
{{ end }}

{{ range $idx := .Table.Uniques }}
// UpsertBy{{$idx.Method}} find a "{{$.Table.Pascal}}"
func (m *Model) UpsertBy{{$idx.Method}}(ctx context.Context, {{$.Table.Camel}}Input *Input) (*{{$.Table.Pascal}}, error) {
  // get all the non-nil columns and prepare them for the query
  _c, _i, _v := slice(columns({{$.Table.Camel}}Input), 0)

  // sql query
  sqlstr := `INSERT INTO "{{$.Schema.Name}}"."{{$.Table.Name}}" (` + strings.Join(_c, ", ") + `) ` +
  `VALUES (` + strings.Join(_i, ", ") + `) ` +
  `ON CONFLICT ({{$idx.ColumnList}}) ` +
  `DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
  `RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr, _v...)
  }

  // run query
  var {{$.Table.Camel}} {{$.Table.Pascal}}
  row := m.DB.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil && e != pgx.ErrNoRows {
    return nil, e
  }

  return &{{$.Table.Camel}}, nil
}
{{ end }}
*/}}

// slice converts our columns into something the sql driver can understand
func slice(columns map[string]interface{}, offset int) (c []string, i []string, v []interface{}) {
	n := offset + 1
	for col, val := range columns {
		c = append(c, `"`+col+`"`)
		i = append(i, "$"+strconv.Itoa(n))
		v = append(v, val)
		n++
	}
	return c, i, v
}

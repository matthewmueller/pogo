{{/* Variables */}}
{{ $User := .Table.Name | singular | pascal }}
{{ $user := .Table.Name | singular | camel }}
{{ $users := .Table.Name | plural | camel }}

package {{$users | lower}}

// GENERATED BY POGO. DO NOT EDIT.

// Err{{$User}}NotFound returned if the {{$user}} is not found
var Err{{$User}}NotFound = errors.New("{{$user}} not found")

// {{$User}}Input model for '{{$.Schema.Name}}.{{$.Table.Name}}'
type {{$User}}Input struct {
  {{- range $col := .Table.Columns }}
  {{ $col.Name | camel }} *{{ $col.GoType }}
  {{- end }}
}

// {{$User}} model for "{{$.Schema.Name}}.{{$.Table.Name}}"
type {{$User}} struct {
  {{- range $col := .Table.Columns }}
  {{$col.Name | pascal }} {{ if $col.NotNull }}{{$col.GoType}}{{ else }}*{{$col.GoType}}{{ end }}
  {{- end }}
}

// New "{{$.Schema.Name}}.{{$.Table.Name}}" API
func New() *{{$User}}Input {
  return &{{$User}}Input{}
}

{{ range $col := .Table.Columns }}
{{ $Email := .Name | pascal }}
{{ $email := .Name | camel }}
// {{$Email}} sets the "{{$email}}"
func ({{$user}} *{{$User}}Input) {{$Email}}({{$email}} {{$col.GoType}}) *{{$User}}Input {
  {{$user}}.{{$email}} = &{{$email}}
  return {{$user}}
}
{{- end }}

// MarshalJSON marshals the "{{$user}}" into JSON
func ({{$user}} *{{$User}}Input) MarshalJSON() ([]byte, error) {
  return json.Marshal({{$user}})
}

// UnmarshalJSON unmarshals json to a "{{$user}}"
func ({{$user}} *{{$User}}Input) UnmarshalJSON(data []byte) error {
  return json.Unmarshal(data, {{$user}})
}

func ({{$user}} *{{$User}}Input) String() string {
  return "{{$user}}"
}

func getColumns({{$user}} *{{$User}}Input) map[string]interface{} {
  columns := make(map[string]interface{})

  {{ range $col := .Table.Columns }}
  {{ $email := $col.Name | camel }}
  if {{$user}}.{{$email}} != nil {
    columns["{{$col.Name}}"] = *{{$user}}.{{$email}}
  }
  {{ end }}

  return columns
}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
  condition string
  params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
  return &WhereClause{
    condition: condition,
    params:    params,
  }
}

// Insert a "{{$user}}" into the "{{$.Schema.Name}}.{{$.Table.Name}}"
func Insert(db {{$.Package}}.DB, {{$user}}Input *{{$User}}Input) (*{{$User}}, error) {
  // get all the non-nil columns and prepare them for the query
  _c, _i, _v := {{$.Package}}.Slice(getColumns({{$user}}Input), 0)

  // sql insert query, primary key provided by sequence
  sqlstr := `
    INSERT INTO "{{$.Schema.Name}}.{{$.Table.Name}}" (` + strings.Join(_c, ", ") + `)
    VALUES (` + strings.Join(_i, ", ") + `)
    RETURNING {{$.Table.SQLReturn}}
  `
  {{$.Package}}.Log(sqlstr, _v...)

  var {{$user}} {{$User}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.GoScan}}); e != nil {
    return nil, e
  }

  return &{{$user}}, nil
}

{{ if .Table.PrimaryKey }}
{{ $pk := .Table.PrimaryKey }}
{{ $email := $pk.Name | camel }}
// Find a "{{$User}}" by "{{$pk.Name}}"
func Find(db pogo.DB, {{$email}} string) (*{{$User}}, error) {
  // sql select query, primary key provided by sequence
  sqlstr := `
    SELECT {{.Table.SQLSelect}}
    FROM "{{$.Schema.Name}}.{{$.Table.Name}}"
    WHERE "{{$pk.Name}}" = $1
  `
  pogo.Log(sqlstr, &{{$email}})

  var {{$user}} {{$User}}
  row := db.QueryRow(sqlstr, &{{$email}})
  if e := row.Scan({{$.Table.GoScan}}); e != nil {
    if e == pgx.ErrNoRows {
      return nil, Err{{$User}}NotFound
    }
    return nil, e
  }

  return &{{$user}}, nil
}
{{ end }}

{{ range $idx := .Table.Indexes }}
// FindBy{{$idx.GoMethod}} find a {{$user}} by {{$idx.Description}}
func FindBy{{$idx.GoMethod}}(db {{$.Package}}.DB, {{$idx.GoParams}}) (*{{$User}}, error) {
  // sql select query, primary key provided by sequence
  sqlstr := `
    SELECT {{$.Table.SQLSelect}}
    FROM "{{$.Schema.Name}}.{{$.Table.Name}}"
    WHERE {{$idx.SQLWhere}}
  `
  {{$.Package}}.Log(sqlstr, {{$idx.GoVars}})

  var {{$user}} {{$User}}
  row := db.QueryRow(sqlstr, {{$idx.GoVars}})
  err := row.Scan({{$.Table.GoScan}})
  if err != nil {
    if err == pgx.ErrNoRows {
      return nil,  Err{{$User}}NotFound
    }
    return nil, err
  }

  return &{{$user}}, nil
}
{{ end }}

// FindOne find one {{$user}} by a condition
func FindOne(db {{$.Package}}.DB, where *WhereClause) (*{{$User}}, error) {
  // sql select query, primary key provided by sequence
  sqlstr := `
  SELECT {{.Table.SQLSelect}}
  FROM "{{$.Schema.Name}}.{{$.Table.Name}}"
  WHERE ` + where.condition
  {{$.Package}}.Log(sqlstr, where.params...)

  var {{$user}} {{$User}}
  row := db.QueryRow(sqlstr, where.params...)
  if e := row.Scan({{$.Table.GoScan}}); e != nil {
    if e == pgx.ErrNoRows {
      return nil,  Err{{$User}}NotFound
    }
    return nil, e
  }

  return &{{$user}}, nil
}	

// FindMany find many "{{$user}}"'s by a given condition
func FindMany(db {{$.Package}}.DB, where *WhereClause) ({{$users}} []*{{$User}}, err error) {
  // sql select query, primary key provided by sequence
  sqlstr := `
  SELECT {{.Table.SQLSelect}}
  FROM "{{$.Schema.Name}}.{{$.Table.Name}}"
  WHERE ` + where.condition
  {{$.Package}}.Log(sqlstr, where.params...)

  rows, err := db.Query(sqlstr, where.params...)
  if err != nil {
    return {{$users}}, err
  }
  defer rows.Close()

  for rows.Next() {
    var {{$user}} {{$User}}
    if e := rows.Scan({{$.Table.GoScan}}); e != nil {
      if e == pgx.ErrNoRows {
        return {{$users}}, Err{{$User}}NotFound
      }
      return {{$users}}, err
    }
    {{$users}} = append({{$users}}, &{{$user}})
  }
  if rows.Err() != nil {
    return {{$users}}, rows.Err()
  }

  // ensure we return an empty array
  // rather than nil when we marshal
  // if len({{$users}}) == 0 {
  // 	return make([]*{{$User}}, 0), nil
  // }

  return {{$users}}, nil
}

{{ if .Table.PrimaryKey }}
{{ $pk := .Table.PrimaryKey }}
{{ $email := $pk.Name | camel }}
// Update a "{{$user}}" in "{{$.Schema.Name}}.{{$.Table.Name}}" by its "{{$pk.Name}}"
func Update(db {{$.Package}}.DB, {{$email}} {{$pk.GoType}}, {{$user}}Input *{{$User}}Input) (*{{$User}}, error) {
  fields := getColumns({{$user}}Input)

  // don't update the primary key
  delete(fields, "{{$pk.Name}}")

  // prepare the slices
  _c, _i, _v := {{$.Package}}.Slice(fields, 1)

  // sql query
  sqlstr := `UPDATE "{{$.Schema.Name}}.{{$.Table.Name}}" SET (` +
      strings.Join(_c, ", ") + 
    `) = (` +
      strings.Join(_i, ", ") + 
    `)
    WHERE "{{$pk.Name}}" = $1
    RETURNING {{$.Table.SQLReturn}}`

  // setup query
  values := append([]interface{}{&{{$email}}}, _v...)
  {{$.Package}}.Log(sqlstr, values...)

  // run the query
  var {{$user}} {{$User}}
  row := db.QueryRow(sqlstr, values...)
  if e := row.Scan({{$.Table.GoScan}}); e != nil {
    if e == pgx.ErrNoRows {
      return nil,  Err{{$User}}NotFound
    }
    return nil, e
  }

  return &{{$user}}, nil
}
{{ end }}

{{ range $idx := .Table.Uniques }}
// UpdateBy{{$idx.GoMethod}} find a {{$User}}
func UpdateBy{{$idx.GoMethod}}(db {{$.Package}}.DB, {{$idx.GoParams}}, {{$user}}Input *{{$User}}Input) (*{{$User}}, error) {
  fields := getColumns({{$user}}Input)

  // don't update the keys
  {{- range $idx.Columns}}
  delete(fields, "{{.Name}}")
  {{- end }}

  // prepare the slices
  _c, _i, _v := {{$.Package}}.Slice(fields, {{$idx.NumColumns}})

  // sql query
  sqlstr := `UPDATE "{{$.Schema.Name}}.{{$.Table.Name}}" SET (` +
    strings.Join(_c, ", ") + `) = (` +
    strings.Join(_i, ", ") + `) ` +
    `WHERE {{$idx.SQLWhere}} ` +
    `RETURNING {{$.Table.SQLReturn}}`

  // setup the query
  values := []interface{}{}
  {{- range $idx.Columns}}
  values = append(values, {{.Name | camel}})
  {{- end }}
  values = append(values, _v...)
  {{$.Package}}.Log(sqlstr, values...)

  // run the query
  var {{$user}} {{$User}}
  row := db.QueryRow(sqlstr, values...)
  if e := row.Scan({{$.Table.GoScan}}); e != nil {
    if e == pgx.ErrNoRows {
      return nil, Err{{$User}}NotFound
    }
    return nil, e
  }

  return &{{$user}}, nil
}
{{ end }}

// UpdateMany rows in "{{$.Schema.Name}}.{{$.Table.Name}}" by a given condition
func UpdateMany(db {{$.Package}}.DB, where *WhereClause, {{$user}}Input *{{$User}}Input) ({{$users}} []*{{$User}}, err error) {
  // prepare the slices
  _c, _i, _v := {{$.Package}}.Slice(getColumns({{$user}}Input), len(where.params))

  // sql query
  sqlstr := `UPDATE "{{$.Schema.Name}}.{{$.Table.Name}}" SET (` +
    strings.Join(_c, ", ") + `) = (` +
    strings.Join(_i, ", ") + `) ` +
    `WHERE ` + where.condition + ` ` +
    `RETURNING {{$.Table.SQLReturn}}`

  // setup the query
  values := []interface{}{}
  values = append(values, where.params...)
  values = append(values, _v...)
  {{$.Package}}.Log(sqlstr, values...)

  // run query
  rows, err := db.Query(sqlstr, values...)
  if err != nil {
    return {{$users}}, err
  }
  defer rows.Close()

  for rows.Next() {
    var {{$user}} {{$User}}
    if e := rows.Scan({{$.Table.GoScan}}); e != nil {
      if e == pgx.ErrNoRows {
        return {{$users}}, Err{{$User}}NotFound
      }
      return {{$users}}, err
    }
    {{$users}} = append({{$users}}, &{{$user}})
  }
  if rows.Err() != nil {
    return {{$users}}, rows.Err()
  }

  // ensure we return an empty array
  // rather than nil when we marshal
  // if len({{$users}}) == 0 {
  // 	return make([]*{{$User}}, 0), nil
  // }

  return {{$users}}, nil
}

{{ if .Table.PrimaryKey }}
{{ $pk := .Table.PrimaryKey }}
{{ $email := $pk.Name | camel }}
// Delete a "{{$user}}" from the "{{$.Schema.Name}}.{{$.Table.Name}}" table
func Delete(db {{$.Package}}.DB, {{$email}} {{$pk.GoType}}) error {
  // sql query
  sqlstr := `DELETE FROM "{{$.Schema.Name}}.{{$.Table.Name}}" WHERE "{{$pk.Name}}" = $1`
  {{$.Package}}.Log(sqlstr, {{$email}})

  // run query
  if _, e := db.Exec(sqlstr, {{$email}}); e != nil {
    if e == pgx.ErrNoRows {
      return Err{{$User}}NotFound
    }
    return e
  }

  return nil
}
{{ end }}

{{ range $idx := .Table.Uniques }}
// DeleteBy{{$idx.GoMethod}} deletes a "{{$user}}"
func DeleteBy{{$idx.GoMethod}}(db {{$.Package}}.DB, {{$idx.GoParams}}) error {
  // sql delete query
  sqlstr := `DELETE FROM "{{$.Schema.Name}}.{{$.Table.Name}}" WHERE {{$idx.SQLWhere}}`
  {{$.Package}}.Log(sqlstr, {{$idx.GoVars}})

  if _, e := db.Exec(sqlstr, {{$idx.GoVars}}); e != nil {
    if e == pgx.ErrNoRows {
      return Err{{$User}}NotFound
    }
    return e
  }

  return nil
}
{{ end }}

// DeleteMany delete many "{{$user}}"'s by the given condition
func DeleteMany(db {{$.Package}}.DB, where *WhereClause) error {
  // sql select query, primary key provided by sequence
  sqlstr := `DELETE FROM "{{$.Schema.Name}}.{{$.Table.Name}}" WHERE ` + where.condition
  {{$.Package}}.Log(sqlstr, where.params...)

  if _, e := db.Exec(sqlstr, where.params...); e != nil {
    return e
  }

  return nil
}

{{ if .Table.PrimaryKey }}
{{ $pk := .Table.PrimaryKey }}
// Upsert the "{{$user}}" by its "{{$pk.Name}}".
func Upsert(db {{$.Package}}.DB, {{$user}}Input *{{$User}}Input) (*{{$User}}, error) {
  // get all the non-nil columns and prepare them for the query
  _c, _i, _v := {{$.Package}}.Slice(getColumns({{$user}}Input), 0)

  // sql query
  sqlstr := `INSERT INTO "{{$.Schema.Name}}.{{$.Table.Name}}" (` + strings.Join(_c, ", ") + `) ` +
  `VALUES (` + strings.Join(_i, ", ") + `) ` +
  `ON CONFLICT ("{{$pk.Name}}") ` +
  `DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
  `RETURNING {{$.Table.SQLReturn}}`
  {{$.Package}}.Log(sqlstr, _v...)

  // run query
  var {{$user}} {{$User}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.GoScan}}); e != nil {
    return nil, e
  }

  return &{{$user}}, nil
}
{{ end }}

{{ range $idx := .Table.Uniques }}
// UpsertBy{{$idx.GoMethod}} find a "{{$User}}"
func UpsertBy{{$idx.GoMethod}}(db {{$.Package}}.DB, {{$user}}Input *{{$User}}Input) (*{{$User}}, error) {
  // get all the non-nil columns and prepare them for the query
  _c, _i, _v := {{$.Package}}.Slice(getColumns({{$user}}Input), 0)

  // sql query
  sqlstr := `INSERT INTO "{{$.Schema.Name}}.{{$.Table.Name}}" (` + strings.Join(_c, ", ") + `) ` +
  `VALUES (` + strings.Join(_i, ", ") + `) ` +
  `ON CONFLICT ({{$idx.SQLColumns}}) ` +
  `DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
  `RETURNING {{$.Table.SQLReturn}}`
  {{$.Package}}.Log(sqlstr, _v...)

  // run query
  var {{$user}} {{$User}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.GoScan}}); e != nil && e != pgx.ErrNoRows {
    return nil, e
  }

  return &{{$user}}, nil
}
{{ end }}
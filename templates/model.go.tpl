{{/*************************************************************************/}}
{{/* Variables */}}
{{/*************************************************************************/}}

{{ $pkg := .Settings.Package }}
{{ $t := tablename $.Schema .Table }}
{{ $tn := .Table.Name }}
{{ $c := $tn | capitalize }}
{{ $cv := $c | lower }}
{{ $m := $tn | singular }}
{{ $mv := $m | lower }}
{{ $p := primary .Table.Columns }}
{{ $pt := coerce $.Schema $p.DataType }}
{{ $co := colnames .Table.Columns }}
{{ $idxs := indexes .Table.Indexes }}
{{ $cof := map $co (mprintf "\"%s\"") | join ", " }}
{{ $cog := map $co mcapitalize (mprefix "&cols.") | join ", " }}

{{/*************************************************************************/}}
{{/* Our Package */}}
{{/*************************************************************************/}}

package {{ $cv }}

{{/*************************************************************************/}}
{{/* Pogo marker */}}
{{/*************************************************************************/}}

// GENERATED BY POGO. DO NOT EDIT.

{{/*************************************************************************/}}
{{/* Errors */}}
{{/*************************************************************************/}}

// Err{{ $m }}NotFound returned if the {{ $mv }} is not found
var Err{{ $m }}NotFound = errors.New("{{ $mv }} not found")

{{/*************************************************************************/}}
{{/* All the columns in our table */}}
{{/*************************************************************************/}}

// columns in `{{ $t }}`
type columns struct {
  {{ range .Table.Columns }}{{ $t := coerce $.Schema .DataType }}
  {{ .Name | capitalize }} *{{ $t }} `json:"{{ .Name }},omitempty"` {{ if .Comment }}// {{ .Comment }}{{ end }}{{ end }}
}

{{/*************************************************************************/}}
{{/* This contains our fluent parameter container */}}
{{/*************************************************************************/}}

// {{ $m }} fluent API
type {{ $m }} struct {
	columns *columns
}

{{/*************************************************************************/}}
{{/* Helper to create the fluent API */}}
{{/*************************************************************************/}}

// New `{{ $t }}` API
func New() *{{ $m }} {
	return &{{ $m }}{&columns{}}
}

{{/*************************************************************************/}}
{{/* Generate each of the fluent methods for the fluent parameter API      */}}
{{/* This is very messy right now because we have some custom accessors    */}}
{{/* for uuid.                                                             */}}
{{/*                                                                       */}}
{{/* NOTE: This would probably be better solved at pgx level, but I spent  */}}
{{/* far too long trying to get that working with scanning nil *uuid.UUID  */}}
{{/* Fortunately, this isn't a big deal, because the API can remain stable */}}
{{/*************************************************************************/}}

{{ range .Table.Columns }}{{ $dt := coerceaccessor $.Schema .DataType }}
// {{ .Name | capitalize }} sets the `{{ .Name }}`
func ({{ $mv }} *{{ $m }}) {{ .Name | capitalize }}({{ .Name | camelize }} {{ $dt }}) *{{ $m }} {
	{{ if eq .DataType "uuid" }}*{{ $mv }}.columns.{{ .Name | capitalize }} = {{ .Name | camelize }}.String(){{ else }}{{ $mv }}.columns.{{ .Name | capitalize }} = &{{ .Name | camelize }}{{ end }}
	return {{ $mv }}
}

// Get{{ .Name | capitalize }} returns the `{{ .Name }}` if set
func ({{ $mv }} *{{ $m }}) Get{{ .Name | capitalize }}() ({{ .Name | camelize }} *{{ $dt }}) {
	{{ if eq .DataType "uuid" }}if {{ $mv }}.columns.{{ .Name | capitalize }} == nil {
		return nil
	}

	_u, err := uuid.FromString(*{{ $mv }}.columns.{{ .Name | capitalize }})
	if err != nil {
		return nil
	}

	return &_u{{ else }}return {{ $mv }}.columns.{{ .Name | capitalize }}{{ end }}
}
{{ end }}

{{/*************************************************************************/}}
{{/* Implement the Marshaler & Unmarshaler interfaces */}}
{{/*************************************************************************/}}

// MarshalJSON marshals the `{{ $mv }}` into JSON
func ({{ $mv }} *{{ $m }}) MarshalJSON() ([]byte, error) {
	return json.Marshal({{ $mv }}.columns)
}

// UnmarshalJSON unmarshals json to a `{{ $mv }}`
func ({{ $mv }} *{{ $m }}) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, {{ $mv }}.columns)
}

{{/*************************************************************************/}}
{{/* Implement the Stringer interface */}}
{{/*************************************************************************/}}

func ({{ $mv }} *{{ $m }}) String() string {
	return "{{ $mv}} TODO"
}

{{/*************************************************************************/}}
{{/* Private helper to get all the non-nil columns in our table */}}
{{/*************************************************************************/}}

// get all the non-nil columns
func getColumns({{ $mv }} *{{ $m }}) map[string]interface{} {
  columns := make(map[string]interface{})
  {{ range .Table.Columns }}{{ $col := .Name | capitalize }}
  if {{ $mv }}.columns.{{ $col }} != nil {
    columns["{{ .Name }}"] = *{{ $mv }}.columns.{{ $col }}
  }{{ end }}
  
  return columns
}

{{/*************************************************************************/}}
{{/* pogo.$TABLE.Find(): find one row by it's primary key */}}
{{/*************************************************************************/}}

{{ if $p }}
// Find a {{ $mv }} by "{{ $p.Name }}"
func Find(db {{ $pkg }}.DB, {{ $p.Name }} *{{ $pt }}) (*{{ $m }}, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT {{ $cof }}
	FROM {{ $t }}
	WHERE "{{ $p.Name }}" = $1
	`
	{{$pkg}}.Log(sqlstr, {{ $p.Name }})

	var cols *columns
	row := db.QueryRow(sqlstr, {{ $p.Name }})
  if e := row.Scan({{ $cog }}); e != nil {
    if e == pgx.ErrNoRows {
      return nil,  Err{{ $m }}NotFound
    }
    return nil, e
  }

	return &{{ $m }}{cols}, nil
}
{{ end }}

{{/*************************************************************************/}}
{{/* pogo.$TABLE.FindBy...(): find a row by its unique non-primary indexes */}}
{{/*************************************************************************/}}

{{ range $idx := $idxs }}
{{ $cols := idxcolnames $idx }}
{{ $idxmethod := map $cols mcapitalize | join "And" }}
{{ $idxparams := idxparams $.Schema $idx }}
{{ $indexvars := map $cols mcamelize | join ", " }}
// FindBy{{ $idxmethod }} find a {{ $mv }} by {{ $cols | join "` and `" | printf "`%s`"}}
func FindBy{{ $idxmethod }}(db {{ $pkg }}.DB, {{ $idxparams }}) (*{{ $m }}, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT {{ $cof }}
	FROM {{ $t }}
	WHERE {{ idxwhere $idx }}
	`
	{{ $pkg }}.Log(sqlstr, {{ $indexvars }})

	var cols *columns
	row := db.QueryRow(sqlstr, {{ $indexvars }})
	err := row.Scan({{ $cog }})
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil,  Err{{ $m }}NotFound
		}
		return nil, err
	}

	return &{{ $m }}{cols}, nil
}
{{ end }}

{{/*************************************************************************/}}
{{/* pogo.$TABLE.FindMany(): find many rows by a condition */}}
{{/*************************************************************************/}}

// FindMany find many `{{ $mv }}`s by a given condition
func FindMany(db {{ $pkg }}.DB, condition string, params... interface{}) ([]*{{ $m }}, error) {
	var _o []*{{ $m }}
	
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT {{ $cof }}
	FROM {{ $t }}
	WHERE ` + condition
	{{ $pkg }}.Log(sqlstr, params...)

  rows, err := db.Query(sqlstr, params...)
  if err != nil {
    return _o, err
  }
  defer rows.Close()

  for rows.Next() {
		var cols *columns
    if e := rows.Scan({{ $cog }}); e != nil {
			if e == pgx.ErrNoRows {
				return _o, Err{{ $m }}NotFound
			}
			return _o, err
		}
    _o = append(_o, &{{ $m }}{cols})
  }
  if rows.Err() != nil {
    return _o, rows.Err()
  }

	// ensure we return an empty array
	// rather than nil when we marshal
	if len(_o) == 0 {
		return make([]*{{ $m }}, 0), nil
	}

  return _o, nil
}

{{/*************************************************************************/}}
{{/* pogo.$TABLE.FindOne(): find exactly one row by a condition */}}
{{/*************************************************************************/}}

// FindOne find one {{ $mv }} by a condition
func FindOne(db {{ $pkg }}.DB, condition string, params... interface{}) (*{{ $m }}, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT {{ $cof }}
	FROM {{ $t }}
	WHERE ` + condition
	{{ $pkg }}.Log(sqlstr, params...)

	var cols *columns
  row := db.QueryRow(sqlstr, params...)
  if e := row.Scan({{ $cog }}); e != nil {
		if e == pgx.ErrNoRows {
      return nil,  Err{{ $m }}NotFound
    }
		return nil, e
	}

  return &{{ $m }}{cols}, nil
}

{{/*************************************************************************/}}
{{/* pogo.$TABLE.Insert(): insert a new row into the table */}}
{{/*************************************************************************/}}

// Insert a `{{ $mv }}` into the `{{ $t }}` table.
func Insert(db {{ $pkg }}.DB, {{ $mv }} *{{ $m }}) (*{{ $m }}, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := {{ $pkg }}.Slice(getColumns({{ $mv }}), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
	INSERT INTO {{ $t }} (` + strings.Join(_c, ", ") + `)
	VALUES (` + strings.Join(_i, ", ") + `)
	RETURNING {{ $cof }}
	`
	{{ $pkg }}.Log(sqlstr, _v...)

	cols := &columns{}
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan({{ $cog }}); e != nil {
    return nil, e
  }

	return &{{ $m }}{cols}, nil
}

{{/*************************************************************************/}}
{{/* pogo.$TABLE.Update(): update an existing row in the table */}}
{{/*************************************************************************/}}

// Update a {{ $mv }} by its `{{ $p.Name }}`
func Update(db {{ $pkg }}.DB, {{ $mv }} *{{ $m }}, {{ $p.Name }} *{{ $pt }}) (*{{ $m }}, error) {
	fields := getColumns({{ $mv }})

	// first check if we have the primary key
	if {{ $p.Name }} == nil {
		return nil, errors.New(`primary key "{{ $p.Name }}" must be non-nil`)
	}

	// don't update the primary key
	delete(fields, "{{ $p.Name }}")

	// prepare the slices
	_c, _i, _v := {{ $pkg }}.Slice(fields, 1)

	// sql query
	sqlstr := `UPDATE {{ $t }} SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `)
		WHERE "{{ $p.Name }}" = $1
		RETURNING {{ $cof }}`

	// setup query
	values := append([]interface{}{ {{ $p.Name }} }, _v...)
	{{ $pkg }}.Log(sqlstr, values...)

	// run the query
	var cols *columns
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan({{ $cog }}); e != nil {
		if e == pgx.ErrNoRows {
      return nil,  Err{{ $m }}NotFound
    }
    return nil, e
  }

	return &{{ $m }}{cols}, nil
}

{{/*****************************************************************************/}}
{{/* pogo.$TABLE.UpdateBy...(): update a row by its unique non-primary indexes */}}
{{/*****************************************************************************/}}

{{ range $idx := $idxs }}
{{ $cols := idxcolnames $idx }}
{{ $idxmethod := map $cols mcapitalize | join "And" }}
{{ $idxparams := idxparams $.Schema $idx }}
// UpdateBy{{ $idxmethod }} find a {{ $m }}
func UpdateBy{{ $idxmethod }}(db {{ $pkg }}.DB, {{ $mv }} *{{ $m }}, {{ $idxparams }}) (*{{ $m }}, error) {
	fields := getColumns({{ $mv }})

	// first check if we have all the keys we need
	{{ range $idx.Columns }}if {{ .Name | camelize }} == nil {
		return nil, errors.New(`{{ .Name | camelize }} must be non-nil`)
	}
	{{ end }}

	// don't update the keys
	{{ range $idx.Columns }}delete(fields, "{{ .Name | camelize }}")
	{{ end }}

	// prepare the slices
	_c, _i, _v := {{ $pkg }}.Slice(fields, {{ len $cols }})

	// sql query
	sqlstr := `UPDATE {{ $t }} SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE {{ idxwhere $idx }} ` +
		`RETURNING {{ $cof }}`

	// setup the query
	values := []interface{}{}
	{{ range .Columns }}values = append(values, {{ .Name | camelize }})
	{{ end }}
	values = append(values, _v...)
	{{ $pkg }}.Log(sqlstr, values...)

	// run the query
	var cols *columns
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan({{ $cog }}); e != nil {
		if e == pgx.ErrNoRows {
      return nil, Err{{ $m }}NotFound
    }
		return nil, e
	}

	return &{{ $m }}{cols}, nil
}
{{ end }}

{{/*****************************************************************************/}}
{{/* pogo.$TABLE.UpdateMany(): update many rows by the given condition */}}
{{/*****************************************************************************/}}

// UpdateMany rows in `{{ $t }}` by a given condition
func UpdateMany(db {{ $pkg }}.DB, {{ $mv }} *{{ $m }}, condition string, params... interface{}) ([]*{{ $m }}, error) {
	var _o []*{{ $m }}
	
	// prepare the slices
	_c, _i, _v := {{ $pkg }}.Slice(getColumns({{ $mv }}), len(params))

	// sql query
	sqlstr := `UPDATE {{ $t }} SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE ` + condition + ` ` +
		`RETURNING {{ $cof }}`

	// setup the query
  values := []interface{}{}
  values = append(values, params...)
  values = append(values, _v...)
	{{ $pkg }}.Log(sqlstr, values...)

	// run query
  rows, err := db.Query(sqlstr, values...)
  if err != nil {
    return _o, err
  }
  defer rows.Close()

  for rows.Next() {
    var cols *columns
    if e := rows.Scan({{ $cog }}); e != nil {
			if e == pgx.ErrNoRows {
				return _o, Err{{ $m }}NotFound
			}
      return _o, err
    }
    _o = append(_o, &{{ $m }}{cols})
  }
  if rows.Err() != nil {
    return _o, rows.Err()
  }

	// ensure we return an empty array
	// rather than nil when we marshal
	if len(_o) == 0 {
		return make([]*{{ $m }}, 0), nil
	}

  return _o, nil
}

{{/*****************************************************************************/}}
{{/* pogo.$TABLE.Delete(): delete a row using its primary index */}}
{{/*****************************************************************************/}}

// Delete a `{{ $mv }}` from the `{{ $t }}` table
func Delete(db {{ $pkg }}.DB, {{ $p.Name }} *{{ $pt }}) error {
	// sql query
	sqlstr := `DELETE FROM {{ $t }} WHERE "{{ $p.Name }}" = $1`
	{{ $pkg }}.Log(sqlstr, {{ $p.Name }})

	// run query
	if _, e := db.Exec(sqlstr, {{ $p.Name }}); e != nil {
    if e == pgx.ErrNoRows {
      return Err{{ $m }}NotFound
    }
    return e
  }

	return nil
}

{{/*****************************************************************************/}}
{{/* pogo.$TABLE.DeleteBy...(): delete a row by its unique non-primary indexes */}}
{{/*****************************************************************************/}}

{{ range $idx := $idxs }}
{{ $cols := idxcolnames $idx }}
{{ $idxmethod := map $cols mcapitalize | join "And" }}
{{ $idxparams := idxparams $.Schema $idx }}
{{ $indexvars := map $cols mcamelize | join ", " }}
// DeleteBy{{ $idxmethod }} find a {{ $m }}
func DeleteBy{{ $idxmethod }}(db {{ $pkg }}.DB, {{ $idxparams }}) error {
	// sql delete query
	sqlstr := `DELETE FROM {{ $t }} WHERE {{ idxwhere $idx }}`
	{{ $pkg }}.Log(sqlstr, {{ $indexvars }})

	if _, e := db.Exec(sqlstr, {{ $indexvars }}); e != nil {
    if e == pgx.ErrNoRows {
      return Err{{ $m }}NotFound
    }
    return e
  }

	return nil
}
{{ end }}

{{/*****************************************************************************/}}
{{/* pogo.$TABLE.DeleteMany(): delete many rows by the given condition */}}
{{/*****************************************************************************/}}

// DeleteMany delete many `{{ $mv }}`'s by the given condition
func DeleteMany(db {{ $pkg }}.DB, condition string, params... interface{}) error {
	// sql select query, primary key provided by sequence
	sqlstr := `DELETE FROM {{ $t }} WHERE ` + condition
	{{ $pkg }}.Log(sqlstr, params...)

  if _, e := db.Exec(sqlstr, params...); e != nil {
    return e
	}

  return nil
}

{{/*****************************************************************************/}}
{{/* pogo.$TABLE.Upsert(): upsert a row by its primary key */}}
{{/*****************************************************************************/}}

// Upsert the `{{ $mv }}` by its `{{ $p.Name }}`.
func Upsert(db {{ $pkg }}.DB, {{ $mv }} *{{ $m }}, action string) (*{{ $m }}, error) {
	// prepare the slices
	_c, _i, _v := {{ $pkg }}.Slice(getColumns({{ $mv }}), 0)

  // determine on conflict action
  var upsertAction string
  if action == {{ $pkg }}.UpsertDoUpdate {
    upsertAction = `DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `)`
  } else if action == {{ $pkg }}.UpsertDoNothing {
    upsertAction = {{ $pkg }}.UpsertDoNothing
  } else {
    return nil, errors.New("invalid upsert action")
  }

	// sql query
  sqlstr := `INSERT INTO {{ $t }} (` + strings.Join(_c, ", ") + `) ` +
	`VALUES (` + strings.Join(_i, ", ") + `) ` +
  `ON CONFLICT ("{{ $p.Name }}") ` +
  upsertAction + ` ` +
  `RETURNING {{ $cof }}`
  {{ $pkg }}.Log(sqlstr, _v...)

	// run query
	var cols *columns
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan({{ $cog }}); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &{{ $m }}{cols}, nil
}

{{/*****************************************************************************/}}
{{/* pogo.$TABLE.UpsertBy...(): upsert a row by its non-unique indexes */}}
{{/*****************************************************************************/}}

{{ range $idx := $idxs }}
{{ $cols := idxcolnames $idx }}
{{ $idxmethod := map $cols mcapitalize | join "And" }}
{{ $idxparams := idxparams $.Schema $idx }}
{{ $idxparamlist := map $cols (mprintf "\"%s\"") | join ", " }}
// UpsertBy{{ $idxmethod }} find a {{ $m }}
func UpsertBy{{ $idxmethod }}(db {{ $pkg }}.DB, {{ $mv }} *{{ $m }}, action string) (*{{ $m }}, error) {
	// get all the non-nil columns and prepare them for the query
  _c, _i, _v := {{ $pkg }}.Slice(getColumns({{ $mv }}), 0)

  // determine on conflict action
  var upsertAction string
  if action == {{ $pkg }}.UpsertDoUpdate {
    upsertAction = `DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `)`
  } else if action == {{ $pkg }}.UpsertDoNothing {
    upsertAction = {{ $pkg }}.UpsertDoNothing
  } else {
    return nil, errors.New("invalid upsert action")
  }

  // sql query
  sqlstr := `INSERT INTO {{ $t }} (` + strings.Join(_c, ", ") + `) ` +
	`VALUES (` + strings.Join(_i, ", ") + `) ` +
  `ON CONFLICT ({{ $idxparamlist }}) ` +
  upsertAction + ` ` +
  `RETURNING {{ $cof }}`
  {{ $pkg }}.Log(sqlstr, _v...)

	// run query
	var cols *columns
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan({{ $cog }}); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &{{ $m }}{cols}, nil
}
{{ end }}

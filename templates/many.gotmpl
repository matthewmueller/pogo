package {{$.Path.Package}}

import (
  "context"
  "encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/jackc/pgx"
)

// GENERATED BY POGO. DO NOT EDIT.

// Err{{$.Table.Pascal}}NotFound returned if the {{.Table.Name}} is not found
var Err{{$.Table.Pascal}}NotFound = errors.New("{{.Table.Name}} not found")

// {{$.Table.Pascal}} result data for "{{$.Schema.Name}}"."{{$.Table.Name}}"
type {{$.Table.Pascal}} struct {
  {{- range $col := $.Table.Columns }}
  {{$col.Pascal}} {{ if $col.NotNull }}{{$col.Type $.Schema}}{{ else }}*{{$col.Type $.Schema}}{{ end }}
  {{- end }}
}

{{/*
// New input builder for "{{$.Schema.Name}}"."{{$.Table.Name}}".
func New() *Input {
  return &Input{}
}

// Input data for "{{$.Schema.Name}}"."{{$.Table.Name}}"
type Input struct {
  {{- range $col := $.Table.Columns }}
  {{$col.Camel}} *{{ $col.Type $.Schema }}
  {{- end }}
}

{{ range $col := $.Table.Columns }}
// {{$col.Pascal}} sets the "{{$col.Camel}}"
func ({{$.Table.Camel}} *Input) {{$col.Pascal}}({{$col.Camel}} {{$col.Type $.Schema}}) *Input {
  {{$.Table.Camel}}.{{$col.Camel}} = &{{$col.Camel}}
  return {{$.Table.Camel}}
}
{{- end }}

// MarshalJSON marshals the "{{$.Table.Camel}}" into JSON
func ({{$.Table.Camel}} *Input) MarshalJSON() ([]byte, error) {
  return json.Marshal({{$.Table.Camel}})
}

// UnmarshalJSON unmarshals json to a "{{$.Table.Camel}}"
func ({{$.Table.Camel}} *Input) UnmarshalJSON(data []byte) error {
  return json.Unmarshal(data, {{$.Table.Camel}})
}

func ({{$.Table.Camel}} *Input) String() string {
  return "{{$.Table.Camel}}"
}

func columns({{$.Table.Camel}} *Input) map[string]interface{} {
  columns := make(map[string]interface{})

  {{ range $col := $.Table.Columns }}
  if {{$.Table.Camel}}.{{$col.Camel}} != nil {
    columns["{{$col.Name}}"] = *{{$.Table.Camel}}.{{$col.Camel}}
  }
  {{ end }}

  return columns
}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
  condition string
  params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
  return &WhereClause{
    condition: condition,
    params:    params,
  }
}

// DB is the common interface for database operations that can be used with
// types from schema `{{ .Schema.Name }}`.
//
// This should work with database/sql.DB and database/sql.Tx.
type DB interface {
	Exec(string, ...interface{}) (pgx.CommandTag, error)
	Query(string, ...interface{}) (*pgx.Rows, error)
	QueryRow(string, ...interface{}) *pgx.Row
}

// Model for {{$.Table.Pascal}}
type Model struct {
  DB DB
  Log func(string, ...interface{})
}

// Insert a "{{$.Table.Camel}}" into "{{$.Schema.Name}}"."{{$.Table.Name}}"
func (m *Model) Insert(ctx context.Context, {{$.Table.Camel}}Input *Input) (*{{$.Table.Pascal}}, error) {
  // get all the non-nil fields and prepare them for the query
  _c, _i, _v := slice(columns({{$.Table.Camel}}Input), 0)

  // sql insert query, primary key provided by sequence
  sqlstr := `
  INSERT INTO "{{$.Schema.Name}}"."{{$.Table.Name}}" (` + strings.Join(_c, ", ") + `)
  VALUES (` + strings.Join(_i, ", ") + `)
  RETURNING {{$.Table.Returning}}
  `
  
  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr, _v...)
  }

  // run the query
  var {{$.Table.Camel}} {{$.Table.Pascal}}
  row := m.DB.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    return nil, e
  }

  return &{{$.Table.Camel}}, nil
}

{{ if .Table.Composite }}
{{ $cps := .Table.Composite }}
// Find a "{{$.Table.Pascal}}" by its {{$cps.Description}}
func (m *Model) Find(ctx context.Context, {{$cps.Params}}) (*{{$.Table.Pascal}}, error) {
  // sql select query, primary key provided by sequence
  sqlstr := `
    SELECT {{$.Table.Select}}
    FROM "{{$.Schema.Name}}.{{$.Table.Name}}"
    WHERE {{$cps.Where}}
  `
  
  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr, {{$cps.Variables}})
  }

  // run the query
  var {{$.Table.Camel}} {{$.Table.Pascal}}
  row := m.DB.QueryRow(sqlstr, {{$cps.Variables}})
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if e == pgx.ErrNoRows {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &{{$.Table.Camel}}, nil
}
{{ end }}

{{ if .Table.Composite }}
{{ $cps := .Table.Composite }}
// Update a "{{$.Table.Pascal}}" by its {{$cps.Description}}
func (m *Model) Update(ctx context.Context, {{$cps.Params}}, {{$.Table.Camel}}Input *Input) (*{{$.Table.Pascal}}, error) {
  fields := columns({{$.Table.Camel}}Input)

  // don't update the foreign keys
  {{- range $cps.Columns}}
  delete(fields, "{{.Name}}")
  {{- end }}

  // prepare the slices
  _c, _i, _v := slice(fields, {{$cps.NumColumns}})

  // sql query
  sqlstr := `UPDATE "{{$.Schema.Name}}"."{{$.Table.Name}}" SET (` +
    strings.Join(_c, ", ") + `) = (` +
    strings.Join(_i, ", ") + `)
    WHERE {{$cps.Where}}
    RETURNING {{$.Table.Returning}}`

  // setup the query
  values := []interface{}{}
  {{- range $cp := $cps.Columns}}
  values = append(values, {{$cp.Camel}})
  {{- end }}
  values = append(values, _v...)
  
  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr, values...)
  }

  // run the query
  var {{$.Table.Camel}} {{$.Table.Pascal}}
  row := m.DB.QueryRow(sqlstr, values...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if e == pgx.ErrNoRows {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &{{$.Table.Camel}}, nil
}
{{ end }}

{{ if .Table.Composite }}
{{ $cps := .Table.Composite }}
// Delete a "{{$.Table.Pascal}}" by its {{$cps.Description}}.
func (m *Model) Delete(ctx context.Context, {{$cps.Params}}) error {
  // sql query
  const sqlstr = `
    DELETE FROM "{{$.Schema.Name}}"."{{$.Table.Name}}"
    WHERE {{$cps.Where}}
  `
  
  // log query if we've provided a logger
  if m.Log != nil {
    m.Log(sqlstr, {{$cps.Variables}})
  }

  // run query
  if _, e := m.DB.Exec(sqlstr, {{$cps.Variables}}); e != nil {
    if e == pgx.ErrNoRows {
      return Err{{$.Table.Pascal}}NotFound
    }
    return e
  }

  return nil
}
{{ end }}

// slice converts our columns into something the sql driver can understand
func slice(columns map[string]interface{}, offset int) (c []string, i []string, v []interface{}) {
	n := offset + 1
	for col, val := range columns {
		c = append(c, `"`+col+`"`)
		i = append(i, "$"+strconv.Itoa(n))
		v = append(v, val)
		n++
	}
	return c, i, v
}
*/}}
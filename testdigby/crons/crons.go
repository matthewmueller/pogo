package crons

import (
	"encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/digby/pogo"
	"github.com/matthewmueller/pogo/testdigby"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrCronNotFound returned if the cron is not found
var ErrCronNotFound = errors.New("cron not found")

// CronInput model for 'public.crons'
type CronInput struct {
	id        *string
	creatorID *string
	runEvery  *int
	runURL    *string
	lastRunAt *time.Time
	createdAt *time.Time
	updatedAt *time.Time
}

// Cron model for "public.crons"
type Cron struct {
	ID        string
	CreatorID string
	RunEvery  int
	RunURL    string
	LastRunAt *time.Time
	CreatedAt *time.Time
	UpdatedAt *time.Time
}

// New "public.crons" API
func New() *CronInput {
	return &CronInput{}
}

// ID sets the "id"
func (cron *CronInput) ID(id string) *CronInput {
	cron.id = &id
	return cron
}

// CreatorID sets the "creatorID"
func (cron *CronInput) CreatorID(creatorID string) *CronInput {
	cron.creatorID = &creatorID
	return cron
}

// RunEvery sets the "runEvery"
func (cron *CronInput) RunEvery(runEvery int) *CronInput {
	cron.runEvery = &runEvery
	return cron
}

// RunURL sets the "runURL"
func (cron *CronInput) RunURL(runURL string) *CronInput {
	cron.runURL = &runURL
	return cron
}

// LastRunAt sets the "lastRunAt"
func (cron *CronInput) LastRunAt(lastRunAt time.Time) *CronInput {
	cron.lastRunAt = &lastRunAt
	return cron
}

// CreatedAt sets the "createdAt"
func (cron *CronInput) CreatedAt(createdAt time.Time) *CronInput {
	cron.createdAt = &createdAt
	return cron
}

// UpdatedAt sets the "updatedAt"
func (cron *CronInput) UpdatedAt(updatedAt time.Time) *CronInput {
	cron.updatedAt = &updatedAt
	return cron
}

// MarshalJSON marshals the "cron" into JSON
func (cron *CronInput) MarshalJSON() ([]byte, error) {
	return json.Marshal(cron)
}

// UnmarshalJSON unmarshals json to a "cron"
func (cron *CronInput) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, cron)
}

func (cron *CronInput) String() string {
	return "cron"
}

func getColumns(cron *CronInput) map[string]interface{} {
	columns := make(map[string]interface{})

	if cron.id != nil {
		columns["id"] = *cron.id
	}

	if cron.creatorID != nil {
		columns["creator_id"] = *cron.creatorID
	}

	if cron.runEvery != nil {
		columns["run_every"] = *cron.runEvery
	}

	if cron.runURL != nil {
		columns["run_url"] = *cron.runURL
	}

	if cron.lastRunAt != nil {
		columns["last_run_at"] = *cron.lastRunAt
	}

	if cron.createdAt != nil {
		columns["created_at"] = *cron.createdAt
	}

	if cron.updatedAt != nil {
		columns["updated_at"] = *cron.updatedAt
	}

	return columns
}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
	condition string
	params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
	return &WhereClause{
		condition: condition,
		params:    params,
	}
}

// Insert a "cron" into the "public.crons"
func Insert(db testdigby.DB, cronInput *CronInput) (*Cron, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := testdigby.Slice(getColumns(cronInput), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
    INSERT INTO "public.crons" (` + strings.Join(_c, ", ") + `)
    VALUES (` + strings.Join(_i, ", ") + `)
    RETURNING "id", "creator_id", "run_every", "run_url", "last_run_at", "created_at", "updated_at"
  `
	testdigby.Log(sqlstr, _v...)

	var cron Cron
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&cron.ID, &cron.CreatorID, &cron.RunEvery, &cron.RunURL, &cron.LastRunAt, &cron.CreatedAt, &cron.UpdatedAt); e != nil {
		return nil, e
	}

	return &cron, nil
}

// Find a "Cron" by "id"
func Find(db pogo.DB, id string) (*Cron, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "creator_id", "run_every", "run_url", "last_run_at", "created_at", "updated_at"
    FROM "public.crons"
    WHERE "id" = $1
  `
	pogo.Log(sqlstr, &id)

	var cron Cron
	row := db.QueryRow(sqlstr, &id)
	if e := row.Scan(&cron.ID, &cron.CreatorID, &cron.RunEvery, &cron.RunURL, &cron.LastRunAt, &cron.CreatedAt, &cron.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrCronNotFound
		}
		return nil, e
	}

	return &cron, nil
}

// FindByID find a cron by id
func FindByID(db testdigby.DB, id string) (*Cron, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "creator_id", "run_every", "run_url", "last_run_at", "created_at", "updated_at"
    FROM "public.crons"
    WHERE "id" = $1
  `
	testdigby.Log(sqlstr, id)

	var cron Cron
	row := db.QueryRow(sqlstr, id)
	err := row.Scan(&cron.ID, &cron.CreatorID, &cron.RunEvery, &cron.RunURL, &cron.LastRunAt, &cron.CreatedAt, &cron.UpdatedAt)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, ErrCronNotFound
		}
		return nil, err
	}

	return &cron, nil
}

// FindOne find one cron by a condition
func FindOne(db testdigby.DB, where *WhereClause) (*Cron, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
  SELECT "id", "creator_id", "run_every", "run_url", "last_run_at", "created_at", "updated_at"
  FROM "public.crons"
  WHERE ` + where.condition
	testdigby.Log(sqlstr, where.params...)

	var cron Cron
	row := db.QueryRow(sqlstr, where.params...)
	if e := row.Scan(&cron.ID, &cron.CreatorID, &cron.RunEvery, &cron.RunURL, &cron.LastRunAt, &cron.CreatedAt, &cron.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrCronNotFound
		}
		return nil, e
	}

	return &cron, nil
}

// FindMany find many "cron"'s by a given condition
func FindMany(db testdigby.DB, where *WhereClause) (crons []*Cron, err error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
  SELECT "id", "creator_id", "run_every", "run_url", "last_run_at", "created_at", "updated_at"
  FROM "public.crons"
  WHERE ` + where.condition
	testdigby.Log(sqlstr, where.params...)

	rows, err := db.Query(sqlstr, where.params...)
	if err != nil {
		return crons, err
	}
	defer rows.Close()

	for rows.Next() {
		var cron Cron
		if e := rows.Scan(&cron.ID, &cron.CreatorID, &cron.RunEvery, &cron.RunURL, &cron.LastRunAt, &cron.CreatedAt, &cron.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return crons, ErrCronNotFound
			}
			return crons, err
		}
		crons = append(crons, &cron)
	}
	if rows.Err() != nil {
		return crons, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	// if len(crons) == 0 {
	// 	return make([]*Cron, 0), nil
	// }

	return crons, nil
}

// Update a "cron" in "public.crons" by its "id"
func Update(db testdigby.DB, id string, cronInput *CronInput) (*Cron, error) {
	fields := getColumns(cronInput)

	// don't update the primary key
	delete(fields, "id")

	// prepare the slices
	_c, _i, _v := testdigby.Slice(fields, 1)

	// sql query
	sqlstr := `UPDATE "public.crons" SET (` +
		strings.Join(_c, ", ") +
		`) = (` +
		strings.Join(_i, ", ") +
		`)
    WHERE "id" = $1
    RETURNING "id", "creator_id", "run_every", "run_url", "last_run_at", "created_at", "updated_at"`

	// setup query
	values := append([]interface{}{&id}, _v...)
	testdigby.Log(sqlstr, values...)

	// run the query
	var cron Cron
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&cron.ID, &cron.CreatorID, &cron.RunEvery, &cron.RunURL, &cron.LastRunAt, &cron.CreatedAt, &cron.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrCronNotFound
		}
		return nil, e
	}

	return &cron, nil
}

// UpdateMany rows in "public.crons" by a given condition
func UpdateMany(db testdigby.DB, where *WhereClause, cronInput *CronInput) (crons []*Cron, err error) {
	// prepare the slices
	_c, _i, _v := testdigby.Slice(getColumns(cronInput), len(where.params))

	// sql query
	sqlstr := `UPDATE "public.crons" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE ` + where.condition + ` ` +
		`RETURNING "id", "creator_id", "run_every", "run_url", "last_run_at", "created_at", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, where.params...)
	values = append(values, _v...)
	testdigby.Log(sqlstr, values...)

	// run query
	rows, err := db.Query(sqlstr, values...)
	if err != nil {
		return crons, err
	}
	defer rows.Close()

	for rows.Next() {
		var cron Cron
		if e := rows.Scan(&cron.ID, &cron.CreatorID, &cron.RunEvery, &cron.RunURL, &cron.LastRunAt, &cron.CreatedAt, &cron.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return crons, ErrCronNotFound
			}
			return crons, err
		}
		crons = append(crons, &cron)
	}
	if rows.Err() != nil {
		return crons, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	// if len(crons) == 0 {
	// 	return make([]*Cron, 0), nil
	// }

	return crons, nil
}

// Delete a "cron" from the "public.crons" table
func Delete(db testdigby.DB, id string) error {
	// sql query
	sqlstr := `DELETE FROM "public.crons" WHERE "id" = $1`
	testdigby.Log(sqlstr, id)

	// run query
	if _, e := db.Exec(sqlstr, id); e != nil {
		if e == pgx.ErrNoRows {
			return ErrCronNotFound
		}
		return e
	}

	return nil
}

// DeleteMany delete many "cron"'s by the given condition
func DeleteMany(db testdigby.DB, where *WhereClause) error {
	// sql select query, primary key provided by sequence
	sqlstr := `DELETE FROM "public.crons" WHERE ` + where.condition
	testdigby.Log(sqlstr, where.params...)

	if _, e := db.Exec(sqlstr, where.params...); e != nil {
		return e
	}

	return nil
}

// Upsert the "cron" by its "id".
func Upsert(db testdigby.DB, cronInput *CronInput) (*Cron, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := testdigby.Slice(getColumns(cronInput), 0)

	// sql query
	sqlstr := `INSERT INTO "public.crons" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "id", "creator_id", "run_every", "run_url", "last_run_at", "created_at", "updated_at"`
	testdigby.Log(sqlstr, _v...)

	// run query
	var cron Cron
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&cron.ID, &cron.CreatorID, &cron.RunEvery, &cron.RunURL, &cron.LastRunAt, &cron.CreatedAt, &cron.UpdatedAt); e != nil {
		return nil, e
	}

	return &cron, nil
}

{{ $shortClass := shortname .Table.TableName }}
{{ $class := classname .Table.TableName }}
{{ $shortModel := shortname .Table.TableName $shortClass }}
{{ $model := modelname .Table.TableName }}
{{ $singular := modelreturn .Table.TableName }}
{{ $return := pluralize $singular }}
package {{ .Package }}

// GENERATED BY POGO. DO NOT EDIT.

import (
	"errors"
	"strings"
)

// UpdateMany rows by the condition
func ({{ $shortClass }} *{{ $class }}) UpdateMany({{ $shortModel }} *{{ $model }}, condition string, params... interface{}) ({{ $return }} []{{ $model }}, err error) {
	fields := {{ $shortClass }}.getFields({{ $shortModel }})

	// prepare the slices
	_c, _i, _v := querySlices(fields, len(params))

	// sql query
	sqlstr := `UPDATE {{ schema .Schema .Table.TableName }} SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
    `WHERE ` + condition + ` ` +
		`RETURNING {{ fields .Columns }}`

  values := []interface{}{}
  values = append(values, params...)
  values = append(values, _v...)

	// run query
	DBLog(sqlstr, values...)
  rows, err := {{ $shortClass }}.DB.Query(sqlstr, values...)
  if err != nil {
    return {{ $return }}, err
  }
  defer rows.Close()

  for rows.Next() {
    {{ $singular }} := {{ $model }}{}
    err = rows.Scan({{ gofields .Columns $singular }})
    if err != nil {
      return {{ $return }}, err
    }
    {{ $return }} = append({{ $return }}, {{ $singular }})
  }

  if rows.Err() != nil {
    return {{ $return }}, rows.Err()
  }

	// ensure we return an empty array
	// rather than nil when we marshal
	if len({{ $return }}) == 0 {
		return make([]{{ $model }}, 0), nil
	}

  return {{ $return }}, nil
}

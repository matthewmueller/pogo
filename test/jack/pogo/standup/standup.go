package standup

import (
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/pogo/test/jack/pogo"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrStandupNotFound returned if the standups is not found
var ErrStandupNotFound = errors.New("standup not found")

// Standup result data for "jack"."standups"
type Standup struct {
	ID       int    `json:"id,omitempty"`
	TeamID   int    `json:"team_id,omitempty"`
	Name     string `json:"name,omitempty"`
	Channel  string `json:"channel,omitempty"`
	Time     string `json:"time,omitempty"`
	Timezone string `json:"timezone,omitempty"`
}

// New "jack"."standups" input
func New() *Input {
	return &Input{}
}

// Input data for "jack"."standups"
type Input struct {
	id       *int
	teamID   *int
	name     *string
	channel  *string
	time     *string
	timezone *string
}

// ID sets the "id"
func (s *Input) ID(id int) *Input {
	s.id = &id
	return s
}

// TeamID sets the "team_id"
func (s *Input) TeamID(teamID int) *Input {
	s.teamID = &teamID
	return s
}

// Name sets the "name"
func (s *Input) Name(name string) *Input {
	s.name = &name
	return s
}

// Channel sets the "channel"
func (s *Input) Channel(channel string) *Input {
	s.channel = &channel
	return s
}

// Time sets the "time"
func (s *Input) Time(time string) *Input {
	s.time = &time
	return s
}

// Timezone sets the "timezone"
func (s *Input) Timezone(timezone string) *Input {
	s.timezone = &timezone
	return s
}

// MarshalJSON marshals the "standup" into JSON
func (s *Input) MarshalJSON() ([]byte, error) {
	return json.Marshal(s)
}

// UnmarshalJSON unmarshals json to a "standup"
func (s *Input) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, s)
}

func (s *Input) String() string {
	return "standups"
}

func (s *Input) columns() map[string]interface{} {
	columns := make(map[string]interface{})

	if s.id != nil {
		columns["id"] = *s.id
	}

	if s.teamID != nil {
		columns["team_id"] = *s.teamID
	}

	if s.name != nil {
		columns["name"] = *s.name
	}

	if s.channel != nil {
		columns["channel"] = *s.channel
	}

	if s.time != nil {
		columns["time"] = *s.time
	}

	if s.timezone != nil {
		columns["timezone"] = *s.timezone
	}

	return columns
}

// NewFilter creates a new filter
func NewFilter() *Filter {
	return &Filter{}
}

// Filter filters for "jack"."standups"
type Filter struct {
	formats []string
	values  []interface{}
}

var _ pogo.Condition = (*Filter)(nil)

// Clause fn
func (f *Filter) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "WHERE",
		Format: strings.Join(f.formats, " AND "),
		Params: f.values,
	}
}

// And filter
// func (f *Filter) And(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " AND "))
//   return f
// }

// Or filter
// func (f *Filter) Or(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " OR "))
//   return f
// }

// ID id equals
func (f *Filter) ID(v int) *Filter {
	f.formats = append(f.formats, `id = %s`)
	f.values = append(f.values, v)
	return f
}

// IDNot id doesn't equal
func (f *Filter) IDNot(v int) *Filter {
	f.formats = append(f.formats, `id != %s`)
	f.values = append(f.values, v)
	return f
}

// IDLt id is less than
func (f *Filter) IDLt(v int) *Filter {
	f.formats = append(f.formats, `id < %s`)
	f.values = append(f.values, v)
	return f
}

// IDLte id is less than or equal
func (f *Filter) IDLte(v int) *Filter {
	f.formats = append(f.formats, `id <= %s`)
	f.values = append(f.values, v)
	return f
}

// IDGt id is greater than
func (f *Filter) IDGt(v int) *Filter {
	f.formats = append(f.formats, `id > %s`)
	f.values = append(f.values, v)
	return f
}

// IDGte id is greater than or equal
func (f *Filter) IDGte(v int) *Filter {
	f.formats = append(f.formats, `id >= %s`)
	f.values = append(f.values, v)
	return f
}

// IDIn id is in
func (f *Filter) IDIn(v int) *Filter {
	f.formats = append(f.formats, `id IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// IDNotIn id is not in
func (f *Filter) IDNotIn(v int) *Filter {
	f.formats = append(f.formats, `id NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// TeamID team_id equals
func (f *Filter) TeamID(v int) *Filter {
	f.formats = append(f.formats, `team_id = %s`)
	f.values = append(f.values, v)
	return f
}

// TeamIDNot team_id doesn't equal
func (f *Filter) TeamIDNot(v int) *Filter {
	f.formats = append(f.formats, `team_id != %s`)
	f.values = append(f.values, v)
	return f
}

// TeamIDLt team_id is less than
func (f *Filter) TeamIDLt(v int) *Filter {
	f.formats = append(f.formats, `team_id < %s`)
	f.values = append(f.values, v)
	return f
}

// TeamIDLte team_id is less than or equal
func (f *Filter) TeamIDLte(v int) *Filter {
	f.formats = append(f.formats, `team_id <= %s`)
	f.values = append(f.values, v)
	return f
}

// TeamIDGt team_id is greater than
func (f *Filter) TeamIDGt(v int) *Filter {
	f.formats = append(f.formats, `team_id > %s`)
	f.values = append(f.values, v)
	return f
}

// TeamIDGte team_id is greater than or equal
func (f *Filter) TeamIDGte(v int) *Filter {
	f.formats = append(f.formats, `team_id >= %s`)
	f.values = append(f.values, v)
	return f
}

// TeamIDIn team_id is in
func (f *Filter) TeamIDIn(v int) *Filter {
	f.formats = append(f.formats, `team_id IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// TeamIDNotIn team_id is not in
func (f *Filter) TeamIDNotIn(v int) *Filter {
	f.formats = append(f.formats, `team_id NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// Name name equals
func (f *Filter) Name(v string) *Filter {
	f.formats = append(f.formats, `name = %s`)
	f.values = append(f.values, v)
	return f
}

// NameNot name doesn't equal
func (f *Filter) NameNot(v string) *Filter {
	f.formats = append(f.formats, `name != %s`)
	f.values = append(f.values, v)
	return f
}

// NameContains name contains
func (f *Filter) NameContains(v string) *Filter {
	f.formats = append(f.formats, `name LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// NameNotContains name doesn't contain
func (f *Filter) NameNotContains(v string) *Filter {
	f.formats = append(f.formats, `name NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// NameStartsWith name starts with
func (f *Filter) NameStartsWith(v string) *Filter {
	f.formats = append(f.formats, `name LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// NameNotStartsWith name doesn't start with
func (f *Filter) NameNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `name NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// NameEndsWith name ends with
func (f *Filter) NameEndsWith(v string) *Filter {
	f.formats = append(f.formats, `name LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// NameNotEndsWith name doesn't end with
func (f *Filter) NameNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `name NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// NameLt name is less than
func (f *Filter) NameLt(v string) *Filter {
	f.formats = append(f.formats, `name < %s`)
	f.values = append(f.values, v)
	return f
}

// NameLte name is less than or equal
func (f *Filter) NameLte(v string) *Filter {
	f.formats = append(f.formats, `name <= %s`)
	f.values = append(f.values, v)
	return f
}

// NameGt name is greater than
func (f *Filter) NameGt(v string) *Filter {
	f.formats = append(f.formats, `name > %s`)
	f.values = append(f.values, v)
	return f
}

// NameGte name is greater than or equal
func (f *Filter) NameGte(v string) *Filter {
	f.formats = append(f.formats, `name >= %s`)
	f.values = append(f.values, v)
	return f
}

// NameIn name is in
func (f *Filter) NameIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`name IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// NameNotIn name is not in
func (f *Filter) NameNotIn(v string) *Filter {
	f.formats = append(f.formats, `name NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// Channel channel equals
func (f *Filter) Channel(v string) *Filter {
	f.formats = append(f.formats, `channel = %s`)
	f.values = append(f.values, v)
	return f
}

// ChannelNot channel doesn't equal
func (f *Filter) ChannelNot(v string) *Filter {
	f.formats = append(f.formats, `channel != %s`)
	f.values = append(f.values, v)
	return f
}

// ChannelContains channel contains
func (f *Filter) ChannelContains(v string) *Filter {
	f.formats = append(f.formats, `channel LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// ChannelNotContains channel doesn't contain
func (f *Filter) ChannelNotContains(v string) *Filter {
	f.formats = append(f.formats, `channel NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// ChannelStartsWith channel starts with
func (f *Filter) ChannelStartsWith(v string) *Filter {
	f.formats = append(f.formats, `channel LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// ChannelNotStartsWith channel doesn't start with
func (f *Filter) ChannelNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `channel NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// ChannelEndsWith channel ends with
func (f *Filter) ChannelEndsWith(v string) *Filter {
	f.formats = append(f.formats, `channel LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// ChannelNotEndsWith channel doesn't end with
func (f *Filter) ChannelNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `channel NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// ChannelLt channel is less than
func (f *Filter) ChannelLt(v string) *Filter {
	f.formats = append(f.formats, `channel < %s`)
	f.values = append(f.values, v)
	return f
}

// ChannelLte channel is less than or equal
func (f *Filter) ChannelLte(v string) *Filter {
	f.formats = append(f.formats, `channel <= %s`)
	f.values = append(f.values, v)
	return f
}

// ChannelGt channel is greater than
func (f *Filter) ChannelGt(v string) *Filter {
	f.formats = append(f.formats, `channel > %s`)
	f.values = append(f.values, v)
	return f
}

// ChannelGte channel is greater than or equal
func (f *Filter) ChannelGte(v string) *Filter {
	f.formats = append(f.formats, `channel >= %s`)
	f.values = append(f.values, v)
	return f
}

// ChannelIn channel is in
func (f *Filter) ChannelIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`channel IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// ChannelNotIn channel is not in
func (f *Filter) ChannelNotIn(v string) *Filter {
	f.formats = append(f.formats, `channel NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// Time time equals
func (f *Filter) Time(v string) *Filter {
	f.formats = append(f.formats, `time = %s`)
	f.values = append(f.values, v)
	return f
}

// TimeNot time doesn't equal
func (f *Filter) TimeNot(v string) *Filter {
	f.formats = append(f.formats, `time != %s`)
	f.values = append(f.values, v)
	return f
}

// TimeContains time contains
func (f *Filter) TimeContains(v string) *Filter {
	f.formats = append(f.formats, `time LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// TimeNotContains time doesn't contain
func (f *Filter) TimeNotContains(v string) *Filter {
	f.formats = append(f.formats, `time NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// TimeStartsWith time starts with
func (f *Filter) TimeStartsWith(v string) *Filter {
	f.formats = append(f.formats, `time LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// TimeNotStartsWith time doesn't start with
func (f *Filter) TimeNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `time NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// TimeEndsWith time ends with
func (f *Filter) TimeEndsWith(v string) *Filter {
	f.formats = append(f.formats, `time LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// TimeNotEndsWith time doesn't end with
func (f *Filter) TimeNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `time NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// TimeLt time is less than
func (f *Filter) TimeLt(v string) *Filter {
	f.formats = append(f.formats, `time < %s`)
	f.values = append(f.values, v)
	return f
}

// TimeLte time is less than or equal
func (f *Filter) TimeLte(v string) *Filter {
	f.formats = append(f.formats, `time <= %s`)
	f.values = append(f.values, v)
	return f
}

// TimeGt time is greater than
func (f *Filter) TimeGt(v string) *Filter {
	f.formats = append(f.formats, `time > %s`)
	f.values = append(f.values, v)
	return f
}

// TimeGte time is greater than or equal
func (f *Filter) TimeGte(v string) *Filter {
	f.formats = append(f.formats, `time >= %s`)
	f.values = append(f.values, v)
	return f
}

// TimeIn time is in
func (f *Filter) TimeIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`time IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// TimeNotIn time is not in
func (f *Filter) TimeNotIn(v string) *Filter {
	f.formats = append(f.formats, `time NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// Timezone timezone equals
func (f *Filter) Timezone(v string) *Filter {
	f.formats = append(f.formats, `timezone = %s`)
	f.values = append(f.values, v)
	return f
}

// TimezoneNot timezone doesn't equal
func (f *Filter) TimezoneNot(v string) *Filter {
	f.formats = append(f.formats, `timezone != %s`)
	f.values = append(f.values, v)
	return f
}

// TimezoneContains timezone contains
func (f *Filter) TimezoneContains(v string) *Filter {
	f.formats = append(f.formats, `timezone LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// TimezoneNotContains timezone doesn't contain
func (f *Filter) TimezoneNotContains(v string) *Filter {
	f.formats = append(f.formats, `timezone NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// TimezoneStartsWith timezone starts with
func (f *Filter) TimezoneStartsWith(v string) *Filter {
	f.formats = append(f.formats, `timezone LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// TimezoneNotStartsWith timezone doesn't start with
func (f *Filter) TimezoneNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `timezone NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// TimezoneEndsWith timezone ends with
func (f *Filter) TimezoneEndsWith(v string) *Filter {
	f.formats = append(f.formats, `timezone LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// TimezoneNotEndsWith timezone doesn't end with
func (f *Filter) TimezoneNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `timezone NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// TimezoneLt timezone is less than
func (f *Filter) TimezoneLt(v string) *Filter {
	f.formats = append(f.formats, `timezone < %s`)
	f.values = append(f.values, v)
	return f
}

// TimezoneLte timezone is less than or equal
func (f *Filter) TimezoneLte(v string) *Filter {
	f.formats = append(f.formats, `timezone <= %s`)
	f.values = append(f.values, v)
	return f
}

// TimezoneGt timezone is greater than
func (f *Filter) TimezoneGt(v string) *Filter {
	f.formats = append(f.formats, `timezone > %s`)
	f.values = append(f.values, v)
	return f
}

// TimezoneGte timezone is greater than or equal
func (f *Filter) TimezoneGte(v string) *Filter {
	f.formats = append(f.formats, `timezone >= %s`)
	f.values = append(f.values, v)
	return f
}

// TimezoneIn timezone is in
func (f *Filter) TimezoneIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`timezone IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// TimezoneNotIn timezone is not in
func (f *Filter) TimezoneNotIn(v string) *Filter {
	f.formats = append(f.formats, `timezone NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// OrderBy specificies the ORDERBy BY <order>
type OrderBy string

const (
	// Asc sorts by ascending order
	ASC OrderBy = "ASC"

	// Desc sorts by descending order
	DESC OrderBy = "DESC"
)

// NewOrder fn
func NewOrder() *Order {
	return &Order{}
}

// Order orders the given fields
type Order struct {
	formats []string
}

// Clause fn
func (o *Order) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "ORDER BY",
		Format: strings.Join(o.formats, ", "),
	}
}

// ID sorts `id` by an expression
func (o *Order) ID(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"id" %s`, order))
	return o
}

// TeamID sorts `team_id` by an expression
func (o *Order) TeamID(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"team_id" %s`, order))
	return o
}

// Name sorts `name` by an expression
func (o *Order) Name(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"name" %s`, order))
	return o
}

// Channel sorts `channel` by an expression
func (o *Order) Channel(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"channel" %s`, order))
	return o
}

// Time sorts `time` by an expression
func (o *Order) Time(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"time" %s`, order))
	return o
}

// Timezone sorts `timezone` by an expression
func (o *Order) Timezone(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"timezone" %s`, order))
	return o
}

// Insert a "standups" into the "jack"."standups"
func Insert(db pogo.DB, standup *Input) (*Standup, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(standup.columns(), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
    INSERT INTO "jack"."standups" (` + strings.Join(_c, ", ") + `)
    VALUES (` + strings.Join(_i, ", ") + `)
    RETURNING "id", "team_id", "name", "channel", "time", "timezone"
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _standup Standup
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_standup.ID, &_standup.TeamID, &_standup.Name, &_standup.Channel, &_standup.Time, &_standup.Timezone); e != nil {
		return nil, e
	}

	return &_standup, nil
}

// Find a `Standup` by some conditions.
func Find(db pogo.DB, conds ...pogo.Condition) (*Standup, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "id", "team_id", "name", "channel", "time", "timezone" ` +
		`FROM "jack"."standups" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _standup Standup
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_standup.ID, &_standup.TeamID, &_standup.Name, &_standup.Channel, &_standup.Time, &_standup.Timezone); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, e
	}

	return &_standup, nil
}

// FindByID a `Standup` by some conditions.
func FindByID(db pogo.DB, id int) (*Standup, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "team_id", "name", "channel", "time", "timezone"
    FROM "jack"."standups"
    WHERE "id" = $1
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, &id)
	}

	var _standup Standup
	row := db.QueryRow(sqlstr, &id)
	if e := row.Scan(&_standup.ID, &_standup.TeamID, &_standup.Name, &_standup.Channel, &_standup.Time, &_standup.Timezone); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, e
	}

	return &_standup, nil
}

// FindByChannel find a standup by channel
func FindByChannel(db pogo.DB, channel string) (*Standup, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "team_id", "name", "channel", "time", "timezone"
    FROM "jack"."standups"
    WHERE "channel" = $1
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, channel)
	}

	var _standup Standup
	row := db.QueryRow(sqlstr, channel)
	err := row.Scan(&_standup.ID, &_standup.TeamID, &_standup.Name, &_standup.Channel, &_standup.Time, &_standup.Timezone)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, err
	}

	return &_standup, nil
}

// FindMany finds many "jack"."standups" by a condition
func FindMany(db pogo.DB, conds ...pogo.Condition) ([]*Standup, error) {
	var standups []*Standup

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return standups, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "id", "team_id", "name", "channel", "time", "timezone" ` +
		`FROM "jack"."standups" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return standups, err
	}
	defer rows.Close()

	for rows.Next() {
		var _standup Standup
		if e := rows.Scan(&_standup.ID, &_standup.TeamID, &_standup.Name, &_standup.Channel, &_standup.Time, &_standup.Timezone); e != nil {
			if e == pgx.ErrNoRows {
				return standups, ErrStandupNotFound
			}
			return standups, err
		}
		standups = append(standups, &_standup)
	}
	if rows.Err() != nil {
		return standups, rows.Err()
	}

	return standups, nil
}

// UpdateByID a "standup" in "jack"."standups" by its "id"
func UpdateByID(db pogo.DB, id int, standup *Input) (*Standup, error) {
	fields := standup.columns()

	// don't update the primary key
	delete(fields, "id")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// sql query
	sqlstr := `UPDATE "jack"."standups" SET ` +
		strings.Join(_u, ", ") + ` ` +
		`WHERE "id" = $1 ` +
		`RETURNING "id", "team_id", "name", "channel", "time", "timezone"`

	// setup query
	values := append([]interface{}{&id}, _v...)

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, values...)
	}

	// run the query
	var _standup Standup
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&_standup.ID, &_standup.TeamID, &_standup.Name, &_standup.Channel, &_standup.Time, &_standup.Timezone); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, e
	}

	return &_standup, nil
}

// UpdateByChannel find a Standup
func UpdateByChannel(db pogo.DB, channel string, standup *Input) (*Standup, error) {
	// add values to input, overriding existing keys if present in the input
	standup = standup.Channel(channel)

	// get the columns
	fields := standup.columns()

	// don't update the keys
	delete(fields, "channel")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// sql query
	sqlstr := `UPDATE "jack"."standups" SET ` +
		strings.Join(_u, ", ") + ` ` +
		`WHERE "channel" = $1 ` +
		`RETURNING "id", "team_id", "name", "channel", "time", "timezone"`

	// setup the query
	values := []interface{}{}
	values = append(values, channel)
	values = append(values, _v...)

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, values...)
	}

	// run the query
	var _standup Standup
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&_standup.ID, &_standup.TeamID, &_standup.Name, &_standup.Channel, &_standup.Time, &_standup.Timezone); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, e
	}

	return &_standup, nil
}

// Delete `Standup`s by some conditions. Returns the first result.
func Delete(db pogo.DB, conds ...pogo.Condition) (*Standup, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql delete query
	sqlstr := `DELETE FROM "jack"."standups" ` +
		_s + ` ` +
		`RETURNING "id", "team_id", "name", "channel", "time", "timezone"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _standup Standup
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_standup.ID, &_standup.TeamID, &_standup.Name, &_standup.Channel, &_standup.Time, &_standup.Timezone); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, e
	}

	return &_standup, nil
}

// DeleteMany `Standup`s by some conditions, returning all results.
func DeleteMany(db pogo.DB, conds ...pogo.Condition) ([]*Standup, error) {
	var standups []*Standup

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return standups, err
	}

	// sql delete query
	sqlstr := `DELETE FROM "jack"."standups" ` +
		_s + ` ` +
		`RETURNING "id", "team_id", "name", "channel", "time", "timezone"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return standups, err
	}
	defer rows.Close()

	for rows.Next() {
		var _standup Standup
		if e := rows.Scan(&_standup.ID, &_standup.TeamID, &_standup.Name, &_standup.Channel, &_standup.Time, &_standup.Timezone); e != nil {
			if e == pgx.ErrNoRows {
				return standups, ErrStandupNotFound
			}
			return standups, err
		}
		standups = append(standups, &_standup)
	}
	if rows.Err() != nil {
		return standups, rows.Err()
	}

	return standups, nil
}

// DeleteByID a "standup" from the "jack"."standups" table
func DeleteByID(db pogo.DB, id int) (*Standup, error) {
	// sql delete query
	sqlstr := `DELETE FROM "jack"."standups" ` +
		`WHERE "id" = $1 ` +
		`RETURNING "id", "team_id", "name", "channel", "time", "timezone"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, id)
	}

	// run the query
	var _standup Standup
	row := db.QueryRow(sqlstr, id)
	if e := row.Scan(&_standup.ID, &_standup.TeamID, &_standup.Name, &_standup.Channel, &_standup.Time, &_standup.Timezone); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, e
	}

	return &_standup, nil
}

// DeleteByChannel deletes a "standup"
func DeleteByChannel(db pogo.DB, channel string) (*Standup, error) {
	// sql delete query
	sqlstr := `DELETE FROM "jack"."standups" ` +
		`WHERE "channel" = $1 ` +
		`RETURNING "id", "team_id", "name", "channel", "time", "timezone"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, channel)
	}

	// run the query
	var _standup Standup
	row := db.QueryRow(sqlstr, channel)
	if e := row.Scan(&_standup.ID, &_standup.TeamID, &_standup.Name, &_standup.Channel, &_standup.Time, &_standup.Timezone); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, e
	}

	return &_standup, nil
}

// UpsertByChannel find a "Standup"
func UpsertByChannel(db pogo.DB, channel string, standup *Input) (*Standup, error) {
	// add values to input, overriding existing keys if present in the input
	standup = standup.Channel(channel)

	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(standup.columns(), 0)

	// sql query
	sqlstr := `INSERT INTO "jack"."standups" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("channel") ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "id", "team_id", "name", "channel", "time", "timezone"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run query
	var _standup Standup
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_standup.ID, &_standup.TeamID, &_standup.Name, &_standup.Channel, &_standup.Time, &_standup.Timezone); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &_standup, nil
}

// slice converts our columns into something the sql driver can understand
func slice(columns map[string]interface{}, offset int) (c []string, i []string, v []interface{}) {
	n := offset + 1
	for col, val := range columns {
		c = append(c, `"`+col+`"`)
		i = append(i, "$"+strconv.Itoa(n))
		v = append(v, val)
		n++
	}
	return c, i, v
}

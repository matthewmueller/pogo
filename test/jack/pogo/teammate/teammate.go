package teammate

import (
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/pogo/test/jack/pogo"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrTeammateNotFound returned if the teammates is not found
var ErrTeammateNotFound = errors.New("teammate not found")

// Teammate result data for "jack"."teammates"
type Teammate struct {
	ID        int     `json:"id,omitempty"`
	TeamID    int     `json:"team_id,omitempty"`
	SlackID   string  `json:"slack_id,omitempty"`
	Username  string  `json:"username,omitempty"`
	FirstName *string `json:"first_name,omitempty"`
	LastName  *string `json:"last_name,omitempty"`
	Email     *string `json:"email,omitempty"`
	Avatar    *string `json:"avatar,omitempty"`
	Timezone  string  `json:"timezone,omitempty"`
}

// New "jack"."teammates" input
func New() *Input {
	return &Input{}
}

// Input data for "jack"."teammates"
type Input struct {
	id        *int
	teamID    *int
	slackID   *string
	username  *string
	firstName *string
	lastName  *string
	email     *string
	avatar    *string
	timezone  *string
}

// ID sets the "id"
func (t *Input) ID(id int) *Input {
	t.id = &id
	return t
}

// TeamID sets the "team_id"
func (t *Input) TeamID(teamID int) *Input {
	t.teamID = &teamID
	return t
}

// SlackID sets the "slack_id"
func (t *Input) SlackID(slackID string) *Input {
	t.slackID = &slackID
	return t
}

// Username sets the "username"
func (t *Input) Username(username string) *Input {
	t.username = &username
	return t
}

// FirstName sets the "first_name"
func (t *Input) FirstName(firstName string) *Input {
	t.firstName = &firstName
	return t
}

// LastName sets the "last_name"
func (t *Input) LastName(lastName string) *Input {
	t.lastName = &lastName
	return t
}

// Email sets the "email"
func (t *Input) Email(email string) *Input {
	t.email = &email
	return t
}

// Avatar sets the "avatar"
func (t *Input) Avatar(avatar string) *Input {
	t.avatar = &avatar
	return t
}

// Timezone sets the "timezone"
func (t *Input) Timezone(timezone string) *Input {
	t.timezone = &timezone
	return t
}

// MarshalJSON marshals the "teammate" into JSON
func (t *Input) MarshalJSON() ([]byte, error) {
	return json.Marshal(t)
}

// UnmarshalJSON unmarshals json to a "teammate"
func (t *Input) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, t)
}

func (t *Input) String() string {
	return "teammates"
}

func (t *Input) columns() map[string]interface{} {
	columns := make(map[string]interface{})

	if t.id != nil {
		columns["id"] = *t.id
	}

	if t.teamID != nil {
		columns["team_id"] = *t.teamID
	}

	if t.slackID != nil {
		columns["slack_id"] = *t.slackID
	}

	if t.username != nil {
		columns["username"] = *t.username
	}

	if t.firstName != nil {
		columns["first_name"] = *t.firstName
	}

	if t.lastName != nil {
		columns["last_name"] = *t.lastName
	}

	if t.email != nil {
		columns["email"] = *t.email
	}

	if t.avatar != nil {
		columns["avatar"] = *t.avatar
	}

	if t.timezone != nil {
		columns["timezone"] = *t.timezone
	}

	return columns
}

// NewFilter creates a new filter
func NewFilter() *Filter {
	return &Filter{}
}

// Filter filters for "jack"."teammates"
type Filter struct {
	formats []string
	values  []interface{}
}

var _ pogo.Condition = (*Filter)(nil)

// Clause fn
func (f *Filter) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "WHERE",
		Format: strings.Join(f.formats, " AND "),
		Params: f.values,
	}
}

// And filter
// func (f *Filter) And(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " AND "))
//   return f
// }

// Or filter
// func (f *Filter) Or(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " OR "))
//   return f
// }

// ID id equals
func (f *Filter) ID(v int) *Filter {
	f.formats = append(f.formats, `id = %s`)
	f.values = append(f.values, v)
	return f
}

// IDNot id doesn't equal
func (f *Filter) IDNot(v int) *Filter {
	f.formats = append(f.formats, `id != %s`)
	f.values = append(f.values, v)
	return f
}

// IDLt id is less than
func (f *Filter) IDLt(v int) *Filter {
	f.formats = append(f.formats, `id < %s`)
	f.values = append(f.values, v)
	return f
}

// IDLte id is less than or equal
func (f *Filter) IDLte(v int) *Filter {
	f.formats = append(f.formats, `id <= %s`)
	f.values = append(f.values, v)
	return f
}

// IDGt id is greater than
func (f *Filter) IDGt(v int) *Filter {
	f.formats = append(f.formats, `id > %s`)
	f.values = append(f.values, v)
	return f
}

// IDGte id is greater than or equal
func (f *Filter) IDGte(v int) *Filter {
	f.formats = append(f.formats, `id >= %s`)
	f.values = append(f.values, v)
	return f
}

// IDIn id is in
func (f *Filter) IDIn(v int) *Filter {
	f.formats = append(f.formats, `id IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// IDNotIn id is not in
func (f *Filter) IDNotIn(v int) *Filter {
	f.formats = append(f.formats, `id NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// TeamID team_id equals
func (f *Filter) TeamID(v int) *Filter {
	f.formats = append(f.formats, `team_id = %s`)
	f.values = append(f.values, v)
	return f
}

// TeamIDNot team_id doesn't equal
func (f *Filter) TeamIDNot(v int) *Filter {
	f.formats = append(f.formats, `team_id != %s`)
	f.values = append(f.values, v)
	return f
}

// TeamIDLt team_id is less than
func (f *Filter) TeamIDLt(v int) *Filter {
	f.formats = append(f.formats, `team_id < %s`)
	f.values = append(f.values, v)
	return f
}

// TeamIDLte team_id is less than or equal
func (f *Filter) TeamIDLte(v int) *Filter {
	f.formats = append(f.formats, `team_id <= %s`)
	f.values = append(f.values, v)
	return f
}

// TeamIDGt team_id is greater than
func (f *Filter) TeamIDGt(v int) *Filter {
	f.formats = append(f.formats, `team_id > %s`)
	f.values = append(f.values, v)
	return f
}

// TeamIDGte team_id is greater than or equal
func (f *Filter) TeamIDGte(v int) *Filter {
	f.formats = append(f.formats, `team_id >= %s`)
	f.values = append(f.values, v)
	return f
}

// TeamIDIn team_id is in
func (f *Filter) TeamIDIn(v int) *Filter {
	f.formats = append(f.formats, `team_id IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// TeamIDNotIn team_id is not in
func (f *Filter) TeamIDNotIn(v int) *Filter {
	f.formats = append(f.formats, `team_id NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// SlackID slack_id equals
func (f *Filter) SlackID(v string) *Filter {
	f.formats = append(f.formats, `slack_id = %s`)
	f.values = append(f.values, v)
	return f
}

// SlackIDNot slack_id doesn't equal
func (f *Filter) SlackIDNot(v string) *Filter {
	f.formats = append(f.formats, `slack_id != %s`)
	f.values = append(f.values, v)
	return f
}

// SlackIDContains slack_id contains
func (f *Filter) SlackIDContains(v string) *Filter {
	f.formats = append(f.formats, `slack_id LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// SlackIDNotContains slack_id doesn't contain
func (f *Filter) SlackIDNotContains(v string) *Filter {
	f.formats = append(f.formats, `slack_id NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// SlackIDStartsWith slack_id starts with
func (f *Filter) SlackIDStartsWith(v string) *Filter {
	f.formats = append(f.formats, `slack_id LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// SlackIDNotStartsWith slack_id doesn't start with
func (f *Filter) SlackIDNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `slack_id NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// SlackIDEndsWith slack_id ends with
func (f *Filter) SlackIDEndsWith(v string) *Filter {
	f.formats = append(f.formats, `slack_id LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// SlackIDNotEndsWith slack_id doesn't end with
func (f *Filter) SlackIDNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `slack_id NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// SlackIDLt slack_id is less than
func (f *Filter) SlackIDLt(v string) *Filter {
	f.formats = append(f.formats, `slack_id < %s`)
	f.values = append(f.values, v)
	return f
}

// SlackIDLte slack_id is less than or equal
func (f *Filter) SlackIDLte(v string) *Filter {
	f.formats = append(f.formats, `slack_id <= %s`)
	f.values = append(f.values, v)
	return f
}

// SlackIDGt slack_id is greater than
func (f *Filter) SlackIDGt(v string) *Filter {
	f.formats = append(f.formats, `slack_id > %s`)
	f.values = append(f.values, v)
	return f
}

// SlackIDGte slack_id is greater than or equal
func (f *Filter) SlackIDGte(v string) *Filter {
	f.formats = append(f.formats, `slack_id >= %s`)
	f.values = append(f.values, v)
	return f
}

// SlackIDIn slack_id is in
func (f *Filter) SlackIDIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`slack_id IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// SlackIDNotIn slack_id is not in
func (f *Filter) SlackIDNotIn(v string) *Filter {
	f.formats = append(f.formats, `slack_id NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// Username username equals
func (f *Filter) Username(v string) *Filter {
	f.formats = append(f.formats, `username = %s`)
	f.values = append(f.values, v)
	return f
}

// UsernameNot username doesn't equal
func (f *Filter) UsernameNot(v string) *Filter {
	f.formats = append(f.formats, `username != %s`)
	f.values = append(f.values, v)
	return f
}

// UsernameContains username contains
func (f *Filter) UsernameContains(v string) *Filter {
	f.formats = append(f.formats, `username LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// UsernameNotContains username doesn't contain
func (f *Filter) UsernameNotContains(v string) *Filter {
	f.formats = append(f.formats, `username NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// UsernameStartsWith username starts with
func (f *Filter) UsernameStartsWith(v string) *Filter {
	f.formats = append(f.formats, `username LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// UsernameNotStartsWith username doesn't start with
func (f *Filter) UsernameNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `username NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// UsernameEndsWith username ends with
func (f *Filter) UsernameEndsWith(v string) *Filter {
	f.formats = append(f.formats, `username LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// UsernameNotEndsWith username doesn't end with
func (f *Filter) UsernameNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `username NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// UsernameLt username is less than
func (f *Filter) UsernameLt(v string) *Filter {
	f.formats = append(f.formats, `username < %s`)
	f.values = append(f.values, v)
	return f
}

// UsernameLte username is less than or equal
func (f *Filter) UsernameLte(v string) *Filter {
	f.formats = append(f.formats, `username <= %s`)
	f.values = append(f.values, v)
	return f
}

// UsernameGt username is greater than
func (f *Filter) UsernameGt(v string) *Filter {
	f.formats = append(f.formats, `username > %s`)
	f.values = append(f.values, v)
	return f
}

// UsernameGte username is greater than or equal
func (f *Filter) UsernameGte(v string) *Filter {
	f.formats = append(f.formats, `username >= %s`)
	f.values = append(f.values, v)
	return f
}

// UsernameIn username is in
func (f *Filter) UsernameIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`username IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// UsernameNotIn username is not in
func (f *Filter) UsernameNotIn(v string) *Filter {
	f.formats = append(f.formats, `username NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// FirstName first_name equals
func (f *Filter) FirstName(v string) *Filter {
	f.formats = append(f.formats, `first_name = %s`)
	f.values = append(f.values, v)
	return f
}

// FirstNameNot first_name doesn't equal
func (f *Filter) FirstNameNot(v string) *Filter {
	f.formats = append(f.formats, `first_name != %s`)
	f.values = append(f.values, v)
	return f
}

// FirstNameContains first_name contains
func (f *Filter) FirstNameContains(v string) *Filter {
	f.formats = append(f.formats, `first_name LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// FirstNameNotContains first_name doesn't contain
func (f *Filter) FirstNameNotContains(v string) *Filter {
	f.formats = append(f.formats, `first_name NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// FirstNameStartsWith first_name starts with
func (f *Filter) FirstNameStartsWith(v string) *Filter {
	f.formats = append(f.formats, `first_name LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// FirstNameNotStartsWith first_name doesn't start with
func (f *Filter) FirstNameNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `first_name NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// FirstNameEndsWith first_name ends with
func (f *Filter) FirstNameEndsWith(v string) *Filter {
	f.formats = append(f.formats, `first_name LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// FirstNameNotEndsWith first_name doesn't end with
func (f *Filter) FirstNameNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `first_name NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// FirstNameLt first_name is less than
func (f *Filter) FirstNameLt(v string) *Filter {
	f.formats = append(f.formats, `first_name < %s`)
	f.values = append(f.values, v)
	return f
}

// FirstNameLte first_name is less than or equal
func (f *Filter) FirstNameLte(v string) *Filter {
	f.formats = append(f.formats, `first_name <= %s`)
	f.values = append(f.values, v)
	return f
}

// FirstNameGt first_name is greater than
func (f *Filter) FirstNameGt(v string) *Filter {
	f.formats = append(f.formats, `first_name > %s`)
	f.values = append(f.values, v)
	return f
}

// FirstNameGte first_name is greater than or equal
func (f *Filter) FirstNameGte(v string) *Filter {
	f.formats = append(f.formats, `first_name >= %s`)
	f.values = append(f.values, v)
	return f
}

// FirstNameIn first_name is in
func (f *Filter) FirstNameIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`first_name IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// FirstNameNotIn first_name is not in
func (f *Filter) FirstNameNotIn(v string) *Filter {
	f.formats = append(f.formats, `first_name NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// LastName last_name equals
func (f *Filter) LastName(v string) *Filter {
	f.formats = append(f.formats, `last_name = %s`)
	f.values = append(f.values, v)
	return f
}

// LastNameNot last_name doesn't equal
func (f *Filter) LastNameNot(v string) *Filter {
	f.formats = append(f.formats, `last_name != %s`)
	f.values = append(f.values, v)
	return f
}

// LastNameContains last_name contains
func (f *Filter) LastNameContains(v string) *Filter {
	f.formats = append(f.formats, `last_name LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// LastNameNotContains last_name doesn't contain
func (f *Filter) LastNameNotContains(v string) *Filter {
	f.formats = append(f.formats, `last_name NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// LastNameStartsWith last_name starts with
func (f *Filter) LastNameStartsWith(v string) *Filter {
	f.formats = append(f.formats, `last_name LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// LastNameNotStartsWith last_name doesn't start with
func (f *Filter) LastNameNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `last_name NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// LastNameEndsWith last_name ends with
func (f *Filter) LastNameEndsWith(v string) *Filter {
	f.formats = append(f.formats, `last_name LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// LastNameNotEndsWith last_name doesn't end with
func (f *Filter) LastNameNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `last_name NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// LastNameLt last_name is less than
func (f *Filter) LastNameLt(v string) *Filter {
	f.formats = append(f.formats, `last_name < %s`)
	f.values = append(f.values, v)
	return f
}

// LastNameLte last_name is less than or equal
func (f *Filter) LastNameLte(v string) *Filter {
	f.formats = append(f.formats, `last_name <= %s`)
	f.values = append(f.values, v)
	return f
}

// LastNameGt last_name is greater than
func (f *Filter) LastNameGt(v string) *Filter {
	f.formats = append(f.formats, `last_name > %s`)
	f.values = append(f.values, v)
	return f
}

// LastNameGte last_name is greater than or equal
func (f *Filter) LastNameGte(v string) *Filter {
	f.formats = append(f.formats, `last_name >= %s`)
	f.values = append(f.values, v)
	return f
}

// LastNameIn last_name is in
func (f *Filter) LastNameIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`last_name IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// LastNameNotIn last_name is not in
func (f *Filter) LastNameNotIn(v string) *Filter {
	f.formats = append(f.formats, `last_name NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// Email email equals
func (f *Filter) Email(v string) *Filter {
	f.formats = append(f.formats, `email = %s`)
	f.values = append(f.values, v)
	return f
}

// EmailNot email doesn't equal
func (f *Filter) EmailNot(v string) *Filter {
	f.formats = append(f.formats, `email != %s`)
	f.values = append(f.values, v)
	return f
}

// EmailContains email contains
func (f *Filter) EmailContains(v string) *Filter {
	f.formats = append(f.formats, `email LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// EmailNotContains email doesn't contain
func (f *Filter) EmailNotContains(v string) *Filter {
	f.formats = append(f.formats, `email NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// EmailStartsWith email starts with
func (f *Filter) EmailStartsWith(v string) *Filter {
	f.formats = append(f.formats, `email LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// EmailNotStartsWith email doesn't start with
func (f *Filter) EmailNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `email NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// EmailEndsWith email ends with
func (f *Filter) EmailEndsWith(v string) *Filter {
	f.formats = append(f.formats, `email LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// EmailNotEndsWith email doesn't end with
func (f *Filter) EmailNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `email NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// EmailLt email is less than
func (f *Filter) EmailLt(v string) *Filter {
	f.formats = append(f.formats, `email < %s`)
	f.values = append(f.values, v)
	return f
}

// EmailLte email is less than or equal
func (f *Filter) EmailLte(v string) *Filter {
	f.formats = append(f.formats, `email <= %s`)
	f.values = append(f.values, v)
	return f
}

// EmailGt email is greater than
func (f *Filter) EmailGt(v string) *Filter {
	f.formats = append(f.formats, `email > %s`)
	f.values = append(f.values, v)
	return f
}

// EmailGte email is greater than or equal
func (f *Filter) EmailGte(v string) *Filter {
	f.formats = append(f.formats, `email >= %s`)
	f.values = append(f.values, v)
	return f
}

// EmailIn email is in
func (f *Filter) EmailIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`email IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// EmailNotIn email is not in
func (f *Filter) EmailNotIn(v string) *Filter {
	f.formats = append(f.formats, `email NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// Avatar avatar equals
func (f *Filter) Avatar(v string) *Filter {
	f.formats = append(f.formats, `avatar = %s`)
	f.values = append(f.values, v)
	return f
}

// AvatarNot avatar doesn't equal
func (f *Filter) AvatarNot(v string) *Filter {
	f.formats = append(f.formats, `avatar != %s`)
	f.values = append(f.values, v)
	return f
}

// AvatarContains avatar contains
func (f *Filter) AvatarContains(v string) *Filter {
	f.formats = append(f.formats, `avatar LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// AvatarNotContains avatar doesn't contain
func (f *Filter) AvatarNotContains(v string) *Filter {
	f.formats = append(f.formats, `avatar NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// AvatarStartsWith avatar starts with
func (f *Filter) AvatarStartsWith(v string) *Filter {
	f.formats = append(f.formats, `avatar LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// AvatarNotStartsWith avatar doesn't start with
func (f *Filter) AvatarNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `avatar NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// AvatarEndsWith avatar ends with
func (f *Filter) AvatarEndsWith(v string) *Filter {
	f.formats = append(f.formats, `avatar LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// AvatarNotEndsWith avatar doesn't end with
func (f *Filter) AvatarNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `avatar NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// AvatarLt avatar is less than
func (f *Filter) AvatarLt(v string) *Filter {
	f.formats = append(f.formats, `avatar < %s`)
	f.values = append(f.values, v)
	return f
}

// AvatarLte avatar is less than or equal
func (f *Filter) AvatarLte(v string) *Filter {
	f.formats = append(f.formats, `avatar <= %s`)
	f.values = append(f.values, v)
	return f
}

// AvatarGt avatar is greater than
func (f *Filter) AvatarGt(v string) *Filter {
	f.formats = append(f.formats, `avatar > %s`)
	f.values = append(f.values, v)
	return f
}

// AvatarGte avatar is greater than or equal
func (f *Filter) AvatarGte(v string) *Filter {
	f.formats = append(f.formats, `avatar >= %s`)
	f.values = append(f.values, v)
	return f
}

// AvatarIn avatar is in
func (f *Filter) AvatarIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`avatar IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// AvatarNotIn avatar is not in
func (f *Filter) AvatarNotIn(v string) *Filter {
	f.formats = append(f.formats, `avatar NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// Timezone timezone equals
func (f *Filter) Timezone(v string) *Filter {
	f.formats = append(f.formats, `timezone = %s`)
	f.values = append(f.values, v)
	return f
}

// TimezoneNot timezone doesn't equal
func (f *Filter) TimezoneNot(v string) *Filter {
	f.formats = append(f.formats, `timezone != %s`)
	f.values = append(f.values, v)
	return f
}

// TimezoneContains timezone contains
func (f *Filter) TimezoneContains(v string) *Filter {
	f.formats = append(f.formats, `timezone LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// TimezoneNotContains timezone doesn't contain
func (f *Filter) TimezoneNotContains(v string) *Filter {
	f.formats = append(f.formats, `timezone NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// TimezoneStartsWith timezone starts with
func (f *Filter) TimezoneStartsWith(v string) *Filter {
	f.formats = append(f.formats, `timezone LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// TimezoneNotStartsWith timezone doesn't start with
func (f *Filter) TimezoneNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `timezone NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// TimezoneEndsWith timezone ends with
func (f *Filter) TimezoneEndsWith(v string) *Filter {
	f.formats = append(f.formats, `timezone LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// TimezoneNotEndsWith timezone doesn't end with
func (f *Filter) TimezoneNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `timezone NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// TimezoneLt timezone is less than
func (f *Filter) TimezoneLt(v string) *Filter {
	f.formats = append(f.formats, `timezone < %s`)
	f.values = append(f.values, v)
	return f
}

// TimezoneLte timezone is less than or equal
func (f *Filter) TimezoneLte(v string) *Filter {
	f.formats = append(f.formats, `timezone <= %s`)
	f.values = append(f.values, v)
	return f
}

// TimezoneGt timezone is greater than
func (f *Filter) TimezoneGt(v string) *Filter {
	f.formats = append(f.formats, `timezone > %s`)
	f.values = append(f.values, v)
	return f
}

// TimezoneGte timezone is greater than or equal
func (f *Filter) TimezoneGte(v string) *Filter {
	f.formats = append(f.formats, `timezone >= %s`)
	f.values = append(f.values, v)
	return f
}

// TimezoneIn timezone is in
func (f *Filter) TimezoneIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`timezone IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// TimezoneNotIn timezone is not in
func (f *Filter) TimezoneNotIn(v string) *Filter {
	f.formats = append(f.formats, `timezone NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// OrderBy specificies the ORDERBy BY <order>
type OrderBy string

const (
	// Asc sorts by ascending order
	ASC OrderBy = "ASC"

	// Desc sorts by descending order
	DESC OrderBy = "DESC"
)

// NewOrder fn
func NewOrder() *Order {
	return &Order{}
}

// Order orders the given fields
type Order struct {
	formats []string
}

// Clause fn
func (o *Order) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "ORDER BY",
		Format: strings.Join(o.formats, ", "),
	}
}

// ID sorts `id` by an expression
func (o *Order) ID(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"id" %s`, order))
	return o
}

// TeamID sorts `team_id` by an expression
func (o *Order) TeamID(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"team_id" %s`, order))
	return o
}

// SlackID sorts `slack_id` by an expression
func (o *Order) SlackID(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"slack_id" %s`, order))
	return o
}

// Username sorts `username` by an expression
func (o *Order) Username(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"username" %s`, order))
	return o
}

// FirstName sorts `first_name` by an expression
func (o *Order) FirstName(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"first_name" %s`, order))
	return o
}

// LastName sorts `last_name` by an expression
func (o *Order) LastName(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"last_name" %s`, order))
	return o
}

// Email sorts `email` by an expression
func (o *Order) Email(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"email" %s`, order))
	return o
}

// Avatar sorts `avatar` by an expression
func (o *Order) Avatar(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"avatar" %s`, order))
	return o
}

// Timezone sorts `timezone` by an expression
func (o *Order) Timezone(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"timezone" %s`, order))
	return o
}

// Insert a "teammates" into the "jack"."teammates"
func Insert(db pogo.DB, teammate *Input) (*Teammate, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(teammate.columns(), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
    INSERT INTO "jack"."teammates" (` + strings.Join(_c, ", ") + `)
    VALUES (` + strings.Join(_i, ", ") + `)
    RETURNING "id", "team_id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone"
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _teammate Teammate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_teammate.ID, &_teammate.TeamID, &_teammate.SlackID, &_teammate.Username, &_teammate.FirstName, &_teammate.LastName, &_teammate.Email, &_teammate.Avatar, &_teammate.Timezone); e != nil {
		return nil, e
	}

	return &_teammate, nil
}

// Find a `Teammate` by some conditions.
func Find(db pogo.DB, conds ...pogo.Condition) (*Teammate, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "id", "team_id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone" ` +
		`FROM "jack"."teammates" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _teammate Teammate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_teammate.ID, &_teammate.TeamID, &_teammate.SlackID, &_teammate.Username, &_teammate.FirstName, &_teammate.LastName, &_teammate.Email, &_teammate.Avatar, &_teammate.Timezone); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, e
	}

	return &_teammate, nil
}

// FindByID a `Teammate` by some conditions.
func FindByID(db pogo.DB, id int) (*Teammate, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "team_id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone"
    FROM "jack"."teammates"
    WHERE "id" = $1
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, &id)
	}

	var _teammate Teammate
	row := db.QueryRow(sqlstr, &id)
	if e := row.Scan(&_teammate.ID, &_teammate.TeamID, &_teammate.SlackID, &_teammate.Username, &_teammate.FirstName, &_teammate.LastName, &_teammate.Email, &_teammate.Avatar, &_teammate.Timezone); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, e
	}

	return &_teammate, nil
}

// FindBySlackID find a teammate by slack_id
func FindBySlackID(db pogo.DB, slackID string) (*Teammate, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "team_id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone"
    FROM "jack"."teammates"
    WHERE "slack_id" = $1
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, slackID)
	}

	var _teammate Teammate
	row := db.QueryRow(sqlstr, slackID)
	err := row.Scan(&_teammate.ID, &_teammate.TeamID, &_teammate.SlackID, &_teammate.Username, &_teammate.FirstName, &_teammate.LastName, &_teammate.Email, &_teammate.Avatar, &_teammate.Timezone)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, err
	}

	return &_teammate, nil
}

// FindMany finds many "jack"."teammates" by a condition
func FindMany(db pogo.DB, conds ...pogo.Condition) ([]*Teammate, error) {
	var teammates []*Teammate

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return teammates, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "id", "team_id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone" ` +
		`FROM "jack"."teammates" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return teammates, err
	}
	defer rows.Close()

	for rows.Next() {
		var _teammate Teammate
		if e := rows.Scan(&_teammate.ID, &_teammate.TeamID, &_teammate.SlackID, &_teammate.Username, &_teammate.FirstName, &_teammate.LastName, &_teammate.Email, &_teammate.Avatar, &_teammate.Timezone); e != nil {
			if e == pgx.ErrNoRows {
				return teammates, ErrTeammateNotFound
			}
			return teammates, err
		}
		teammates = append(teammates, &_teammate)
	}
	if rows.Err() != nil {
		return teammates, rows.Err()
	}

	return teammates, nil
}

// UpdateByID a "teammate" in "jack"."teammates" by its "id"
func UpdateByID(db pogo.DB, id int, teammate *Input) (*Teammate, error) {
	fields := teammate.columns()

	// don't update the primary key
	delete(fields, "id")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// sql query
	sqlstr := `UPDATE "jack"."teammates" SET ` +
		strings.Join(_u, ", ") + ` ` +
		`WHERE "id" = $1 ` +
		`RETURNING "id", "team_id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone"`

	// setup query
	values := append([]interface{}{&id}, _v...)

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, values...)
	}

	// run the query
	var _teammate Teammate
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&_teammate.ID, &_teammate.TeamID, &_teammate.SlackID, &_teammate.Username, &_teammate.FirstName, &_teammate.LastName, &_teammate.Email, &_teammate.Avatar, &_teammate.Timezone); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, e
	}

	return &_teammate, nil
}

// UpdateBySlackID find a Teammate
func UpdateBySlackID(db pogo.DB, slackID string, teammate *Input) (*Teammate, error) {
	// add values to input, overriding existing keys if present in the input
	teammate = teammate.SlackID(slackID)

	// get the columns
	fields := teammate.columns()

	// don't update the keys
	delete(fields, "slack_id")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// sql query
	sqlstr := `UPDATE "jack"."teammates" SET ` +
		strings.Join(_u, ", ") + ` ` +
		`WHERE "slack_id" = $1 ` +
		`RETURNING "id", "team_id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone"`

	// setup the query
	values := []interface{}{}
	values = append(values, slackID)
	values = append(values, _v...)

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, values...)
	}

	// run the query
	var _teammate Teammate
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&_teammate.ID, &_teammate.TeamID, &_teammate.SlackID, &_teammate.Username, &_teammate.FirstName, &_teammate.LastName, &_teammate.Email, &_teammate.Avatar, &_teammate.Timezone); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, e
	}

	return &_teammate, nil
}

// Delete `Teammate`s by some conditions. Returns the first result.
func Delete(db pogo.DB, conds ...pogo.Condition) (*Teammate, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql delete query
	sqlstr := `DELETE FROM "jack"."teammates" ` +
		_s + ` ` +
		`RETURNING "id", "team_id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _teammate Teammate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_teammate.ID, &_teammate.TeamID, &_teammate.SlackID, &_teammate.Username, &_teammate.FirstName, &_teammate.LastName, &_teammate.Email, &_teammate.Avatar, &_teammate.Timezone); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, e
	}

	return &_teammate, nil
}

// DeleteMany `Teammate`s by some conditions, returning all results.
func DeleteMany(db pogo.DB, conds ...pogo.Condition) ([]*Teammate, error) {
	var teammates []*Teammate

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return teammates, err
	}

	// sql delete query
	sqlstr := `DELETE FROM "jack"."teammates" ` +
		_s + ` ` +
		`RETURNING "id", "team_id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return teammates, err
	}
	defer rows.Close()

	for rows.Next() {
		var _teammate Teammate
		if e := rows.Scan(&_teammate.ID, &_teammate.TeamID, &_teammate.SlackID, &_teammate.Username, &_teammate.FirstName, &_teammate.LastName, &_teammate.Email, &_teammate.Avatar, &_teammate.Timezone); e != nil {
			if e == pgx.ErrNoRows {
				return teammates, ErrTeammateNotFound
			}
			return teammates, err
		}
		teammates = append(teammates, &_teammate)
	}
	if rows.Err() != nil {
		return teammates, rows.Err()
	}

	return teammates, nil
}

// DeleteByID a "teammate" from the "jack"."teammates" table
func DeleteByID(db pogo.DB, id int) (*Teammate, error) {
	// sql delete query
	sqlstr := `DELETE FROM "jack"."teammates" ` +
		`WHERE "id" = $1 ` +
		`RETURNING "id", "team_id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, id)
	}

	// run the query
	var _teammate Teammate
	row := db.QueryRow(sqlstr, id)
	if e := row.Scan(&_teammate.ID, &_teammate.TeamID, &_teammate.SlackID, &_teammate.Username, &_teammate.FirstName, &_teammate.LastName, &_teammate.Email, &_teammate.Avatar, &_teammate.Timezone); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, e
	}

	return &_teammate, nil
}

// DeleteBySlackID deletes a "teammate"
func DeleteBySlackID(db pogo.DB, slackID string) (*Teammate, error) {
	// sql delete query
	sqlstr := `DELETE FROM "jack"."teammates" ` +
		`WHERE "slack_id" = $1 ` +
		`RETURNING "id", "team_id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, slackID)
	}

	// run the query
	var _teammate Teammate
	row := db.QueryRow(sqlstr, slackID)
	if e := row.Scan(&_teammate.ID, &_teammate.TeamID, &_teammate.SlackID, &_teammate.Username, &_teammate.FirstName, &_teammate.LastName, &_teammate.Email, &_teammate.Avatar, &_teammate.Timezone); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, e
	}

	return &_teammate, nil
}

// UpsertBySlackID find a "Teammate"
func UpsertBySlackID(db pogo.DB, slackID string, teammate *Input) (*Teammate, error) {
	// add values to input, overriding existing keys if present in the input
	teammate = teammate.SlackID(slackID)

	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(teammate.columns(), 0)

	// sql query
	sqlstr := `INSERT INTO "jack"."teammates" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("slack_id") ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "id", "team_id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run query
	var _teammate Teammate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_teammate.ID, &_teammate.TeamID, &_teammate.SlackID, &_teammate.Username, &_teammate.FirstName, &_teammate.LastName, &_teammate.Email, &_teammate.Avatar, &_teammate.Timezone); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &_teammate, nil
}

// slice converts our columns into something the sql driver can understand
func slice(columns map[string]interface{}, offset int) (c []string, i []string, v []interface{}) {
	n := offset + 1
	for col, val := range columns {
		c = append(c, `"`+col+`"`)
		i = append(i, "$"+strconv.Itoa(n))
		v = append(v, val)
		n++
	}
	return c, i, v
}

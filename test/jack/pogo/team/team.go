package team

import (
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/pogo/test/jack/pogo"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrTeamNotFound returned if the teams is not found
var ErrTeamNotFound = errors.New("team not found")

// Team result data for "jack"."teams"
type Team struct {
	ID            int      `json:"id,omitempty"`
	Token         int      `json:"token,omitempty"`
	TeamName      string   `json:"team_name,omitempty"`
	Scope         []string `json:"scope,omitempty"`
	Email         *string  `json:"email,omitempty"`
	StripeID      *string  `json:"stripe_id,omitempty"`
	Active        bool     `json:"active,omitempty"`
	FreeTeammates int      `json:"free_teammates,omitempty"`
	CostPerUser   int      `json:"cost_per_user,omitempty"`
}

// New "jack"."teams" input
func New() *Input {
	return &Input{}
}

// Input data for "jack"."teams"
type Input struct {
	id            *int
	token         *int
	teamName      *string
	scope         *[]string
	email         *string
	stripeID      *string
	active        *bool
	freeTeammates *int
	costPerUser   *int
}

// ID sets the "id"
func (t *Input) ID(id int) *Input {
	t.id = &id
	return t
}

// Token sets the "token"
func (t *Input) Token(token int) *Input {
	t.token = &token
	return t
}

// TeamName sets the "team_name"
func (t *Input) TeamName(teamName string) *Input {
	t.teamName = &teamName
	return t
}

// Scope sets the "scope"
func (t *Input) Scope(scope []string) *Input {
	t.scope = &scope
	return t
}

// Email sets the "email"
func (t *Input) Email(email string) *Input {
	t.email = &email
	return t
}

// StripeID sets the "stripe_id"
func (t *Input) StripeID(stripeID string) *Input {
	t.stripeID = &stripeID
	return t
}

// Active sets the "active"
func (t *Input) Active(active bool) *Input {
	t.active = &active
	return t
}

// FreeTeammates sets the "free_teammates"
func (t *Input) FreeTeammates(freeTeammates int) *Input {
	t.freeTeammates = &freeTeammates
	return t
}

// CostPerUser sets the "cost_per_user"
func (t *Input) CostPerUser(costPerUser int) *Input {
	t.costPerUser = &costPerUser
	return t
}

// MarshalJSON marshals the "team" into JSON
func (t *Input) MarshalJSON() ([]byte, error) {
	return json.Marshal(t)
}

// UnmarshalJSON unmarshals json to a "team"
func (t *Input) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, t)
}

func (t *Input) String() string {
	return "teams"
}

func (t *Input) columns() map[string]interface{} {
	columns := make(map[string]interface{})

	if t.id != nil {
		columns["id"] = *t.id
	}

	if t.token != nil {
		columns["token"] = *t.token
	}

	if t.teamName != nil {
		columns["team_name"] = *t.teamName
	}

	if t.scope != nil {
		columns["scope"] = *t.scope
	}

	if t.email != nil {
		columns["email"] = *t.email
	}

	if t.stripeID != nil {
		columns["stripe_id"] = *t.stripeID
	}

	if t.active != nil {
		columns["active"] = *t.active
	}

	if t.freeTeammates != nil {
		columns["free_teammates"] = *t.freeTeammates
	}

	if t.costPerUser != nil {
		columns["cost_per_user"] = *t.costPerUser
	}

	return columns
}

// NewFilter creates a new filter
func NewFilter() *Filter {
	return &Filter{}
}

// Filter filters for "jack"."teams"
type Filter struct {
	formats []string
	values  []interface{}
}

var _ pogo.Condition = (*Filter)(nil)

// Clause fn
func (f *Filter) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "WHERE",
		Format: strings.Join(f.formats, " AND "),
		Params: f.values,
	}
}

// And filter
// func (f *Filter) And(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " AND "))
//   return f
// }

// Or filter
// func (f *Filter) Or(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " OR "))
//   return f
// }

// ID id equals
func (f *Filter) ID(v int) *Filter {
	f.formats = append(f.formats, `id = %s`)
	f.values = append(f.values, v)
	return f
}

// IDNot id doesn't equal
func (f *Filter) IDNot(v int) *Filter {
	f.formats = append(f.formats, `id != %s`)
	f.values = append(f.values, v)
	return f
}

// IDLt id is less than
func (f *Filter) IDLt(v int) *Filter {
	f.formats = append(f.formats, `id < %s`)
	f.values = append(f.values, v)
	return f
}

// IDLte id is less than or equal
func (f *Filter) IDLte(v int) *Filter {
	f.formats = append(f.formats, `id <= %s`)
	f.values = append(f.values, v)
	return f
}

// IDGt id is greater than
func (f *Filter) IDGt(v int) *Filter {
	f.formats = append(f.formats, `id > %s`)
	f.values = append(f.values, v)
	return f
}

// IDGte id is greater than or equal
func (f *Filter) IDGte(v int) *Filter {
	f.formats = append(f.formats, `id >= %s`)
	f.values = append(f.values, v)
	return f
}

// IDIn id is in
func (f *Filter) IDIn(v []int) *Filter {
	f.formats = append(f.formats, `id IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// IDNotIn id is not in
func (f *Filter) IDNotIn(v []int) *Filter {
	f.formats = append(f.formats, `id NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// Token token equals
func (f *Filter) Token(v int) *Filter {
	f.formats = append(f.formats, `token = %s`)
	f.values = append(f.values, v)
	return f
}

// TokenNot token doesn't equal
func (f *Filter) TokenNot(v int) *Filter {
	f.formats = append(f.formats, `token != %s`)
	f.values = append(f.values, v)
	return f
}

// TokenLt token is less than
func (f *Filter) TokenLt(v int) *Filter {
	f.formats = append(f.formats, `token < %s`)
	f.values = append(f.values, v)
	return f
}

// TokenLte token is less than or equal
func (f *Filter) TokenLte(v int) *Filter {
	f.formats = append(f.formats, `token <= %s`)
	f.values = append(f.values, v)
	return f
}

// TokenGt token is greater than
func (f *Filter) TokenGt(v int) *Filter {
	f.formats = append(f.formats, `token > %s`)
	f.values = append(f.values, v)
	return f
}

// TokenGte token is greater than or equal
func (f *Filter) TokenGte(v int) *Filter {
	f.formats = append(f.formats, `token >= %s`)
	f.values = append(f.values, v)
	return f
}

// TokenIn token is in
func (f *Filter) TokenIn(v []int) *Filter {
	f.formats = append(f.formats, `token IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// TokenNotIn token is not in
func (f *Filter) TokenNotIn(v []int) *Filter {
	f.formats = append(f.formats, `token NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// TeamName team_name equals
func (f *Filter) TeamName(v string) *Filter {
	f.formats = append(f.formats, `team_name = %s`)
	f.values = append(f.values, v)
	return f
}

// TeamNameNot team_name doesn't equal
func (f *Filter) TeamNameNot(v string) *Filter {
	f.formats = append(f.formats, `team_name != %s`)
	f.values = append(f.values, v)
	return f
}

// TeamNameContains team_name contains
func (f *Filter) TeamNameContains(v string) *Filter {
	f.formats = append(f.formats, `team_name LIKE %%s%`)
	f.values = append(f.values, v)
	return f
}

// TeamNameNotContains team_name doesn't contain
func (f *Filter) TeamNameNotContains(v string) *Filter {
	f.formats = append(f.formats, `team_name NOT LIKE %%s%`)
	f.values = append(f.values, v)
	return f
}

// TeamNameStartsWith team_name starts with
func (f *Filter) TeamNameStartsWith(v string) *Filter {
	f.formats = append(f.formats, `team_name LIKE %s%`)
	f.values = append(f.values, v)
	return f
}

// TeamNameNotStartsWith team_name doesn't start with
func (f *Filter) TeamNameNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `team_name NOT LIKE %s%`)
	f.values = append(f.values, v)
	return f
}

// TeamNameEndsWith team_name ends with
func (f *Filter) TeamNameEndsWith(v string) *Filter {
	f.formats = append(f.formats, `team_name LIKE %%s`)
	f.values = append(f.values, v)
	return f
}

// TeamNameNotEndsWith team_name doesn't end with
func (f *Filter) TeamNameNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `team_name NOT LIKE %%s`)
	f.values = append(f.values, v)
	return f
}

// TeamNameLt team_name is less than
func (f *Filter) TeamNameLt(v string) *Filter {
	f.formats = append(f.formats, `team_name < %s`)
	f.values = append(f.values, v)
	return f
}

// TeamNameLte team_name is less than or equal
func (f *Filter) TeamNameLte(v string) *Filter {
	f.formats = append(f.formats, `team_name <= %s`)
	f.values = append(f.values, v)
	return f
}

// TeamNameGt team_name is greater than
func (f *Filter) TeamNameGt(v string) *Filter {
	f.formats = append(f.formats, `team_name > %s`)
	f.values = append(f.values, v)
	return f
}

// TeamNameGte team_name is greater than or equal
func (f *Filter) TeamNameGte(v string) *Filter {
	f.formats = append(f.formats, `team_name >= %s`)
	f.values = append(f.values, v)
	return f
}

// TeamNameIn team_name is in
func (f *Filter) TeamNameIn(v []string) *Filter {
	f.formats = append(f.formats, `team_name IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// TeamNameNotIn team_name is not in
func (f *Filter) TeamNameNotIn(v []string) *Filter {
	f.formats = append(f.formats, `team_name NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// ScopeContains
func (f *Filter) ScopeContains(v []string) *Filter {
	f.formats = append(f.formats, ``)
	f.values = append(f.values, v)
	return f
}

// ScopeContainsEvery
func (f *Filter) ScopeContainsEvery(v [][]string) *Filter {
	f.formats = append(f.formats, ``)
	f.values = append(f.values, v)
	return f
}

// ScopeContainsSome
func (f *Filter) ScopeContainsSome(v [][]string) *Filter {
	f.formats = append(f.formats, ``)
	f.values = append(f.values, v)
	return f
}

// Email email equals
func (f *Filter) Email(v string) *Filter {
	f.formats = append(f.formats, `email = %s`)
	f.values = append(f.values, v)
	return f
}

// EmailNot email doesn't equal
func (f *Filter) EmailNot(v string) *Filter {
	f.formats = append(f.formats, `email != %s`)
	f.values = append(f.values, v)
	return f
}

// EmailContains email contains
func (f *Filter) EmailContains(v string) *Filter {
	f.formats = append(f.formats, `email LIKE %%s%`)
	f.values = append(f.values, v)
	return f
}

// EmailNotContains email doesn't contain
func (f *Filter) EmailNotContains(v string) *Filter {
	f.formats = append(f.formats, `email NOT LIKE %%s%`)
	f.values = append(f.values, v)
	return f
}

// EmailStartsWith email starts with
func (f *Filter) EmailStartsWith(v string) *Filter {
	f.formats = append(f.formats, `email LIKE %s%`)
	f.values = append(f.values, v)
	return f
}

// EmailNotStartsWith email doesn't start with
func (f *Filter) EmailNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `email NOT LIKE %s%`)
	f.values = append(f.values, v)
	return f
}

// EmailEndsWith email ends with
func (f *Filter) EmailEndsWith(v string) *Filter {
	f.formats = append(f.formats, `email LIKE %%s`)
	f.values = append(f.values, v)
	return f
}

// EmailNotEndsWith email doesn't end with
func (f *Filter) EmailNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `email NOT LIKE %%s`)
	f.values = append(f.values, v)
	return f
}

// EmailLt email is less than
func (f *Filter) EmailLt(v string) *Filter {
	f.formats = append(f.formats, `email < %s`)
	f.values = append(f.values, v)
	return f
}

// EmailLte email is less than or equal
func (f *Filter) EmailLte(v string) *Filter {
	f.formats = append(f.formats, `email <= %s`)
	f.values = append(f.values, v)
	return f
}

// EmailGt email is greater than
func (f *Filter) EmailGt(v string) *Filter {
	f.formats = append(f.formats, `email > %s`)
	f.values = append(f.values, v)
	return f
}

// EmailGte email is greater than or equal
func (f *Filter) EmailGte(v string) *Filter {
	f.formats = append(f.formats, `email >= %s`)
	f.values = append(f.values, v)
	return f
}

// EmailIn email is in
func (f *Filter) EmailIn(v []string) *Filter {
	f.formats = append(f.formats, `email IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// EmailNotIn email is not in
func (f *Filter) EmailNotIn(v []string) *Filter {
	f.formats = append(f.formats, `email NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// StripeID stripe_id equals
func (f *Filter) StripeID(v string) *Filter {
	f.formats = append(f.formats, `stripe_id = %s`)
	f.values = append(f.values, v)
	return f
}

// StripeIDNot stripe_id doesn't equal
func (f *Filter) StripeIDNot(v string) *Filter {
	f.formats = append(f.formats, `stripe_id != %s`)
	f.values = append(f.values, v)
	return f
}

// StripeIDContains stripe_id contains
func (f *Filter) StripeIDContains(v string) *Filter {
	f.formats = append(f.formats, `stripe_id LIKE %%s%`)
	f.values = append(f.values, v)
	return f
}

// StripeIDNotContains stripe_id doesn't contain
func (f *Filter) StripeIDNotContains(v string) *Filter {
	f.formats = append(f.formats, `stripe_id NOT LIKE %%s%`)
	f.values = append(f.values, v)
	return f
}

// StripeIDStartsWith stripe_id starts with
func (f *Filter) StripeIDStartsWith(v string) *Filter {
	f.formats = append(f.formats, `stripe_id LIKE %s%`)
	f.values = append(f.values, v)
	return f
}

// StripeIDNotStartsWith stripe_id doesn't start with
func (f *Filter) StripeIDNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `stripe_id NOT LIKE %s%`)
	f.values = append(f.values, v)
	return f
}

// StripeIDEndsWith stripe_id ends with
func (f *Filter) StripeIDEndsWith(v string) *Filter {
	f.formats = append(f.formats, `stripe_id LIKE %%s`)
	f.values = append(f.values, v)
	return f
}

// StripeIDNotEndsWith stripe_id doesn't end with
func (f *Filter) StripeIDNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `stripe_id NOT LIKE %%s`)
	f.values = append(f.values, v)
	return f
}

// StripeIDLt stripe_id is less than
func (f *Filter) StripeIDLt(v string) *Filter {
	f.formats = append(f.formats, `stripe_id < %s`)
	f.values = append(f.values, v)
	return f
}

// StripeIDLte stripe_id is less than or equal
func (f *Filter) StripeIDLte(v string) *Filter {
	f.formats = append(f.formats, `stripe_id <= %s`)
	f.values = append(f.values, v)
	return f
}

// StripeIDGt stripe_id is greater than
func (f *Filter) StripeIDGt(v string) *Filter {
	f.formats = append(f.formats, `stripe_id > %s`)
	f.values = append(f.values, v)
	return f
}

// StripeIDGte stripe_id is greater than or equal
func (f *Filter) StripeIDGte(v string) *Filter {
	f.formats = append(f.formats, `stripe_id >= %s`)
	f.values = append(f.values, v)
	return f
}

// StripeIDIn stripe_id is in
func (f *Filter) StripeIDIn(v []string) *Filter {
	f.formats = append(f.formats, `stripe_id IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// StripeIDNotIn stripe_id is not in
func (f *Filter) StripeIDNotIn(v []string) *Filter {
	f.formats = append(f.formats, `stripe_id NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// Active
func (f *Filter) Active(v bool) *Filter {
	f.formats = append(f.formats, ``)
	f.values = append(f.values, v)
	return f
}

// ActiveNot
func (f *Filter) ActiveNot(v bool) *Filter {
	f.formats = append(f.formats, ``)
	f.values = append(f.values, v)
	return f
}

// FreeTeammates free_teammates equals
func (f *Filter) FreeTeammates(v int) *Filter {
	f.formats = append(f.formats, `free_teammates = %s`)
	f.values = append(f.values, v)
	return f
}

// FreeTeammatesNot free_teammates doesn't equal
func (f *Filter) FreeTeammatesNot(v int) *Filter {
	f.formats = append(f.formats, `free_teammates != %s`)
	f.values = append(f.values, v)
	return f
}

// FreeTeammatesLt free_teammates is less than
func (f *Filter) FreeTeammatesLt(v int) *Filter {
	f.formats = append(f.formats, `free_teammates < %s`)
	f.values = append(f.values, v)
	return f
}

// FreeTeammatesLte free_teammates is less than or equal
func (f *Filter) FreeTeammatesLte(v int) *Filter {
	f.formats = append(f.formats, `free_teammates <= %s`)
	f.values = append(f.values, v)
	return f
}

// FreeTeammatesGt free_teammates is greater than
func (f *Filter) FreeTeammatesGt(v int) *Filter {
	f.formats = append(f.formats, `free_teammates > %s`)
	f.values = append(f.values, v)
	return f
}

// FreeTeammatesGte free_teammates is greater than or equal
func (f *Filter) FreeTeammatesGte(v int) *Filter {
	f.formats = append(f.formats, `free_teammates >= %s`)
	f.values = append(f.values, v)
	return f
}

// FreeTeammatesIn free_teammates is in
func (f *Filter) FreeTeammatesIn(v []int) *Filter {
	f.formats = append(f.formats, `free_teammates IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// FreeTeammatesNotIn free_teammates is not in
func (f *Filter) FreeTeammatesNotIn(v []int) *Filter {
	f.formats = append(f.formats, `free_teammates NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// CostPerUser cost_per_user equals
func (f *Filter) CostPerUser(v int) *Filter {
	f.formats = append(f.formats, `cost_per_user = %s`)
	f.values = append(f.values, v)
	return f
}

// CostPerUserNot cost_per_user doesn't equal
func (f *Filter) CostPerUserNot(v int) *Filter {
	f.formats = append(f.formats, `cost_per_user != %s`)
	f.values = append(f.values, v)
	return f
}

// CostPerUserLt cost_per_user is less than
func (f *Filter) CostPerUserLt(v int) *Filter {
	f.formats = append(f.formats, `cost_per_user < %s`)
	f.values = append(f.values, v)
	return f
}

// CostPerUserLte cost_per_user is less than or equal
func (f *Filter) CostPerUserLte(v int) *Filter {
	f.formats = append(f.formats, `cost_per_user <= %s`)
	f.values = append(f.values, v)
	return f
}

// CostPerUserGt cost_per_user is greater than
func (f *Filter) CostPerUserGt(v int) *Filter {
	f.formats = append(f.formats, `cost_per_user > %s`)
	f.values = append(f.values, v)
	return f
}

// CostPerUserGte cost_per_user is greater than or equal
func (f *Filter) CostPerUserGte(v int) *Filter {
	f.formats = append(f.formats, `cost_per_user >= %s`)
	f.values = append(f.values, v)
	return f
}

// CostPerUserIn cost_per_user is in
func (f *Filter) CostPerUserIn(v []int) *Filter {
	f.formats = append(f.formats, `cost_per_user IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// CostPerUserNotIn cost_per_user is not in
func (f *Filter) CostPerUserNotIn(v []int) *Filter {
	f.formats = append(f.formats, `cost_per_user NOT IN (%s)`)
	f.values = append(f.values, v)
	return f
}

// NewOrderBy fn
func NewOrderBy() *OrderBy {
	return &OrderBy{}
}

// OrderBy orders the given fields
type OrderBy struct {
	formats []string
}

// Order specificies the ORDER BY <order>
type Order string

const (
	// Asc sorts by ascending order
	Asc Order = "ASC"

	// Desc sorts by descending order
	Desc Order = "DESC"
)

// Clause fn
func (o *OrderBy) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "ORDER BY",
		Format: strings.Join(o.formats, ", "),
	}
}

// ID orders `id` by a sort expression
func (o *OrderBy) ID(order Order) *OrderBy {
	o.formats = append(o.formats, fmt.Sprintf(`"id" %s`, order))
	return o
}

// Token orders `token` by a sort expression
func (o *OrderBy) Token(order Order) *OrderBy {
	o.formats = append(o.formats, fmt.Sprintf(`"token" %s`, order))
	return o
}

// TeamName orders `team_name` by a sort expression
func (o *OrderBy) TeamName(order Order) *OrderBy {
	o.formats = append(o.formats, fmt.Sprintf(`"team_name" %s`, order))
	return o
}

// Scope orders `scope` by a sort expression
func (o *OrderBy) Scope(order Order) *OrderBy {
	o.formats = append(o.formats, fmt.Sprintf(`"scope" %s`, order))
	return o
}

// Email orders `email` by a sort expression
func (o *OrderBy) Email(order Order) *OrderBy {
	o.formats = append(o.formats, fmt.Sprintf(`"email" %s`, order))
	return o
}

// StripeID orders `stripe_id` by a sort expression
func (o *OrderBy) StripeID(order Order) *OrderBy {
	o.formats = append(o.formats, fmt.Sprintf(`"stripe_id" %s`, order))
	return o
}

// Active orders `active` by a sort expression
func (o *OrderBy) Active(order Order) *OrderBy {
	o.formats = append(o.formats, fmt.Sprintf(`"active" %s`, order))
	return o
}

// FreeTeammates orders `free_teammates` by a sort expression
func (o *OrderBy) FreeTeammates(order Order) *OrderBy {
	o.formats = append(o.formats, fmt.Sprintf(`"free_teammates" %s`, order))
	return o
}

// CostPerUser orders `cost_per_user` by a sort expression
func (o *OrderBy) CostPerUser(order Order) *OrderBy {
	o.formats = append(o.formats, fmt.Sprintf(`"cost_per_user" %s`, order))
	return o
}

// Insert a "teams" into the "jack"."teams"
func Insert(db pogo.DB, team *Input) (*Team, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(team.columns(), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
    INSERT INTO "jack"."teams" (` + strings.Join(_c, ", ") + `)
    VALUES (` + strings.Join(_i, ", ") + `)
    RETURNING "id", "token", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user"
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _team Team
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_team.ID, &_team.Token, &_team.TeamName, &_team.Scope, &_team.Email, &_team.StripeID, &_team.Active, &_team.FreeTeammates, &_team.CostPerUser); e != nil {
		return nil, e
	}

	return &_team, nil
}

// Find a `Team` by some conditions.
func Find(db pogo.DB, conds ...pogo.Condition) (*Team, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "id", "token", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user" ` +
		`FROM "jack"."teams" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _team Team
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_team.ID, &_team.Token, &_team.TeamName, &_team.Scope, &_team.Email, &_team.StripeID, &_team.Active, &_team.FreeTeammates, &_team.CostPerUser); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeamNotFound
		}
		return nil, e
	}

	return &_team, nil
}

// FindByID a `Team` by some conditions.
func FindByID(db pogo.DB, id int) (*Team, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "token", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user"
    FROM "jack"."teams"
    WHERE "id" = $1
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, &id)
	}

	var _team Team
	row := db.QueryRow(sqlstr, &id)
	if e := row.Scan(&_team.ID, &_team.Token, &_team.TeamName, &_team.Scope, &_team.Email, &_team.StripeID, &_team.Active, &_team.FreeTeammates, &_team.CostPerUser); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeamNotFound
		}
		return nil, e
	}

	return &_team, nil
}

// FindByToken find a team by token
func FindByToken(db pogo.DB, token int) (*Team, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "token", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user"
    FROM "jack"."teams"
    WHERE "token" = $1
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, token)
	}

	var _team Team
	row := db.QueryRow(sqlstr, token)
	err := row.Scan(&_team.ID, &_team.Token, &_team.TeamName, &_team.Scope, &_team.Email, &_team.StripeID, &_team.Active, &_team.FreeTeammates, &_team.CostPerUser)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, ErrTeamNotFound
		}
		return nil, err
	}

	return &_team, nil
}

// UpdateByID a "team" in "jack"."teams" by its "id"
func UpdateByID(db pogo.DB, id int, team *Input) (*Team, error) {
	fields := team.columns()

	// don't update the primary key
	delete(fields, "id")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// sql query
	sqlstr := `UPDATE "jack"."teams" SET` +
		` ` + strings.Join(_u, ", ") + ` ` +
		`WHERE "id" = $1 ` +
		`RETURNING "id", "token", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user"`

	// setup query
	values := append([]interface{}{&id}, _v...)

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, values...)
	}

	// run the query
	var _team Team
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&_team.ID, &_team.Token, &_team.TeamName, &_team.Scope, &_team.Email, &_team.StripeID, &_team.Active, &_team.FreeTeammates, &_team.CostPerUser); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeamNotFound
		}
		return nil, e
	}

	return &_team, nil
}

// slice converts our columns into something the sql driver can understand
func slice(columns map[string]interface{}, offset int) (c []string, i []string, v []interface{}) {
	n := offset + 1
	for col, val := range columns {
		c = append(c, `"`+col+`"`)
		i = append(i, "$"+strconv.Itoa(n))
		v = append(v, val)
		n++
	}
	return c, i, v
}

package standupsteammates

import (
	"encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/pogo/jack"
	uuid "github.com/satori/go.uuid"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrStandupTeammateNotFound returned if the standupteammate is not found
var ErrStandupTeammateNotFound = errors.New("standupteammate not found")

// columns in `jack.standups_teammates`
type columns struct {
	StandupID  *string    `json:"standup_id,omitempty"`
	TeammateID *string    `json:"teammate_id,omitempty"`
	TeamOwner  *bool      `json:"team_owner,omitempty"`
	CreatedAt  *time.Time `json:"created_at,omitempty"`
	UpdatedAt  *time.Time `json:"updated_at,omitempty"`
}

// StandupTeammate fluent API
type StandupTeammate struct {
	columns *columns
}

// New `jack.standups_teammates` API
func New() *StandupTeammate {
	return &StandupTeammate{&columns{}}
}

// StandupID sets the `standup_id`
func (standupteammate *StandupTeammate) StandupID(standupID uuid.UUID) *StandupTeammate {
	standupteammate.columns.StandupID = &standupID
	return standupteammate
}

// GetStandupID returns the `standup_id` if set
func (standupteammate *StandupTeammate) GetStandupID() (standupID *uuid.UUID) {
	return standupteammate.columns.StandupID
}

// TeammateID sets the `teammate_id`
func (standupteammate *StandupTeammate) TeammateID(teammateID uuid.UUID) *StandupTeammate {
	standupteammate.columns.TeammateID = &teammateID
	return standupteammate
}

// GetTeammateID returns the `teammate_id` if set
func (standupteammate *StandupTeammate) GetTeammateID() (teammateID *uuid.UUID) {
	return standupteammate.columns.TeammateID
}

// TeamOwner sets the `team_owner`
func (standupteammate *StandupTeammate) TeamOwner(teamOwner bool) *StandupTeammate {
	standupteammate.columns.TeamOwner = &teamOwner
	return standupteammate
}

// GetTeamOwner returns the `team_owner` if set
func (standupteammate *StandupTeammate) GetTeamOwner() (teamOwner *bool) {
	return standupteammate.columns.TeamOwner
}

// CreatedAt sets the `created_at`
func (standupteammate *StandupTeammate) CreatedAt(createdAt time.Time) *StandupTeammate {
	standupteammate.columns.CreatedAt = &createdAt
	return standupteammate
}

// GetCreatedAt returns the `created_at` if set
func (standupteammate *StandupTeammate) GetCreatedAt() (createdAt *time.Time) {
	return standupteammate.columns.CreatedAt
}

// UpdatedAt sets the `updated_at`
func (standupteammate *StandupTeammate) UpdatedAt(updatedAt time.Time) *StandupTeammate {
	standupteammate.columns.UpdatedAt = &updatedAt
	return standupteammate
}

// GetUpdatedAt returns the `updated_at` if set
func (standupteammate *StandupTeammate) GetUpdatedAt() (updatedAt *time.Time) {
	return standupteammate.columns.UpdatedAt
}

// MarshalJSON marshals the `standupteammate` into JSON
func (standupteammate *StandupTeammate) MarshalJSON() ([]byte, error) {
	return json.Marshal(standupteammate.columns)
}

// UnmarshalJSON unmarshals json to a `standupteammate`
func (standupteammate *StandupTeammate) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, standupteammate.columns)
}

func (standupteammate *StandupTeammate) String() string {
	return "standupteammate TODO"
}

// get all the non-nil columns
func getColumns(standupteammate *StandupTeammate) map[string]interface{} {
	columns := make(map[string]interface{})

	if standupteammate.columns.StandupID != nil {
		columns["standup_id"] = standupteammate.StandupID
	}
	if standupteammate.columns.TeammateID != nil {
		columns["teammate_id"] = standupteammate.TeammateID
	}
	if standupteammate.columns.TeamOwner != nil {
		columns["team_owner"] = standupteammate.TeamOwner
	}
	if standupteammate.columns.CreatedAt != nil {
		columns["created_at"] = standupteammate.CreatedAt
	}
	if standupteammate.columns.UpdatedAt != nil {
		columns["updated_at"] = standupteammate.UpdatedAt
	}

	return columns
}

// Find a `standupteammate` by its `standup_id`, `teammate_id`
func Find(db jack.DB, standupID *string, teammateID *string) (*StandupTeammate, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "standup_id", "teammate_id", "team_owner", "created_at", "updated_at"
	FROM jack.standups_teammates
	WHERE "standup_id" = $1 AND "teammate_id" = $2
	`
	jack.Log(sqlstr, standupID, teammateID)

	// run the query
	var cols *columns
	row := db.QueryRow(sqlstr, standupID, teammateID)
	if e := row.Scan(cols.StandupID, cols.TeammateID, cols.TeamOwner, cols.CreatedAt, cols.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupTeammateNotFound
		}
		return nil, e
	}

	return &StandupTeammate{cols}, nil
}

// Insert a `standupteammate` into `jack.standups_teammates`
func Insert(db jack.DB, standupteammate *StandupTeammate) (*StandupTeammate, error) {
	// get all the non-nil fields and prepare them for the query
	_c, _i, _v := jack.Slice(getColumns(standupteammate), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
	INSERT INTO jack.standups_teammates (` + strings.Join(_c, ", ") + `)
	VALUES (` + strings.Join(_i, ", ") + `)
	RETURNING "standup_id", "teammate_id", "team_owner", "created_at", "updated_at"
  `
	jack.Log(sqlstr, _v...)

	// run the query
	var cols *columns
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(cols.StandupID, cols.TeammateID, cols.TeamOwner, cols.CreatedAt, cols.UpdatedAt); e != nil {
		return nil, e
	}

	return &StandupTeammate{cols}, nil
}

// Update a `StandupTeammate` by its `standup_id`, `teammate_id`
func Update(db jack.DB, standupID *string, teammateID *string, standupteammate *StandupTeammate) (*StandupTeammate, error) {
	fields := getColumns(standupteammate)

	// first check if we have the foreign keys
	if standupID == nil {
		return nil, errors.New(`"standupID" must be non-nil`)
	}
	if teammateID == nil {
		return nil, errors.New(`"teammateID" must be non-nil`)
	}

	// don't update the foreign keys
	delete(fields, "standup_id")
	delete(fields, "teammate_id")

	// prepare the slices
	_c, _i, _v := jack.Slice(fields, 2)

	// sql query
	sqlstr := `UPDATE jack.standups_teammates SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `)
		WHERE "standup_id" = $1 AND "teammate_id" = $2
		RETURNING "standup_id", "teammate_id", "team_owner", "created_at", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, standupID)
	values = append(values, teammateID)

	values = append(values, _v...)
	jack.Log(sqlstr, values...)

	// run the query
	var cols *columns
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(cols.StandupID, cols.TeammateID, cols.TeamOwner, cols.CreatedAt, cols.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupTeammateNotFound
		}
		return nil, e
	}

	return &StandupTeammate{cols}, nil
}

// Delete a `StandupTeammate` by its `standup_id`, `teammate_id`
func Delete(db jack.DB, standupID *string, teammateID *string) error {
	// sql query
	const sqlstr = `
	DELETE FROM jack.standups_teammates
	WHERE "standup_id" = $1 AND "teammate_id" = $2
	`
	jack.Log(sqlstr, standupID, teammateID)

	// run query
	if _, e := db.Exec(sqlstr, standupID, teammateID); e != nil {
		if e == pgx.ErrNoRows {
			return ErrStandupTeammateNotFound
		}
		return e
	}

	return nil
}

package jack

import (
	"errors"
	"strings"
	"time"

	"github.com/jackc/pgx"
	uuid "github.com/satori/go.uuid"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrStandupNotFound returned if the standup is not found
var ErrStandupNotFound = errors.New("standup not found")

// Standups class
type Standups struct {
	db DB
}

// Standup model
type Standup struct {
	ID             *uuid.UUID              `json:"id,omitempty"`
	Name           *string                 `json:"name,omitempty"`
	SlackChannelID *string                 `json:"slack_channel_id,omitempty"`
	Time           *string                 `json:"time,omitempty"`
	Timezone       *string                 `json:"timezone,omitempty"`
	Questions      *map[string]interface{} `json:"questions,omitempty"`
	TeamID         *uuid.UUID              `json:"team_id,omitempty"`
	CreatedAt      *time.Time              `json:"created_at,omitempty"`
	UpdatedAt      *time.Time              `json:"updated_at,omitempty"`
}

// standup constructor
func standup(db DB) *Standups {
	return &Standups{db}
}

// get all the non-nil fields
func (standups *Standups) fields(standup *Standup) map[string]interface{} {
	fields := make(map[string]interface{})

	if standup.ID != nil {
		fields["id"] = standup.ID
	}
	if standup.Name != nil {
		fields["name"] = standup.Name
	}
	if standup.SlackChannelID != nil {
		fields["slack_channel_id"] = standup.SlackChannelID
	}
	if standup.Time != nil {
		fields["time"] = standup.Time
	}
	if standup.Timezone != nil {
		fields["timezone"] = standup.Timezone
	}
	if standup.Questions != nil {
		fields["questions"] = standup.Questions
	}
	if standup.TeamID != nil {
		fields["team_id"] = standup.TeamID
	}
	if standup.CreatedAt != nil {
		fields["created_at"] = standup.CreatedAt
	}
	if standup.UpdatedAt != nil {
		fields["updated_at"] = standup.UpdatedAt
	}

	return fields
}

// Find a standup by "id"
func (standups *Standups) Find(id *uuid.UUID) (standup *Standup, err error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"
	FROM jack.standups
	WHERE "id" = $1
	`

	Log(sqlstr, id)
	row := standups.db.QueryRow(sqlstr, id)
	if e := row.Scan(standup.ID, standup.Name, standup.SlackChannelID, standup.Time, standup.Timezone, standup.Questions, standup.TeamID, standup.CreatedAt, standup.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, e
	}

	return standup, nil
}

// FindBySlackChannelID find a standup by `slack_channel_id`
func (standups *Standups) FindBySlackChannelID(slackChannelID *string) (standup *Standup, err error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"
	FROM jack.standups
	WHERE "slack_channel_id" = $1
	`

	Log(sqlstr, slackChannelID)
	row := standups.db.QueryRow(sqlstr, slackChannelID)
	err = row.Scan(standup.ID, standup.Name, standup.SlackChannelID, standup.Time, standup.Timezone, standup.Questions, standup.TeamID, standup.CreatedAt, standup.UpdatedAt)
	if err != nil {
		if err == pgx.ErrNoRows {
			return standup, ErrStandupNotFound
		}
		return standup, err
	}

	return standup, nil
}

// FindMany find many `standup`s by a given condition
func (standups *Standups) FindMany(condition string, params ...interface{}) ([]*Standup, error) {
	var _o []*Standup

	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"
	FROM jack.standups
	WHERE ` + condition

	Log(sqlstr, params...)
	rows, err := standups.db.Query(sqlstr, params...)
	if err != nil {
		return _o, err
	}
	defer rows.Close()

	for rows.Next() {
		var standup *Standup
		if e := rows.Scan(standup.ID, standup.Name, standup.SlackChannelID, standup.Time, standup.Timezone, standup.Questions, standup.TeamID, standup.CreatedAt, standup.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return _o, ErrStandupNotFound
			}
			return _o, err
		}
		_o = append(_o, standup)
	}
	if rows.Err() != nil {
		return _o, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	if len(_o) == 0 {
		return make([]*Standup, 0), nil
	}

	return _o, nil
}

// FindOne find one standup by a condition
func (standups *Standups) FindOne(condition string, params ...interface{}) (standup *Standup, err error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"
	FROM jack.standups
	WHERE ` + condition

	Log(sqlstr, params...)
	row := standups.db.QueryRow(sqlstr, params...)
	if e := row.Scan(standup.ID, standup.Name, standup.SlackChannelID, standup.Time, standup.Timezone, standup.Questions, standup.TeamID, standup.CreatedAt, standup.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, e
	}

	return standup, nil
}

// Insert a `standup` into the `jack.standups` table.
func (standups *Standups) Insert(standup Standup) (*Standup, error) {
	// get all the non-nil fields and prepare them for the query
	_c, _i, _v := slice(standups.fields(&standup), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
	INSERT INTO jack.standups (` + strings.Join(_c, ", ") + `)
	VALUES (` + strings.Join(_i, ", ") + `)
	RETURNING "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"
	`

	Log(sqlstr, _v...)
	row := standups.db.QueryRow(sqlstr, _v...)
	if e := row.Scan(standup.ID, standup.Name, standup.SlackChannelID, standup.Time, standup.Timezone, standup.Questions, standup.TeamID, standup.CreatedAt, standup.UpdatedAt); e != nil {
		return nil, e
	}

	return &standup, nil
}

// Update a standup by its `id`
func (standups *Standups) Update(standup Standup, id *uuid.UUID) (*Standup, error) {
	fieldset := standups.fields(&standup)

	// first check if we have the primary key
	if id == nil {
		return nil, errors.New(`primary key "id" must be non-nil`)
	}

	// don't update the primary key
	delete(fieldset, "id")

	// prepare the slices
	_c, _i, _v := slice(fieldset, 1)

	// sql query
	sqlstr := `UPDATE jack.standups SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `)
		WHERE "id" = $1
		RETURNING "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"`

	// run query
	values := append([]interface{}{id}, _v...)
	Log(sqlstr, values...)

	row := standups.db.QueryRow(sqlstr, values...)
	if e := row.Scan(standup.ID, standup.Name, standup.SlackChannelID, standup.Time, standup.Timezone, standup.Questions, standup.TeamID, standup.CreatedAt, standup.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, e
	}

	return &standup, nil
}

// UpdateBySlackChannelID find a Standup
func (standups *Standups) UpdateBySlackChannelID(standup Standup, slackChannelID *string) (*Standup, error) {
	fieldset := standups.fields(&standup)

	// first check if we have all the keys we need
	if slackChannelID == nil {
		return nil, errors.New(`slackChannelID must be non-nil`)
	}

	// don't update the keys
	delete(fieldset, "slackChannelID")

	// prepare the slices
	_c, _i, _v := slice(fieldset, 1)

	// sql query
	sqlstr := `UPDATE jack.standups SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE "slack_channel_id" = $1 ` +
		`RETURNING "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"`

	// run query
	values := []interface{}{}
	values = append(values, slackChannelID)

	values = append(values, _v...)
	Log(sqlstr, values...)

	row := standups.db.QueryRow(sqlstr, values...)
	if e := row.Scan(standup.ID, standup.Name, standup.SlackChannelID, standup.Time, standup.Timezone, standup.Questions, standup.TeamID, standup.CreatedAt, standup.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, e
	}

	return &standup, nil
}

// UpdateMany rows in `jack.standups` by a given condition
func (standups *Standups) UpdateMany(standup *Standup, condition string, params ...interface{}) ([]*Standup, error) {
	var _o []*Standup

	// get the non-nil fields
	fieldset := standups.fields(standup)

	// prepare the slices
	_c, _i, _v := slice(fieldset, len(params))

	// sql query
	sqlstr := `UPDATE jack.standups SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE ` + condition + ` ` +
		`RETURNING "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"`

	values := []interface{}{}
	values = append(values, params...)
	values = append(values, _v...)

	// run query
	Log(sqlstr, values...)
	rows, err := standups.db.Query(sqlstr, values...)
	if err != nil {
		return _o, err
	}
	defer rows.Close()

	for rows.Next() {
		var standup *Standup
		if e := rows.Scan(standup.ID, standup.Name, standup.SlackChannelID, standup.Time, standup.Timezone, standup.Questions, standup.TeamID, standup.CreatedAt, standup.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return _o, ErrStandupNotFound
			}
			return _o, err
		}
		_o = append(_o, standup)
	}
	if rows.Err() != nil {
		return _o, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	if len(_o) == 0 {
		return make([]*Standup, 0), nil
	}

	return _o, nil
}

// Delete a `standup` from the `jack.standups` table
func (standups *Standups) Delete(id *uuid.UUID) error {
	// sql query
	sqlstr := `DELETE FROM jack.standups WHERE "id" = $1`

	// run query
	Log(sqlstr, id)
	if _, e := standups.db.Exec(sqlstr, id); e != nil {
		if e == pgx.ErrNoRows {
			return ErrStandupNotFound
		}
		return e
	}

	return nil
}

// DeleteBySlackChannelID find a Standup
func (standups *Standups) DeleteBySlackChannelID(slackChannelID *string) error {
	// sql delete query
	sqlstr := `DELETE FROM jack.standups WHERE "slack_channel_id" = $1`

	Log(sqlstr, slackChannelID)
	if _, e := standups.db.Exec(sqlstr, slackChannelID); e != nil {
		if e == pgx.ErrNoRows {
			return ErrStandupNotFound
		}
		return e
	}

	return nil
}

// DeleteMany delete many `standup`'s by the given condition
func (standups *Standups) DeleteMany(condition string, params ...interface{}) error {
	// sql select query, primary key provided by sequence
	sqlstr := `DELETE FROM jack.standups WHERE ` + condition

	Log(sqlstr, params...)
	if _, e := standups.db.Exec(sqlstr, params...); e != nil {
		return e
	}

	return nil
}

// Upsert the `standup` by its `id`.
func (standups *Standups) Upsert(standup Standup, action string) (*Standup, error) {
	fieldset := standups.fields(&standup)

	// prepare the slices
	_c, _i, _v := slice(fieldset, 0)

	// determine on conflict action
	var upsertAction string
	if action == UpsertDoUpdate {
		upsertAction = `DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `)`
	} else if action == UpsertDoNothing {
		upsertAction = UpsertDoNothing
	} else {
		return nil, errors.New("invalid upsert action")
	}

	// sql query
	sqlstr := `INSERT INTO jack.standups (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		upsertAction + ` ` +
		`RETURNING "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"`

		// run query
	Log(sqlstr, _v...)
	row := standups.db.QueryRow(sqlstr, _v...)
	if e := row.Scan(standup.ID, standup.Name, standup.SlackChannelID, standup.Time, standup.Timezone, standup.Questions, standup.TeamID, standup.CreatedAt, standup.UpdatedAt); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &standup, nil
}

// UpsertBySlackChannelID find a Standup
func (standups *Standups) UpsertBySlackChannelID(standup Standup, action string) (*Standup, error) {
	// get all the non-nil fields and prepare them for the query
	_c, _i, _v := slice(standups.fields(&standup), 0)

	// determine on conflict action
	var upsertAction string
	if action == UpsertDoUpdate {
		upsertAction = `DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `)`
	} else if action == UpsertDoNothing {
		upsertAction = UpsertDoNothing
	} else {
		return nil, errors.New("invalid upsert action")
	}

	// sql query
	sqlstr := `INSERT INTO jack.standups (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("slack_channel_id") ` +
		upsertAction + ` ` +
		`RETURNING "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"`

		// run query
	Log(sqlstr, _v...)
	row := standups.db.QueryRow(sqlstr, _v...)
	if e := row.Scan(standup.ID, standup.Name, standup.SlackChannelID, standup.Time, standup.Timezone, standup.Questions, standup.TeamID, standup.CreatedAt, standup.UpdatedAt); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &standup, nil
}

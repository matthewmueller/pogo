package jack_test

import (
	"testing"
	"time"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/pogo/jack"
	uuid "github.com/satori/go.uuid"
	"github.com/stretchr/testify/assert"
)

// GENERATED BY POGO. DO NOT EDIT.

func teamsDB(t *testing.T) jack.DB {
	config, err := pgx.ParseURI("postgres://localhost:5432/pogo?sslmode=disable")
	if err != nil {
		t.Fatal(err)
	}

	db, err := pgx.Connect(config)
	if err != nil {
		t.Fatal(err)
	}

	return db
}

func TestTeamsInsert(t *testing.T) {
	// setup the model
	model := jack.New(teamsDB(t))

	// random values
	_id := uuid.NewV4()
	_slackteamid := "00e3fa84-d540-4d43-bbf4-baa71f76d794"
	_slackteamaccesstoken := "9409ea83-6fd2-440e-8589-18cced8d7948"
	_slackbotaccesstoken := "a5311d61-fc84-47d5-ad3c-97d1a941133e"
	_slackbotid := "91f8e886-8599-4257-9f73-b447e340e8cc"
	_teamname := "d0ab7004-5fe6-4c97-bd25-04c222e308cc"
	_scope := []string{"b1dbff45-7e84-40fd-ad80-d4c7a834de50"}
	_email := "6392672d-7363-447c-b98a-5efeaefe0080"
	_stripeid := "761ed8fc-116f-49c2-8e84-0fe988a53a49"
	_active := false
	_freeteammates := 81
	_costperuser := 887
	_trialends := time.Now()
	_createdat := time.Now()
	_updatedat := time.Now()

	// struct
	team1 := jack.Team{
		ID:                   &_id,
		SlackTeamID:          &_slackteamid,
		SlackTeamAccessToken: &_slackteamaccesstoken,
		SlackBotAccessToken:  &_slackbotaccesstoken,
		SlackBotID:           &_slackbotid,
		TeamName:             &_teamname,
		Scope:                &_scope,
		Email:                &_email,
		StripeID:             &_stripeid,
		Active:               &_active,
		FreeTeammates:        &_freeteammates,
		CostPerUser:          &_costperuser,
		TrialEnds:            &_trialends,
		CreatedAt:            &_createdat,
		UpdatedAt:            &_updatedat,
	}

	team2, err := model.Team.Insert(team1)
	if err != nil {
		t.Fatal(err)
	}

	// assertions
	assert.Equal(t, _id, *team2.ID)
	assert.Equal(t, _slackteamid, *team2.SlackTeamID)
	assert.Equal(t, _slackteamaccesstoken, *team2.SlackTeamAccessToken)
	assert.Equal(t, _slackbotaccesstoken, *team2.SlackBotAccessToken)
	assert.Equal(t, _slackbotid, *team2.SlackBotID)
	assert.Equal(t, _teamname, *team2.TeamName)
	assert.Equal(t, _scope, *team2.Scope)
	assert.Equal(t, _email, *team2.Email)
	assert.Equal(t, _stripeid, *team2.StripeID)
	assert.Equal(t, _active, *team2.Active)
	assert.Equal(t, _freeteammates, *team2.FreeTeammates)
	assert.Equal(t, _costperuser, *team2.CostPerUser)
	assert.Equal(t, _trialends, *team2.TrialEnds)
	assert.Equal(t, _createdat, *team2.CreatedAt)
	assert.Equal(t, _updatedat, *team2.UpdatedAt)

	// cleanup
	if e := model.Team.Delete(&_id); e != nil {
		t.Fatal(e)
	}
}

func TestTeamsUpdate(t *testing.T) {
	// setup the model
	model := jack.New(teamsDB(t))

	// random values
	_id := uuid.NewV4()
	_slackteamid := "a205126c-5bfe-4dbb-9698-289815ff8ee4"
	_slackteamaccesstoken := "f12d3131-c95b-4308-9e7b-ce13294ca7a9"
	_slackbotaccesstoken := "e9c4df80-11c5-4fe1-9e69-1fe186788c46"
	_slackbotid := "978f1801-561f-49ff-91d8-2f7a889cbcd9"
	_teamname := "f080c5f5-4a75-4029-bb22-6b8456aea55e"
	_scope := []string{"0cba37f8-1fc3-4d9f-a7d3-0ac062454f5c"}
	_email := "59a02711-bf46-4db9-9977-c9a6b68121b3"
	_stripeid := "4a2bfb40-81a6-483d-ae17-188ec2ec0ee0"
	_active := false
	_freeteammates := 847
	_costperuser := 59
	_trialends := time.Now()
	_createdat := time.Now()
	_updatedat := time.Now()

	// struct
	team1 := jack.Team{
		ID:                   &_id,
		SlackTeamID:          &_slackteamid,
		SlackTeamAccessToken: &_slackteamaccesstoken,
		SlackBotAccessToken:  &_slackbotaccesstoken,
		SlackBotID:           &_slackbotid,
		TeamName:             &_teamname,
		Scope:                &_scope,
		Email:                &_email,
		StripeID:             &_stripeid,
		Active:               &_active,
		FreeTeammates:        &_freeteammates,
		CostPerUser:          &_costperuser,
		TrialEnds:            &_trialends,
		CreatedAt:            &_createdat,
		UpdatedAt:            &_updatedat,
	}

	team2, err := model.Team.Insert(team1)
	if err != nil {
		t.Fatal(err)
	}

	// random values
	_id2 := uuid.NewV4()
	_slackteamid2 := "9e6977f4-f978-4894-a511-3efbe7dbb5f1"
	_slackteamaccesstoken2 := "493258c4-7fcf-4706-bed9-431328743662"
	_slackbotaccesstoken2 := "0f14c178-c7a1-48df-99a1-3fe8336a76b9"
	_slackbotid2 := "857f8c58-c8ba-45a5-949e-43bfcae7d097"
	_teamname2 := "f5af7a3b-59a0-4c0c-a5ce-a5cdf9305fa9"
	_scope2 := []string{"3ac7e7ea-be24-464d-b35c-dc1fbf486407"}
	_email2 := "29e97bb4-078b-41ae-b687-e9ebe3c6e7f5"
	_stripeid2 := "b095d719-1ffb-492e-8d78-a4ffb95dca03"
	_active2 := false
	_freeteammates2 := 81
	_costperuser2 := 318
	_trialends2 := time.Now()
	_createdat2 := time.Now()
	_updatedat2 := time.Now()

	// random values
	team2.ID = &_id2
	team2.SlackTeamID = &_slackteamid2
	team2.SlackTeamAccessToken = &_slackteamaccesstoken2
	team2.SlackBotAccessToken = &_slackbotaccesstoken2
	team2.SlackBotID = &_slackbotid2
	team2.TeamName = &_teamname2
	team2.Scope = &_scope2
	team2.Email = &_email2
	team2.StripeID = &_stripeid2
	team2.Active = &_active2
	team2.FreeTeammates = &_freeteammates2
	team2.CostPerUser = &_costperuser2
	team2.TrialEnds = &_trialends2
	team2.CreatedAt = &_createdat2
	team2.UpdatedAt = &_updatedat2

	team3, err := model.Team.Update(*team2, &_id)
	if err != nil {
		t.Fatal(err)
	}

	// assertions
	assert.Equal(t, _id2, *team3.ID)
	assert.Equal(t, _slackteamid2, *team3.SlackTeamID)
	assert.Equal(t, _slackteamaccesstoken2, *team3.SlackTeamAccessToken)
	assert.Equal(t, _slackbotaccesstoken2, *team3.SlackBotAccessToken)
	assert.Equal(t, _slackbotid2, *team3.SlackBotID)
	assert.Equal(t, _teamname2, *team3.TeamName)
	assert.Equal(t, _scope2, *team3.Scope)
	assert.Equal(t, _email2, *team3.Email)
	assert.Equal(t, _stripeid2, *team3.StripeID)
	assert.Equal(t, _active2, *team3.Active)
	assert.Equal(t, _freeteammates2, *team3.FreeTeammates)
	assert.Equal(t, _costperuser2, *team3.CostPerUser)
	assert.Equal(t, _trialends2, *team3.TrialEnds)
	assert.Equal(t, _createdat2, *team3.CreatedAt)
	assert.Equal(t, _updatedat2, *team3.UpdatedAt)

	// cleanup
	if e := model.Team.Delete(&_id); e != nil {
		t.Fatal(e)
	}
}

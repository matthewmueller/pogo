package jack2

import (
	"errors"
	"strings"
	"time"

	"github.com/jackc/pgx"
	uuid "github.com/satori/go.uuid"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrTeammateNotFound returned if the teammate is not found
var ErrTeammateNotFound = errors.New("teammate not found")

// Teammates class
type Teammates struct {
	db DB
}

// Teammate model
type Teammate struct {
	ID        *uuid.UUID `json:"id,omitempty"`
	SlackID   *string    `json:"slack_id,omitempty"`
	Username  *string    `json:"username,omitempty"`
	FirstName *string    `json:"first_name,omitempty"`
	LastName  *string    `json:"last_name,omitempty"`
	Email     *string    `json:"email,omitempty"`
	Avatar    *string    `json:"avatar,omitempty"`
	Timezone  *string    `json:"timezone,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// teammate constructor
func teammate(db DB) *Teammates {
	return &Teammates{db}
}

// get all the non-nil fields
func (teammates *Teammates) fields(teammate *Teammate) map[string]interface{} {
	fields := make(map[string]interface{})

	if teammate.ID != nil {
		fields["id"] = teammate.ID
	}
	if teammate.SlackID != nil {
		fields["slack_id"] = teammate.SlackID
	}
	if teammate.Username != nil {
		fields["username"] = teammate.Username
	}
	if teammate.FirstName != nil {
		fields["first_name"] = teammate.FirstName
	}
	if teammate.LastName != nil {
		fields["last_name"] = teammate.LastName
	}
	if teammate.Email != nil {
		fields["email"] = teammate.Email
	}
	if teammate.Avatar != nil {
		fields["avatar"] = teammate.Avatar
	}
	if teammate.Timezone != nil {
		fields["timezone"] = teammate.Timezone
	}
	if teammate.CreatedAt != nil {
		fields["created_at"] = teammate.CreatedAt
	}
	if teammate.UpdatedAt != nil {
		fields["updated_at"] = teammate.UpdatedAt
	}

	return fields
}

// Find a teammate by "id"
func (teammates *Teammates) Find(id *uuid.UUID) (teammate *Teammate, err error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"
	FROM jack.teammates
	WHERE "id" = $1
	`

	Log(sqlstr, id)
	row := teammates.db.QueryRow(sqlstr, id)
	if e := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, e
	}

	return teammate, nil
}

// FindByID find a teammate by `id`
func (teammates *Teammates) FindByID(iD *uuid.UUID) (teammate *Teammate, err error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"
	FROM jack.teammates
	WHERE "id" = $1
	`

	Log(sqlstr, iD)
	row := teammates.db.QueryRow(sqlstr, iD)
	err = row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt)
	if err != nil {
		if err == pgx.ErrNoRows {
			return teammate, ErrTeammateNotFound
		}
		return teammate, err
	}

	return teammate, nil
}

// FindBySlackID find a teammate by `slack_id`
func (teammates *Teammates) FindBySlackID(slackID *string) (teammate *Teammate, err error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"
	FROM jack.teammates
	WHERE "slack_id" = $1
	`

	Log(sqlstr, slackID)
	row := teammates.db.QueryRow(sqlstr, slackID)
	err = row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt)
	if err != nil {
		if err == pgx.ErrNoRows {
			return teammate, ErrTeammateNotFound
		}
		return teammate, err
	}

	return teammate, nil
}

// FindMany find many `teammate`s by a given condition
func (teammates *Teammates) FindMany(condition string, params ...interface{}) ([]*Teammate, error) {
	var _o []*Teammate

	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"
	FROM jack.teammates
	WHERE ` + condition

	Log(sqlstr, params...)
	rows, err := teammates.db.Query(sqlstr, params...)
	if err != nil {
		return _o, err
	}
	defer rows.Close()

	for rows.Next() {
		var teammate *Teammate
		if e := rows.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return _o, ErrTeammateNotFound
			}
			return _o, err
		}
		_o = append(_o, teammate)
	}
	if rows.Err() != nil {
		return _o, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	if len(_o) == 0 {
		return make([]*Teammate, 0), nil
	}

	return _o, nil
}

// FindOne find one teammate by a condition
func (teammates *Teammates) FindOne(condition string, params ...interface{}) (teammate *Teammate, err error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"
	FROM jack.teammates
	WHERE ` + condition

	Log(sqlstr, params...)
	row := teammates.db.QueryRow(sqlstr, params...)
	if e := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, e
	}

	return teammate, nil
}

// Insert a `teammate` into the `jack.teammates` table.
func (teammates *Teammates) Insert(teammate Teammate) (*Teammate, error) {
	// get all the non-nil fields and prepare them for the query
	_c, _i, _v := slice(teammates.fields(&teammate), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
	INSERT INTO jack.teammates (` + strings.Join(_c, ", ") + `)
	VALUES (` + strings.Join(_i, ", ") + `)
	RETURNING "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"
	`

	Log(sqlstr, _v...)
	row := teammates.db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil {
		return nil, e
	}

	return &teammate, nil
}

// Update a teammate by its `id`
func (teammates *Teammates) Update(teammate Teammate, id *uuid.UUID) (*Teammate, error) {
	fieldset := teammates.fields(&teammate)

	// first check if we have the primary key
	if id == nil {
		return nil, errors.New(`primary key "id" must be non-nil`)
	}

	// don't update the primary key
	delete(fieldset, "id")

	// prepare the slices
	_c, _i, _v := slice(fieldset, 1)

	// sql query
	sqlstr := `UPDATE jack.teammates SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `)
		WHERE "id" = $1
		RETURNING "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"`

	// run query
	values := append([]interface{}{id}, _v...)
	Log(sqlstr, values...)

	row := teammates.db.QueryRow(sqlstr, values...)
	if e := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, e
	}

	return &teammate, nil
}

// UpdateByID find a Teammate
func (teammates *Teammates) UpdateByID(teammate Teammate, iD *uuid.UUID) (*Teammate, error) {
	fieldset := teammates.fields(&teammate)

	// first check if we have all the keys we need
	if iD == nil {
		return nil, errors.New(`iD must be non-nil`)
	}

	// don't update the keys
	delete(fieldset, "iD")

	// prepare the slices
	_c, _i, _v := slice(fieldset, 1)

	// sql query
	sqlstr := `UPDATE jack.teammates SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE "id" = $1 ` +
		`RETURNING "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"`

	// run query
	values := []interface{}{}
	values = append(values, iD)

	values = append(values, _v...)
	Log(sqlstr, values...)

	row := teammates.db.QueryRow(sqlstr, values...)
	if e := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, e
	}

	return &teammate, nil
}

// UpdateBySlackID find a Teammate
func (teammates *Teammates) UpdateBySlackID(teammate Teammate, slackID *string) (*Teammate, error) {
	fieldset := teammates.fields(&teammate)

	// first check if we have all the keys we need
	if slackID == nil {
		return nil, errors.New(`slackID must be non-nil`)
	}

	// don't update the keys
	delete(fieldset, "slackID")

	// prepare the slices
	_c, _i, _v := slice(fieldset, 1)

	// sql query
	sqlstr := `UPDATE jack.teammates SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE "slack_id" = $1 ` +
		`RETURNING "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"`

	// run query
	values := []interface{}{}
	values = append(values, slackID)

	values = append(values, _v...)
	Log(sqlstr, values...)

	row := teammates.db.QueryRow(sqlstr, values...)
	if e := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, e
	}

	return &teammate, nil
}

// UpdateMany rows in `jack.teammates` by a given condition
func (teammates *Teammates) UpdateMany(teammate *Teammate, condition string, params ...interface{}) ([]*Teammate, error) {
	var _o []*Teammate

	// get the non-nil fields
	fieldset := teammates.fields(teammate)

	// prepare the slices
	_c, _i, _v := slice(fieldset, len(params))

	// sql query
	sqlstr := `UPDATE jack.teammates SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE ` + condition + ` ` +
		`RETURNING "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"`

	values := []interface{}{}
	values = append(values, params...)
	values = append(values, _v...)

	// run query
	Log(sqlstr, values...)
	rows, err := teammates.db.Query(sqlstr, values...)
	if err != nil {
		return _o, err
	}
	defer rows.Close()

	for rows.Next() {
		var teammate *Teammate
		if e := rows.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return _o, ErrTeammateNotFound
			}
			return _o, err
		}
		_o = append(_o, teammate)
	}
	if rows.Err() != nil {
		return _o, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	if len(_o) == 0 {
		return make([]*Teammate, 0), nil
	}

	return _o, nil
}

// Delete a `teammate` from the `jack.teammates` table
func (teammates *Teammates) Delete(id *uuid.UUID) error {
	// sql query
	sqlstr := `DELETE FROM jack.teammates WHERE "id" = $1`

	// run query
	Log(sqlstr, id)
	if _, e := teammates.db.Exec(sqlstr, id); e != nil {
		if e == pgx.ErrNoRows {
			return ErrTeammateNotFound
		}
		return e
	}

	return nil
}

// DeleteByID find a Teammate
func (teammates *Teammates) DeleteByID(iD *uuid.UUID) error {
	// sql delete query
	sqlstr := `DELETE FROM jack.teammates WHERE "id" = $1`

	Log(sqlstr, iD)
	if _, e := teammates.db.Exec(sqlstr, iD); e != nil {
		if e == pgx.ErrNoRows {
			return ErrTeammateNotFound
		}
		return e
	}

	return nil
}

// DeleteBySlackID find a Teammate
func (teammates *Teammates) DeleteBySlackID(slackID *string) error {
	// sql delete query
	sqlstr := `DELETE FROM jack.teammates WHERE "slack_id" = $1`

	Log(sqlstr, slackID)
	if _, e := teammates.db.Exec(sqlstr, slackID); e != nil {
		if e == pgx.ErrNoRows {
			return ErrTeammateNotFound
		}
		return e
	}

	return nil
}

// DeleteMany delete many `teammate`'s by the given condition
func (teammates *Teammates) DeleteMany(condition string, params ...interface{}) error {
	// sql select query, primary key provided by sequence
	sqlstr := `DELETE FROM jack.teammates WHERE ` + condition

	Log(sqlstr, params...)
	if _, e := teammates.db.Exec(sqlstr, params...); e != nil {
		return e
	}

	return nil
}

// Upsert the `teammate` by its `id`.
func (teammates *Teammates) Upsert(teammate Teammate, action string) (*Teammate, error) {
	fieldset := teammates.fields(&teammate)

	// prepare the slices
	_c, _i, _v := slice(fieldset, 0)

	// determine on conflict action
	var upsertAction string
	if action == UpsertDoUpdate {
		upsertAction = `DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `)`
	} else if action == UpsertDoNothing {
		upsertAction = UpsertDoNothing
	} else {
		return nil, errors.New("invalid upsert action")
	}

	// sql query
	sqlstr := `INSERT INTO jack.teammates (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		upsertAction + ` ` +
		`RETURNING "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"`

		// run query
	Log(sqlstr, _v...)
	row := teammates.db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &teammate, nil
}

// UpsertByID find a Teammate
func (teammates *Teammates) UpsertByID(teammate Teammate, action string) (*Teammate, error) {
	// get all the non-nil fields and prepare them for the query
	_c, _i, _v := slice(teammates.fields(&teammate), 0)

	// determine on conflict action
	var upsertAction string
	if action == UpsertDoUpdate {
		upsertAction = `DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `)`
	} else if action == UpsertDoNothing {
		upsertAction = UpsertDoNothing
	} else {
		return nil, errors.New("invalid upsert action")
	}

	// sql query
	sqlstr := `INSERT INTO jack.teammates (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		upsertAction + ` ` +
		`RETURNING "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"`

		// run query
	Log(sqlstr, _v...)
	row := teammates.db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &teammate, nil
}

// UpsertBySlackID find a Teammate
func (teammates *Teammates) UpsertBySlackID(teammate Teammate, action string) (*Teammate, error) {
	// get all the non-nil fields and prepare them for the query
	_c, _i, _v := slice(teammates.fields(&teammate), 0)

	// determine on conflict action
	var upsertAction string
	if action == UpsertDoUpdate {
		upsertAction = `DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `)`
	} else if action == UpsertDoNothing {
		upsertAction = UpsertDoNothing
	} else {
		return nil, errors.New("invalid upsert action")
	}

	// sql query
	sqlstr := `INSERT INTO jack.teammates (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("slack_id") ` +
		upsertAction + ` ` +
		`RETURNING "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"`

		// run query
	Log(sqlstr, _v...)
	row := teammates.db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &teammate, nil
}

package event

import (
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/jack/pogo"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrEventNotFound returned if the events is not found
var ErrEventNotFound = errors.New("event not found")

// Event result data for "jack"."events"
type Event struct {
	ID   int        `json:"id,omitempty"`
	Time *time.Time `json:"time,omitempty"`
}

var _ pogo.Row = (*Event)(nil)

// Decode implements pogo.Row
func (e *Event) Decode(event interface{}) error {
	_event, ok := event.(*Event)
	if !ok {
		return fmt.Errorf(`event decode: "%T" is not a "*Event"`, event)
	}
	*_event = *e
	return nil
}

// New "jack"."events" input
func New() *Input {
	return &Input{}
}

// Input data for "jack"."events"
type Input struct {
	id           *int
	time         *time.Time
	nullableTime **time.Time
}

var _ pogo.Insertable = (*Input)(nil)

// ID sets the "id"
func (e *Input) ID(id int) *Input {
	e.id = &id
	return e
}

// Time sets the "time"
func (e *Input) Time(time time.Time) *Input {
	e.time = &time
	return e
}

// NullableTime will set the `time` to NULL if `time` is null
func (e *Input) NullableTime(time *time.Time) *Input {
	e.nullableTime = &time
	return e
}

// MarshalJSON marshals the "event" into JSON
func (e *Input) MarshalJSON() ([]byte, error) {
	return json.Marshal(e)
}

// UnmarshalJSON unmarshals json to a "event"
func (e *Input) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, e)
}

func (e *Input) String() string {
	return "events"
}

func (e *Input) columns() map[string]interface{} {
	columns := make(map[string]interface{})

	if e.id != nil {
		columns["id"] = *e.id
	}

	if e.nullableTime != nil {
		columns["time"] = *e.nullableTime
	}
	if e.time != nil {
		columns["time"] = *e.time
	}

	return columns
}

// Insert implements pogo.Insertable
func (e *Input) Insert(db pogo.DB) (pogo.Row, error) {
	return Insert(db, e)
}

// NewFilter creates a new filter
func NewFilter() *Filter {
	return &Filter{}
}

// Filter filters for "jack"."events"
type Filter struct {
	formats []string
	values  []interface{}
}

var _ pogo.Condition = (*Filter)(nil)

// Clause fn
func (f *Filter) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "WHERE",
		Format: strings.Join(f.formats, " AND "),
		Params: f.values,
	}
}

// And filter
// func (f *Filter) And(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " AND "))
//   return f
// }

// Or filter
// func (f *Filter) Or(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " OR "))
//   return f
// }

// ID id equals
func (f *Filter) ID(v int) *Filter {
	f.formats = append(f.formats, `"id" = %s`)
	f.values = append(f.values, v)
	return f
}

// IDNot id doesn't equal
func (f *Filter) IDNot(v int) *Filter {
	f.formats = append(f.formats, `"id" != %s`)
	f.values = append(f.values, v)
	return f
}

// IDLt id is less than
func (f *Filter) IDLt(v int) *Filter {
	f.formats = append(f.formats, `"id" < %s`)
	f.values = append(f.values, v)
	return f
}

// IDLte id is less than or equal
func (f *Filter) IDLte(v int) *Filter {
	f.formats = append(f.formats, `"id" <= %s`)
	f.values = append(f.values, v)
	return f
}

// IDGt id is greater than
func (f *Filter) IDGt(v int) *Filter {
	f.formats = append(f.formats, `"id" > %s`)
	f.values = append(f.values, v)
	return f
}

// IDGte id is greater than or equal
func (f *Filter) IDGte(v int) *Filter {
	f.formats = append(f.formats, `"id" >= %s`)
	f.values = append(f.values, v)
	return f
}

// IDIn id is in
func (f *Filter) IDIn(v ...int) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"id" IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// IDNotIn id is not in
func (f *Filter) IDNotIn(v ...int) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"id" NOT IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// Time time is equal to
func (f *Filter) Time(v time.Time) *Filter {
	f.formats = append(f.formats, `"time" = %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// TimeNot time is not equal to
func (f *Filter) TimeNot(v time.Time) *Filter {
	f.formats = append(f.formats, `"time" != %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// TimeIn time is in
func (f *Filter) TimeIn(v ...time.Time) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"time" IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i.Format("2006-01-02 15:04:05.999999999Z07:00"))
	}
	return f
}

// TimeNotIn time is not in
func (f *Filter) TimeNotIn(v ...time.Time) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"time" NOT IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i.Format("2006-01-02 15:04:05.999999999Z07:00"))
	}
	return f
}

// TimeLt time is less than
func (f *Filter) TimeLt(v time.Time) *Filter {
	f.formats = append(f.formats, `"time" < %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// TimeLte time is less than or equal
func (f *Filter) TimeLte(v time.Time) *Filter {
	f.formats = append(f.formats, `"time" <= %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// TimeGt time is greater than
func (f *Filter) TimeGt(v time.Time) *Filter {
	f.formats = append(f.formats, `"time" > %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// TimeGte time is greater than or equal
func (f *Filter) TimeGte(v time.Time) *Filter {
	f.formats = append(f.formats, `"time" >= %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// NullableTime nullable time equals
func (f *Filter) NullableTime(v *time.Time) *Filter {
	if v == nil {
		f.formats = append(f.formats, `"time" IS NULL`)
		return f
	}
	f.formats = append(f.formats, `"time" = %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// NullableTimeNot nullable time is not equal
func (f *Filter) NullableTimeNot(v *time.Time) *Filter {
	if v == nil {
		f.formats = append(f.formats, `"time" IS NOT NULL`)
		return f
	}
	f.formats = append(f.formats, `"time" != %s`)
	f.values = append(f.values, v.Format("2006-01-02 15:04:05.999999999Z07:00"))
	return f
}

// OrderBy specificies the ORDERBy BY <order>
type OrderBy string

const (
	// ASC sorts by ascending order
	ASC OrderBy = "ASC"

	// DESC sorts by descending order
	DESC OrderBy = "DESC"
)

// NewOrder fn
func NewOrder() *Order {
	return &Order{}
}

var _ pogo.Condition = (*Order)(nil)

// Order orders the given fields
type Order struct {
	formats []string
}

// Clause fn
func (o *Order) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "ORDER BY",
		Format: strings.Join(o.formats, ", "),
	}
}

// ID sorts `id` by an expression
func (o *Order) ID(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"id" %s`, order))
	return o
}

// Time sorts `time` by an expression
func (o *Order) Time(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"time" %s`, order))
	return o
}

// Insert a "events" into the "jack"."events"
func Insert(db pogo.DB, event *Input) (*Event, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(event.columns(), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
    INSERT INTO "jack"."events" (` + strings.Join(_c, ", ") + `)
    VALUES (` + strings.Join(_i, ", ") + `)
    RETURNING "id", "time"
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _event Event
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_event.ID, &_event.Time); e != nil {
		return nil, e
	}

	return &_event, nil
}

// InsertMany "events" into the "jack"."events"
func InsertMany(db pogo.DB, events ...*Input) ([]*Event, error) {
	_events := []*Event{}
	for _, event := range events {
		_event, err := Insert(db, event)
		if err != nil {
			return _events, err
		}
		_events = append(_events, _event)
	}
	return _events, nil
}

// Find a `Event` by some conditions.
func Find(db pogo.DB, conds ...pogo.Condition) (*Event, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "id", "time" ` +
		`FROM "jack"."events" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _event Event
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_event.ID, &_event.Time); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrEventNotFound
		}
		return nil, e
	}

	return &_event, nil
}

// FindByID a `Event` by some conditions.
func FindByID(db pogo.DB, id int) (*Event, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "time"
    FROM "jack"."events"
    WHERE "id" = $1
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, &id)
	}

	var _event Event
	row := db.QueryRow(sqlstr, &id)
	if e := row.Scan(&_event.ID, &_event.Time); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrEventNotFound
		}
		return nil, e
	}

	return &_event, nil
}

// FindMany finds many "jack"."events" by a condition
func FindMany(db pogo.DB, conds ...pogo.Condition) ([]*Event, error) {
	events := []*Event{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return events, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "id", "time" ` +
		`FROM "jack"."events" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return events, err
	}
	defer rows.Close()

	for rows.Next() {
		var _event Event
		if e := rows.Scan(&_event.ID, &_event.Time); e != nil {
			if e == pgx.ErrNoRows {
				return events, ErrEventNotFound
			}
			return events, err
		}
		events = append(events, &_event)
	}
	if rows.Err() != nil {
		return events, rows.Err()
	}

	return events, nil
}

// Update "events" rows in "jack"."events" by a condition, returning 1 result
func Update(db pogo.DB, event *Input, conds ...pogo.Condition) (*Event, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	fields := event.columns()

	// prepare the slices
	_c, _i, _v2 := slice(fields, len(_v))
	_v = append(_v, _v2...)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("event.Update: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "jack"."events" SET ` +
		strings.Join(_u, ", ") + ` ` +
		_s + ` ` +
		`RETURNING "id", "time"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run the query
	var _event Event
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_event.ID, &_event.Time); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrEventNotFound
		}
		return nil, e
	}

	return &_event, nil
}

// UpdateMany updates "events" rows in "jack"."events" by conditions, returning all results
func UpdateMany(db pogo.DB, event *Input, conds ...pogo.Condition) ([]*Event, error) {
	events := []*Event{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	fields := event.columns()

	// prepare the slices
	_c, _i, _v2 := slice(fields, len(_v))
	_v = append(_v, _v2...)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("event.UpdateMany: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "jack"."events" SET ` +
		strings.Join(_u, ", ") + ` ` +
		_s + ` ` +
		`RETURNING "id", "time"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return events, err
	}
	defer rows.Close()

	for rows.Next() {
		var _event Event
		if e := rows.Scan(&_event.ID, &_event.Time); e != nil {
			if e == pgx.ErrNoRows {
				return events, ErrEventNotFound
			}
			return events, err
		}
		events = append(events, &_event)
	}
	if rows.Err() != nil {
		return events, rows.Err()
	}

	return events, nil
}

// UpdateByID a "event" in "jack"."events" by its "id"
func UpdateByID(db pogo.DB, id int, event *Input) (*Event, error) {
	fields := event.columns()

	// don't update the primary key
	delete(fields, "id")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("event.UpdateByID: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "jack"."events" ` +
		`SET ` + strings.Join(_u, ", ") + ` ` +
		`WHERE "id" = $1 ` +
		`RETURNING "id", "time"`

	// setup query
	values := append([]interface{}{&id}, _v...)

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, values...)
	}

	// run the query
	var _event Event
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&_event.ID, &_event.Time); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrEventNotFound
		}
		return nil, e
	}

	return &_event, nil
}

// Delete `Event`s by some conditions. Returns the first result.
func Delete(db pogo.DB, conds ...pogo.Condition) (*Event, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql delete query
	sqlstr := `DELETE FROM "jack"."events" ` +
		_s + ` ` +
		`RETURNING "id", "time"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _event Event
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_event.ID, &_event.Time); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrEventNotFound
		}
		return nil, e
	}

	return &_event, nil
}

// DeleteMany `Event`s by some conditions, returning all results.
func DeleteMany(db pogo.DB, conds ...pogo.Condition) ([]*Event, error) {
	events := []*Event{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return events, err
	}

	// sql delete query
	sqlstr := `DELETE FROM "jack"."events" ` +
		_s + ` ` +
		`RETURNING "id", "time"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return events, err
	}
	defer rows.Close()

	for rows.Next() {
		var _event Event
		if e := rows.Scan(&_event.ID, &_event.Time); e != nil {
			if e == pgx.ErrNoRows {
				return events, ErrEventNotFound
			}
			return events, err
		}
		events = append(events, &_event)
	}
	if rows.Err() != nil {
		return events, rows.Err()
	}

	return events, nil
}

// DeleteByID a "event" from the "jack"."events" table
func DeleteByID(db pogo.DB, id int) (*Event, error) {
	// sql delete query
	sqlstr := `DELETE FROM "jack"."events" ` +
		`WHERE "id" = $1 ` +
		`RETURNING "id", "time"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, id)
	}

	// run the query
	var _event Event
	row := db.QueryRow(sqlstr, id)
	if e := row.Scan(&_event.ID, &_event.Time); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrEventNotFound
		}
		return nil, e
	}

	return &_event, nil
}

// UpsertByID inserts a `events`, updating the row if `ID` already exists.
func UpsertByID(db pogo.DB, id int, event *Input) (*Event, error) {
	// add values to input, overriding existing keys if present in the input
	event = event.ID(id)

	fields := event.columns()

	// prepare the slices
	_c, _i, _v := slice(fields, 0)

	// setup the update fields
	var _u []string
	for _, c := range _c {
		_u = append(_u, c+" = EXCLUDED."+c)
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("event.UpsertByID: no input provided")
	}

	// sql query
	sqlstr := `INSERT INTO "jack"."events" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT (id) ` +
		`DO UPDATE SET ` + strings.Join(_u, ", ") + ` ` +
		`RETURNING "id", "time"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run query
	var _event Event
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_event.ID, &_event.Time); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &_event, nil
}

// slice converts our columns into something the sql driver can understand
func slice(columns map[string]interface{}, offset int) (c []string, i []string, v []interface{}) {
	n := offset + 1
	for col, val := range columns {
		c = append(c, `"`+col+`"`)
		i = append(i, "$"+strconv.Itoa(n))
		v = append(v, val)
		n++
	}
	return c, i, v
}

package convo

import (
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/jack/pogo"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrConvoNotFound returned if the convos is not found
var ErrConvoNotFound = errors.New("convo not found")

// Convo result data for "jack"."convos"
type Convo struct {
	User   string          `json:"user,omitempty"`
	Intent *string         `json:"intent,omitempty"`
	Slot   *string         `json:"slot,omitempty"`
	State  json.RawMessage `json:"state,omitempty"`
	TTL    *int            `json:"ttl,omitempty"`
}

var _ pogo.Row = (*Convo)(nil)

// Decode implements pogo.Row
func (c *Convo) Decode(convo interface{}) error {
	_convo, ok := convo.(*Convo)
	if !ok {
		return fmt.Errorf(`convo decode: "%T" is not a "*Convo"`, convo)
	}
	*_convo = *c
	return nil
}

// New "jack"."convos" input
func New() *Input {
	return &Input{}
}

// Input data for "jack"."convos"
type Input struct {
	user           *string
	intent         *string
	nullableIntent **string
	slot           *string
	nullableSlot   **string
	state          *json.RawMessage
	ttl            *int
	nullableTTL    **int
}

var _ pogo.Insertable = (*Input)(nil)

// User sets the "user"
func (c *Input) User(user string) *Input {
	c.user = &user
	return c
}

// Intent sets the "intent"
func (c *Input) Intent(intent string) *Input {
	c.intent = &intent
	return c
}

// NullableIntent will set the `intent` to NULL if `intent` is null
func (c *Input) NullableIntent(intent *string) *Input {
	c.nullableIntent = &intent
	return c
}

// Slot sets the "slot"
func (c *Input) Slot(slot string) *Input {
	c.slot = &slot
	return c
}

// NullableSlot will set the `slot` to NULL if `slot` is null
func (c *Input) NullableSlot(slot *string) *Input {
	c.nullableSlot = &slot
	return c
}

// State sets the "state"
func (c *Input) State(state json.RawMessage) *Input {
	c.state = &state
	return c
}

// TTL sets the "ttl"
func (c *Input) TTL(ttl int) *Input {
	c.ttl = &ttl
	return c
}

// NullableTTL will set the `ttl` to NULL if `ttl` is null
func (c *Input) NullableTTL(ttl *int) *Input {
	c.nullableTTL = &ttl
	return c
}

// MarshalJSON marshals the "convo" into JSON
func (c *Input) MarshalJSON() ([]byte, error) {
	return json.Marshal(c)
}

// UnmarshalJSON unmarshals json to a "convo"
func (c *Input) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, c)
}

func (c *Input) String() string {
	return "convos"
}

func (c *Input) columns() map[string]interface{} {
	columns := make(map[string]interface{})

	if c.user != nil {
		columns["user"] = *c.user
	}

	if c.nullableIntent != nil {
		columns["intent"] = *c.nullableIntent
	}
	if c.intent != nil {
		columns["intent"] = *c.intent
	}

	if c.nullableSlot != nil {
		columns["slot"] = *c.nullableSlot
	}
	if c.slot != nil {
		columns["slot"] = *c.slot
	}

	if c.state != nil {
		columns["state"] = *c.state
	}

	if c.nullableTTL != nil {
		columns["ttl"] = *c.nullableTTL
	}
	if c.ttl != nil {
		columns["ttl"] = *c.ttl
	}

	return columns
}

// Insert implements pogo.Insertable
func (c *Input) Insert(db pogo.DB) (pogo.Row, error) {
	return Insert(db, c)
}

// NewFilter creates a new filter
func NewFilter() *Filter {
	return &Filter{}
}

// Filter filters for "jack"."convos"
type Filter struct {
	formats []string
	values  []interface{}
}

var _ pogo.Condition = (*Filter)(nil)

// Clause fn
func (f *Filter) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "WHERE",
		Format: strings.Join(f.formats, " AND "),
		Params: f.values,
	}
}

// And filter
// func (f *Filter) And(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " AND "))
//   return f
// }

// Or filter
// func (f *Filter) Or(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " OR "))
//   return f
// }

// User user equals
func (f *Filter) User(v string) *Filter {
	f.formats = append(f.formats, `"user" = %s`)
	f.values = append(f.values, v)
	return f
}

// UserNot user doesn't equal
func (f *Filter) UserNot(v string) *Filter {
	f.formats = append(f.formats, `"user" != %s`)
	f.values = append(f.values, v)
	return f
}

// UserContains user contains
func (f *Filter) UserContains(v string) *Filter {
	f.formats = append(f.formats, `"user" LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// UserNotContains user doesn't contain
func (f *Filter) UserNotContains(v string) *Filter {
	f.formats = append(f.formats, `"user" NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// UserStartsWith user starts with
func (f *Filter) UserStartsWith(v string) *Filter {
	f.formats = append(f.formats, `"user" LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// UserNotStartsWith user doesn't start with
func (f *Filter) UserNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `"user" NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// UserEndsWith user ends with
func (f *Filter) UserEndsWith(v string) *Filter {
	f.formats = append(f.formats, `"user" LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// UserNotEndsWith user doesn't end with
func (f *Filter) UserNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `"user" NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// UserLt user is less than
func (f *Filter) UserLt(v string) *Filter {
	f.formats = append(f.formats, `"user" < %s`)
	f.values = append(f.values, v)
	return f
}

// UserLte user is less than or equal
func (f *Filter) UserLte(v string) *Filter {
	f.formats = append(f.formats, `"user" <= %s`)
	f.values = append(f.values, v)
	return f
}

// UserGt user is greater than
func (f *Filter) UserGt(v string) *Filter {
	f.formats = append(f.formats, `"user" > %s`)
	f.values = append(f.values, v)
	return f
}

// UserGte user is greater than or equal
func (f *Filter) UserGte(v string) *Filter {
	f.formats = append(f.formats, `"user" >= %s`)
	f.values = append(f.values, v)
	return f
}

// UserIn user is in
func (f *Filter) UserIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"user" IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// UserNotIn user is not in
func (f *Filter) UserNotIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"user" NOT IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// Intent intent equals
func (f *Filter) Intent(v string) *Filter {
	f.formats = append(f.formats, `"intent" = %s`)
	f.values = append(f.values, v)
	return f
}

// IntentNot intent doesn't equal
func (f *Filter) IntentNot(v string) *Filter {
	f.formats = append(f.formats, `"intent" != %s`)
	f.values = append(f.values, v)
	return f
}

// IntentContains intent contains
func (f *Filter) IntentContains(v string) *Filter {
	f.formats = append(f.formats, `"intent" LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// IntentNotContains intent doesn't contain
func (f *Filter) IntentNotContains(v string) *Filter {
	f.formats = append(f.formats, `"intent" NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// IntentStartsWith intent starts with
func (f *Filter) IntentStartsWith(v string) *Filter {
	f.formats = append(f.formats, `"intent" LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// IntentNotStartsWith intent doesn't start with
func (f *Filter) IntentNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `"intent" NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// IntentEndsWith intent ends with
func (f *Filter) IntentEndsWith(v string) *Filter {
	f.formats = append(f.formats, `"intent" LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// IntentNotEndsWith intent doesn't end with
func (f *Filter) IntentNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `"intent" NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// IntentLt intent is less than
func (f *Filter) IntentLt(v string) *Filter {
	f.formats = append(f.formats, `"intent" < %s`)
	f.values = append(f.values, v)
	return f
}

// IntentLte intent is less than or equal
func (f *Filter) IntentLte(v string) *Filter {
	f.formats = append(f.formats, `"intent" <= %s`)
	f.values = append(f.values, v)
	return f
}

// IntentGt intent is greater than
func (f *Filter) IntentGt(v string) *Filter {
	f.formats = append(f.formats, `"intent" > %s`)
	f.values = append(f.values, v)
	return f
}

// IntentGte intent is greater than or equal
func (f *Filter) IntentGte(v string) *Filter {
	f.formats = append(f.formats, `"intent" >= %s`)
	f.values = append(f.values, v)
	return f
}

// IntentIn intent is in
func (f *Filter) IntentIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"intent" IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// IntentNotIn intent is not in
func (f *Filter) IntentNotIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"intent" NOT IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// NullableIntent nullable intent equals
func (f *Filter) NullableIntent(v *string) *Filter {
	if v == nil {
		f.formats = append(f.formats, `"intent" IS NULL`)
		return f
	}
	f.formats = append(f.formats, `"intent" = %s`)
	f.values = append(f.values, v)
	return f
}

// NullableIntentNot nullable intent is not equal
func (f *Filter) NullableIntentNot(v *string) *Filter {
	if v == nil {
		f.formats = append(f.formats, `"intent" IS NOT NULL`)
		return f
	}
	f.formats = append(f.formats, `"intent" != %s`)
	f.values = append(f.values, v)
	return f
}

// Slot slot equals
func (f *Filter) Slot(v string) *Filter {
	f.formats = append(f.formats, `"slot" = %s`)
	f.values = append(f.values, v)
	return f
}

// SlotNot slot doesn't equal
func (f *Filter) SlotNot(v string) *Filter {
	f.formats = append(f.formats, `"slot" != %s`)
	f.values = append(f.values, v)
	return f
}

// SlotContains slot contains
func (f *Filter) SlotContains(v string) *Filter {
	f.formats = append(f.formats, `"slot" LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// SlotNotContains slot doesn't contain
func (f *Filter) SlotNotContains(v string) *Filter {
	f.formats = append(f.formats, `"slot" NOT LIKE '%%' || %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// SlotStartsWith slot starts with
func (f *Filter) SlotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `"slot" LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// SlotNotStartsWith slot doesn't start with
func (f *Filter) SlotNotStartsWith(v string) *Filter {
	f.formats = append(f.formats, `"slot" NOT LIKE %s || '%%'`)
	f.values = append(f.values, v)
	return f
}

// SlotEndsWith slot ends with
func (f *Filter) SlotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `"slot" LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// SlotNotEndsWith slot doesn't end with
func (f *Filter) SlotNotEndsWith(v string) *Filter {
	f.formats = append(f.formats, `"slot" NOT LIKE '%%' || %s`)
	f.values = append(f.values, v)
	return f
}

// SlotLt slot is less than
func (f *Filter) SlotLt(v string) *Filter {
	f.formats = append(f.formats, `"slot" < %s`)
	f.values = append(f.values, v)
	return f
}

// SlotLte slot is less than or equal
func (f *Filter) SlotLte(v string) *Filter {
	f.formats = append(f.formats, `"slot" <= %s`)
	f.values = append(f.values, v)
	return f
}

// SlotGt slot is greater than
func (f *Filter) SlotGt(v string) *Filter {
	f.formats = append(f.formats, `"slot" > %s`)
	f.values = append(f.values, v)
	return f
}

// SlotGte slot is greater than or equal
func (f *Filter) SlotGte(v string) *Filter {
	f.formats = append(f.formats, `"slot" >= %s`)
	f.values = append(f.values, v)
	return f
}

// SlotIn slot is in
func (f *Filter) SlotIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"slot" IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// SlotNotIn slot is not in
func (f *Filter) SlotNotIn(v ...string) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"slot" NOT IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// NullableSlot nullable slot equals
func (f *Filter) NullableSlot(v *string) *Filter {
	if v == nil {
		f.formats = append(f.formats, `"slot" IS NULL`)
		return f
	}
	f.formats = append(f.formats, `"slot" = %s`)
	f.values = append(f.values, v)
	return f
}

// NullableSlotNot nullable slot is not equal
func (f *Filter) NullableSlotNot(v *string) *Filter {
	if v == nil {
		f.formats = append(f.formats, `"slot" IS NOT NULL`)
		return f
	}
	f.formats = append(f.formats, `"slot" != %s`)
	f.values = append(f.values, v)
	return f
}

// TTL ttl equals
func (f *Filter) TTL(v int) *Filter {
	f.formats = append(f.formats, `"ttl" = %s`)
	f.values = append(f.values, v)
	return f
}

// TTLNot ttl doesn't equal
func (f *Filter) TTLNot(v int) *Filter {
	f.formats = append(f.formats, `"ttl" != %s`)
	f.values = append(f.values, v)
	return f
}

// TTLLt ttl is less than
func (f *Filter) TTLLt(v int) *Filter {
	f.formats = append(f.formats, `"ttl" < %s`)
	f.values = append(f.values, v)
	return f
}

// TTLLte ttl is less than or equal
func (f *Filter) TTLLte(v int) *Filter {
	f.formats = append(f.formats, `"ttl" <= %s`)
	f.values = append(f.values, v)
	return f
}

// TTLGt ttl is greater than
func (f *Filter) TTLGt(v int) *Filter {
	f.formats = append(f.formats, `"ttl" > %s`)
	f.values = append(f.values, v)
	return f
}

// TTLGte ttl is greater than or equal
func (f *Filter) TTLGte(v int) *Filter {
	f.formats = append(f.formats, `"ttl" >= %s`)
	f.values = append(f.values, v)
	return f
}

// TTLIn ttl is in
func (f *Filter) TTLIn(v ...int) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"ttl" IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// TTLNotIn ttl is not in
func (f *Filter) TTLNotIn(v ...int) *Filter {
	var rs []string
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"ttl" NOT IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// NullableTTL nullable ttl equals
func (f *Filter) NullableTTL(v *int) *Filter {
	if v == nil {
		f.formats = append(f.formats, `"ttl" IS NULL`)
		return f
	}
	f.formats = append(f.formats, `"ttl" = %s`)
	f.values = append(f.values, v)
	return f
}

// NullableTTLNot nullable ttl is not equal
func (f *Filter) NullableTTLNot(v *int) *Filter {
	if v == nil {
		f.formats = append(f.formats, `"ttl" IS NOT NULL`)
		return f
	}
	f.formats = append(f.formats, `"ttl" != %s`)
	f.values = append(f.values, v)
	return f
}

// OrderBy specificies the ORDERBy BY <order>
type OrderBy string

const (
	// ASC sorts by ascending order
	ASC OrderBy = "ASC"

	// DESC sorts by descending order
	DESC OrderBy = "DESC"
)

// NewOrder fn
func NewOrder() *Order {
	return &Order{}
}

var _ pogo.Condition = (*Order)(nil)

// Order orders the given fields
type Order struct {
	formats []string
}

// Clause fn
func (o *Order) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "ORDER BY",
		Format: strings.Join(o.formats, ", "),
	}
}

// User sorts `user` by an expression
func (o *Order) User(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"user" %s`, order))
	return o
}

// Intent sorts `intent` by an expression
func (o *Order) Intent(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"intent" %s`, order))
	return o
}

// Slot sorts `slot` by an expression
func (o *Order) Slot(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"slot" %s`, order))
	return o
}

// State sorts `state` by an expression
func (o *Order) State(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"state" %s`, order))
	return o
}

// TTL sorts `ttl` by an expression
func (o *Order) TTL(order OrderBy) *Order {
	o.formats = append(o.formats, fmt.Sprintf(`"ttl" %s`, order))
	return o
}

// Insert a "convos" into the "jack"."convos"
func Insert(db pogo.DB, convo *Input) (*Convo, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(convo.columns(), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
    INSERT INTO "jack"."convos" (` + strings.Join(_c, ", ") + `)
    VALUES (` + strings.Join(_i, ", ") + `)
    RETURNING "user", "intent", "slot", "state", "ttl"
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _convo Convo
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_convo.User, &_convo.Intent, &_convo.Slot, &_convo.State, &_convo.TTL); e != nil {
		return nil, e
	}

	return &_convo, nil
}

// InsertMany "convos" into the "jack"."convos"
func InsertMany(db pogo.DB, convos ...*Input) ([]*Convo, error) {
	_convos := []*Convo{}
	for _, convo := range convos {
		_convo, err := Insert(db, convo)
		if err != nil {
			return _convos, err
		}
		_convos = append(_convos, _convo)
	}
	return _convos, nil
}

// Find a `Convo` by some conditions.
func Find(db pogo.DB, conds ...pogo.Condition) (*Convo, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "user", "intent", "slot", "state", "ttl" ` +
		`FROM "jack"."convos" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _convo Convo
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_convo.User, &_convo.Intent, &_convo.Slot, &_convo.State, &_convo.TTL); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrConvoNotFound
		}
		return nil, e
	}

	return &_convo, nil
}

// FindByUser a `Convo` by some conditions.
func FindByUser(db pogo.DB, user string) (*Convo, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "user", "intent", "slot", "state", "ttl"
    FROM "jack"."convos"
    WHERE "user" = $1
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, &user)
	}

	var _convo Convo
	row := db.QueryRow(sqlstr, &user)
	if e := row.Scan(&_convo.User, &_convo.Intent, &_convo.Slot, &_convo.State, &_convo.TTL); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrConvoNotFound
		}
		return nil, e
	}

	return &_convo, nil
}

// FindMany finds many "jack"."convos" by a condition
func FindMany(db pogo.DB, conds ...pogo.Condition) ([]*Convo, error) {
	convos := []*Convo{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return convos, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "user", "intent", "slot", "state", "ttl" ` +
		`FROM "jack"."convos" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return convos, err
	}
	defer rows.Close()

	for rows.Next() {
		var _convo Convo
		if e := rows.Scan(&_convo.User, &_convo.Intent, &_convo.Slot, &_convo.State, &_convo.TTL); e != nil {
			if e == pgx.ErrNoRows {
				return convos, ErrConvoNotFound
			}
			return convos, err
		}
		convos = append(convos, &_convo)
	}
	if rows.Err() != nil {
		return convos, rows.Err()
	}

	return convos, nil
}

// Update "convos" rows in "jack"."convos" by a condition, returning 1 result
func Update(db pogo.DB, convo *Input, conds ...pogo.Condition) (*Convo, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	fields := convo.columns()

	// prepare the slices
	_c, _i, _v2 := slice(fields, len(_v))
	_v = append(_v, _v2...)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("convo.Update: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "jack"."convos" SET ` +
		strings.Join(_u, ", ") + ` ` +
		_s + ` ` +
		`RETURNING "user", "intent", "slot", "state", "ttl"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run the query
	var _convo Convo
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_convo.User, &_convo.Intent, &_convo.Slot, &_convo.State, &_convo.TTL); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrConvoNotFound
		}
		return nil, e
	}

	return &_convo, nil
}

// UpdateMany updates "convos" rows in "jack"."convos" by conditions, returning all results
func UpdateMany(db pogo.DB, convo *Input, conds ...pogo.Condition) ([]*Convo, error) {
	convos := []*Convo{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	fields := convo.columns()

	// prepare the slices
	_c, _i, _v2 := slice(fields, len(_v))
	_v = append(_v, _v2...)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("convo.UpdateMany: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "jack"."convos" SET ` +
		strings.Join(_u, ", ") + ` ` +
		_s + ` ` +
		`RETURNING "user", "intent", "slot", "state", "ttl"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return convos, err
	}
	defer rows.Close()

	for rows.Next() {
		var _convo Convo
		if e := rows.Scan(&_convo.User, &_convo.Intent, &_convo.Slot, &_convo.State, &_convo.TTL); e != nil {
			if e == pgx.ErrNoRows {
				return convos, ErrConvoNotFound
			}
			return convos, err
		}
		convos = append(convos, &_convo)
	}
	if rows.Err() != nil {
		return convos, rows.Err()
	}

	return convos, nil
}

// UpdateByUser a "convo" in "jack"."convos" by its "user"
func UpdateByUser(db pogo.DB, user string, convo *Input) (*Convo, error) {
	fields := convo.columns()

	// don't update the primary key
	delete(fields, "user")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("convo.UpdateByUser: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "jack"."convos" ` +
		`SET ` + strings.Join(_u, ", ") + ` ` +
		`WHERE "user" = $1 ` +
		`RETURNING "user", "intent", "slot", "state", "ttl"`

	// setup query
	values := append([]interface{}{&user}, _v...)

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, values...)
	}

	// run the query
	var _convo Convo
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&_convo.User, &_convo.Intent, &_convo.Slot, &_convo.State, &_convo.TTL); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrConvoNotFound
		}
		return nil, e
	}

	return &_convo, nil
}

// Delete `Convo`s by some conditions. Returns the first result.
func Delete(db pogo.DB, conds ...pogo.Condition) (*Convo, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql delete query
	sqlstr := `DELETE FROM "jack"."convos" ` +
		_s + ` ` +
		`RETURNING "user", "intent", "slot", "state", "ttl"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _convo Convo
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_convo.User, &_convo.Intent, &_convo.Slot, &_convo.State, &_convo.TTL); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrConvoNotFound
		}
		return nil, e
	}

	return &_convo, nil
}

// DeleteMany `Convo`s by some conditions, returning all results.
func DeleteMany(db pogo.DB, conds ...pogo.Condition) ([]*Convo, error) {
	convos := []*Convo{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return convos, err
	}

	// sql delete query
	sqlstr := `DELETE FROM "jack"."convos" ` +
		_s + ` ` +
		`RETURNING "user", "intent", "slot", "state", "ttl"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return convos, err
	}
	defer rows.Close()

	for rows.Next() {
		var _convo Convo
		if e := rows.Scan(&_convo.User, &_convo.Intent, &_convo.Slot, &_convo.State, &_convo.TTL); e != nil {
			if e == pgx.ErrNoRows {
				return convos, ErrConvoNotFound
			}
			return convos, err
		}
		convos = append(convos, &_convo)
	}
	if rows.Err() != nil {
		return convos, rows.Err()
	}

	return convos, nil
}

// DeleteByUser a "convo" from the "jack"."convos" table
func DeleteByUser(db pogo.DB, user string) (*Convo, error) {
	// sql delete query
	sqlstr := `DELETE FROM "jack"."convos" ` +
		`WHERE "user" = $1 ` +
		`RETURNING "user", "intent", "slot", "state", "ttl"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, user)
	}

	// run the query
	var _convo Convo
	row := db.QueryRow(sqlstr, user)
	if e := row.Scan(&_convo.User, &_convo.Intent, &_convo.Slot, &_convo.State, &_convo.TTL); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrConvoNotFound
		}
		return nil, e
	}

	return &_convo, nil
}

// UpsertByUser inserts a `convos`, updating the row if `User` already exists.
func UpsertByUser(db pogo.DB, user string, convo *Input) (*Convo, error) {
	// add values to input, overriding existing keys if present in the input
	convo = convo.User(user)

	fields := convo.columns()

	// prepare the slices
	_c, _i, _v := slice(fields, 0)

	// setup the update fields
	var _u []string
	for _, c := range _c {
		_u = append(_u, c+" = EXCLUDED."+c)
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("convo.UpsertByUser: no input provided")
	}

	// sql query
	sqlstr := `INSERT INTO "jack"."convos" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT (user) ` +
		`DO UPDATE SET ` + strings.Join(_u, ", ") + ` ` +
		`RETURNING "user", "intent", "slot", "state", "ttl"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run query
	var _convo Convo
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_convo.User, &_convo.Intent, &_convo.Slot, &_convo.State, &_convo.TTL); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &_convo, nil
}

// slice converts our columns into something the sql driver can understand
func slice(columns map[string]interface{}, offset int) (c []string, i []string, v []interface{}) {
	n := offset + 1
	for col, val := range columns {
		c = append(c, `"`+col+`"`)
		i = append(i, "$"+strconv.Itoa(n))
		v = append(v, val)
		n++
	}
	return c, i, v
}

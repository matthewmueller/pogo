package teammates

import (
	"encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/digby/pogo"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrTeammateNotFound returned if the teammates is not found
var ErrTeammateNotFound = errors.New("teammates not found")

// TeammateInput model for "jack"."teammates"
type TeammateInput struct {
	id        *string
	slackID   *string
	username  *string
	firstName *string
	lastName  *string
	email     *string
	avatar    *string
	timezone  *string
	createdAt *time.Time
	updatedAt *time.Time
}

// Teammate model for "jack"."teammates"
type Teammate struct {
	ID        string
	SlackID   string
	Username  string
	FirstName *string
	LastName  *string
	Email     *string
	Avatar    *string
	Timezone  string
	CreatedAt *time.Time
	UpdatedAt *time.Time
}

// New "jack"."teammates" API
func New() *TeammateInput {
	return &TeammateInput{}
}

// ID sets the "id"
func (teammate *TeammateInput) ID(id string) *TeammateInput {
	teammate.id = &id
	return teammate
}

// SlackID sets the "slackID"
func (teammate *TeammateInput) SlackID(slackID string) *TeammateInput {
	teammate.slackID = &slackID
	return teammate
}

// Username sets the "username"
func (teammate *TeammateInput) Username(username string) *TeammateInput {
	teammate.username = &username
	return teammate
}

// FirstName sets the "firstName"
func (teammate *TeammateInput) FirstName(firstName string) *TeammateInput {
	teammate.firstName = &firstName
	return teammate
}

// LastName sets the "lastName"
func (teammate *TeammateInput) LastName(lastName string) *TeammateInput {
	teammate.lastName = &lastName
	return teammate
}

// Email sets the "email"
func (teammate *TeammateInput) Email(email string) *TeammateInput {
	teammate.email = &email
	return teammate
}

// Avatar sets the "avatar"
func (teammate *TeammateInput) Avatar(avatar string) *TeammateInput {
	teammate.avatar = &avatar
	return teammate
}

// Timezone sets the "timezone"
func (teammate *TeammateInput) Timezone(timezone string) *TeammateInput {
	teammate.timezone = &timezone
	return teammate
}

// CreatedAt sets the "createdAt"
func (teammate *TeammateInput) CreatedAt(createdAt time.Time) *TeammateInput {
	teammate.createdAt = &createdAt
	return teammate
}

// UpdatedAt sets the "updatedAt"
func (teammate *TeammateInput) UpdatedAt(updatedAt time.Time) *TeammateInput {
	teammate.updatedAt = &updatedAt
	return teammate
}

// MarshalJSON marshals the "teammate" into JSON
func (teammate *TeammateInput) MarshalJSON() ([]byte, error) {
	return json.Marshal(teammate)
}

// UnmarshalJSON unmarshals json to a "teammate"
func (teammate *TeammateInput) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, teammate)
}

func (teammate *TeammateInput) String() string {
	return "teammate"
}

func getColumns(teammate *TeammateInput) map[string]interface{} {
	columns := make(map[string]interface{})

	if teammate.id != nil {
		columns["id"] = *teammate.id
	}

	if teammate.slackID != nil {
		columns["slack_id"] = *teammate.slackID
	}

	if teammate.username != nil {
		columns["username"] = *teammate.username
	}

	if teammate.firstName != nil {
		columns["first_name"] = *teammate.firstName
	}

	if teammate.lastName != nil {
		columns["last_name"] = *teammate.lastName
	}

	if teammate.email != nil {
		columns["email"] = *teammate.email
	}

	if teammate.avatar != nil {
		columns["avatar"] = *teammate.avatar
	}

	if teammate.timezone != nil {
		columns["timezone"] = *teammate.timezone
	}

	if teammate.createdAt != nil {
		columns["created_at"] = *teammate.createdAt
	}

	if teammate.updatedAt != nil {
		columns["updated_at"] = *teammate.updatedAt
	}

	return columns
}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
	condition string
	params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
	return &WhereClause{
		condition: condition,
		params:    params,
	}
}

// Insert a "teammate" into the "jack"."teammates"
func Insert(db jack.DB, teammateInput *TeammateInput) (*Teammate, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := jack.Slice(getColumns(teammateInput), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
    INSERT INTO "jack"."teammates" (` + strings.Join(_c, ", ") + `)
    VALUES (` + strings.Join(_i, ", ") + `)
    RETURNING "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"
  `
	jack.Log(sqlstr, _v...)

	var teammate Teammate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil {
		return nil, e
	}

	return &teammate, nil
}

// Find a "Teammate" by "id"
func Find(db pogo.DB, id string) (*Teammate, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"
    FROM "jack"."teammates"
    WHERE "id" = $1
  `
	pogo.Log(sqlstr, &id)

	var teammate Teammate
	row := db.QueryRow(sqlstr, &id)
	if e := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, e
	}

	return &teammate, nil
}

// FindByID find a teammate by id
func FindByID(db jack.DB, id string) (*Teammate, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"
    FROM "jack"."teammates"
    WHERE "id" = $1
  `
	jack.Log(sqlstr, id)

	var teammate Teammate
	row := db.QueryRow(sqlstr, id)
	err := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, err
	}

	return &teammate, nil
}

// FindBySlackID find a teammate by slack_id
func FindBySlackID(db jack.DB, slackID string) (*Teammate, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"
    FROM "jack"."teammates"
    WHERE "slack_id" = $1
  `
	jack.Log(sqlstr, slackID)

	var teammate Teammate
	row := db.QueryRow(sqlstr, slackID)
	err := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, err
	}

	return &teammate, nil
}

// FindOne find one teammate by a condition
func FindOne(db jack.DB, where *WhereClause) (*Teammate, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
  SELECT "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"
  FROM "jack"."teammates"
  WHERE ` + where.condition
	jack.Log(sqlstr, where.params...)

	var teammate Teammate
	row := db.QueryRow(sqlstr, where.params...)
	if e := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, e
	}

	return &teammate, nil
}

// FindMany find many "teammate"'s by a given condition
func FindMany(db jack.DB, where *WhereClause) (teammates []*Teammate, err error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
  SELECT "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"
  FROM "jack"."teammates"
  WHERE ` + where.condition
	jack.Log(sqlstr, where.params...)

	rows, err := db.Query(sqlstr, where.params...)
	if err != nil {
		return teammates, err
	}
	defer rows.Close()

	for rows.Next() {
		var teammate Teammate
		if e := rows.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return teammates, ErrTeammateNotFound
			}
			return teammates, err
		}
		teammates = append(teammates, &teammate)
	}
	if rows.Err() != nil {
		return teammates, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	// if len(teammates) == 0 {
	// 	return make([]*Teammate, 0), nil
	// }

	return teammates, nil
}

// Update a "teammate" in "jack"."teammates" by its "id"
func Update(db jack.DB, id string, teammateInput *TeammateInput) (*Teammate, error) {
	fields := getColumns(teammateInput)

	// don't update the primary key
	delete(fields, "id")

	// prepare the slices
	_c, _i, _v := jack.Slice(fields, 1)

	// sql query
	sqlstr := `UPDATE "jack"."teammates" SET (` +
		strings.Join(_c, ", ") +
		`) = (` +
		strings.Join(_i, ", ") +
		`)
    WHERE "id" = $1
    RETURNING "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"`

	// setup query
	values := append([]interface{}{&id}, _v...)
	jack.Log(sqlstr, values...)

	// run the query
	var teammate Teammate
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, e
	}

	return &teammate, nil
}

// UpdateBySlackID find a Teammate
func UpdateBySlackID(db jack.DB, slackID string, teammateInput *TeammateInput) (*Teammate, error) {
	fields := getColumns(teammateInput)

	// don't update the keys
	delete(fields, "slack_id")

	// prepare the slices
	_c, _i, _v := jack.Slice(fields, 1)

	// sql query
	sqlstr := `UPDATE "jack"."teammates" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE "slack_id" = $1 ` +
		`RETURNING "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, slackID)
	values = append(values, _v...)
	jack.Log(sqlstr, values...)

	// run the query
	var teammate Teammate
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeammateNotFound
		}
		return nil, e
	}

	return &teammate, nil
}

// UpdateMany rows in "jack"."teammates" by a given condition
func UpdateMany(db jack.DB, where *WhereClause, teammateInput *TeammateInput) (teammates []*Teammate, err error) {
	// prepare the slices
	_c, _i, _v := jack.Slice(getColumns(teammateInput), len(where.params))

	// sql query
	sqlstr := `UPDATE "jack"."teammates" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE ` + where.condition + ` ` +
		`RETURNING "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, where.params...)
	values = append(values, _v...)
	jack.Log(sqlstr, values...)

	// run query
	rows, err := db.Query(sqlstr, values...)
	if err != nil {
		return teammates, err
	}
	defer rows.Close()

	for rows.Next() {
		var teammate Teammate
		if e := rows.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return teammates, ErrTeammateNotFound
			}
			return teammates, err
		}
		teammates = append(teammates, &teammate)
	}
	if rows.Err() != nil {
		return teammates, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	// if len(teammates) == 0 {
	// 	return make([]*Teammate, 0), nil
	// }

	return teammates, nil
}

// Delete a "teammate" from the "jack"."teammates" table
func Delete(db jack.DB, id string) error {
	// sql query
	sqlstr := `DELETE FROM "jack"."teammates" WHERE "id" = $1`
	jack.Log(sqlstr, id)

	// run query
	if _, e := db.Exec(sqlstr, id); e != nil {
		if e == pgx.ErrNoRows {
			return ErrTeammateNotFound
		}
		return e
	}

	return nil
}

// DeleteBySlackID deletes a "teammate"
func DeleteBySlackID(db jack.DB, slackID string) error {
	// sql delete query
	sqlstr := `DELETE FROM "jack"."teammates" WHERE "slack_id" = $1`
	jack.Log(sqlstr, slackID)

	if _, e := db.Exec(sqlstr, slackID); e != nil {
		if e == pgx.ErrNoRows {
			return ErrTeammateNotFound
		}
		return e
	}

	return nil
}

// DeleteMany delete many "teammate"'s by the given condition
func DeleteMany(db jack.DB, where *WhereClause) error {
	// sql select query, primary key provided by sequence
	sqlstr := `DELETE FROM "jack"."teammates" WHERE ` + where.condition
	jack.Log(sqlstr, where.params...)

	if _, e := db.Exec(sqlstr, where.params...); e != nil {
		return e
	}

	return nil
}

// Upsert the "teammate" by its "id".
func Upsert(db jack.DB, teammateInput *TeammateInput) (*Teammate, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := jack.Slice(getColumns(teammateInput), 0)

	// sql query
	sqlstr := `INSERT INTO "jack"."teammates" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"`
	jack.Log(sqlstr, _v...)

	// run query
	var teammate Teammate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil {
		return nil, e
	}

	return &teammate, nil
}

// UpsertBySlackID find a "Teammate"
func UpsertBySlackID(db jack.DB, teammateInput *TeammateInput) (*Teammate, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := jack.Slice(getColumns(teammateInput), 0)

	// sql query
	sqlstr := `INSERT INTO "jack"."teammates" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT (slack_id) ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "id", "slack_id", "username", "first_name", "last_name", "email", "avatar", "timezone", "created_at", "updated_at"`
	jack.Log(sqlstr, _v...)

	// run query
	var teammate Teammate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&teammate.ID, &teammate.SlackID, &teammate.Username, &teammate.FirstName, &teammate.LastName, &teammate.Email, &teammate.Avatar, &teammate.Timezone, &teammate.CreatedAt, &teammate.UpdatedAt); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &teammate, nil
}

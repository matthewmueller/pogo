package report

import (
	"context"
	"encoding/json"
	"errors"
	"strconv"
	"strings"
	"time"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/jack/pogo/enum"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrReportNotFound returned if the reports is not found
var ErrReportNotFound = errors.New("reports not found")

// Report result data for "jack"."reports"
type Report struct {
	ID        string
	UserID    string
	Timestamp time.Time
	Questions json.RawMessage
	StandupID string
	Status    enum.ReportStatus
	CreatedAt *time.Time
	UpdatedAt *time.Time
}

// New input builder for "jack"."reports".
func New() *Input {
	return &Input{}
}

// Input data for "jack"."reports"
type Input struct {
	id        *string
	userID    *string
	timestamp *time.Time
	questions *json.RawMessage
	standupID *string
	status    *enum.ReportStatus
	createdAt *time.Time
	updatedAt *time.Time
}

// ID sets the "id"
func (report *Input) ID(id string) *Input {
	report.id = &id
	return report
}

// UserID sets the "userID"
func (report *Input) UserID(userID string) *Input {
	report.userID = &userID
	return report
}

// Timestamp sets the "timestamp"
func (report *Input) Timestamp(timestamp time.Time) *Input {
	report.timestamp = &timestamp
	return report
}

// Questions sets the "questions"
func (report *Input) Questions(questions json.RawMessage) *Input {
	report.questions = &questions
	return report
}

// StandupID sets the "standupID"
func (report *Input) StandupID(standupID string) *Input {
	report.standupID = &standupID
	return report
}

// Status sets the "status"
func (report *Input) Status(status enum.ReportStatus) *Input {
	report.status = &status
	return report
}

// CreatedAt sets the "createdAt"
func (report *Input) CreatedAt(createdAt time.Time) *Input {
	report.createdAt = &createdAt
	return report
}

// UpdatedAt sets the "updatedAt"
func (report *Input) UpdatedAt(updatedAt time.Time) *Input {
	report.updatedAt = &updatedAt
	return report
}

// MarshalJSON marshals the "report" into JSON
func (report *Input) MarshalJSON() ([]byte, error) {
	return json.Marshal(report)
}

// UnmarshalJSON unmarshals json to a "report"
func (report *Input) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, report)
}

func (report *Input) String() string {
	return "report"
}

func columns(report *Input) map[string]interface{} {
	columns := make(map[string]interface{})

	if report.id != nil {
		columns["id"] = *report.id
	}

	if report.userID != nil {
		columns["user_id"] = *report.userID
	}

	if report.timestamp != nil {
		columns["timestamp"] = *report.timestamp
	}

	if report.questions != nil {
		columns["questions"] = *report.questions
	}

	if report.standupID != nil {
		columns["standup_id"] = *report.standupID
	}

	if report.status != nil {
		columns["status"] = *report.status
	}

	if report.createdAt != nil {
		columns["created_at"] = *report.createdAt
	}

	if report.updatedAt != nil {
		columns["updated_at"] = *report.updatedAt
	}

	return columns
}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
	condition string
	params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
	return &WhereClause{
		condition: condition,
		params:    params,
	}
}

// DB is the common interface for database operations that can be used with
// types from schema `jack`.
//
// This should work with database/sql.DB and database/sql.Tx.
type DB interface {
	Exec(string, ...interface{}) (pgx.CommandTag, error)
	Query(string, ...interface{}) (*pgx.Rows, error)
	QueryRow(string, ...interface{}) *pgx.Row
}

// Model for Report
type Model struct {
	DB  DB
	Log func(string, ...interface{})
}

// Insert a "report" into the "jack"."reports"
func (m *Model) Insert(ctx context.Context, reportInput *Input) (*Report, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(columns(reportInput), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
    INSERT INTO "jack"."reports" (` + strings.Join(_c, ", ") + `)
    VALUES (` + strings.Join(_i, ", ") + `)
    RETURNING "id", "user_id", "timestamp", "questions", "standup_id", "status", "created_at", "updated_at"
  `

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, _v...)
	}

	var report Report
	row := m.DB.QueryRow(sqlstr, _v...)
	if e := row.Scan(&report.ID, &report.UserID, &report.Timestamp, &report.Questions, &report.StandupID, &report.Status, &report.CreatedAt, &report.UpdatedAt); e != nil {
		return nil, e
	}

	return &report, nil
}

// Find a `Report` by it's primary key `id`
func (m *Model) Find(ctx context.Context, id string) (*Report, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "user_id", "timestamp", "questions", "standup_id", "status", "created_at", "updated_at"
    FROM "jack"."reports"
    WHERE "id" = $1
  `

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, &id)
	}

	var report Report
	row := m.DB.QueryRow(sqlstr, &id)
	if e := row.Scan(&report.ID, &report.UserID, &report.Timestamp, &report.Questions, &report.StandupID, &report.Status, &report.CreatedAt, &report.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrReportNotFound
		}
		return nil, e
	}

	return &report, nil
}

// FindOne find one report by a condition
func (m *Model) FindOne(ctx context.Context, where *WhereClause) (*Report, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
  SELECT "id", "user_id", "timestamp", "questions", "standup_id", "status", "created_at", "updated_at"
  FROM "jack"."reports"
  WHERE ` + where.condition

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, where.params...)
	}

	var report Report
	row := m.DB.QueryRow(sqlstr, where.params...)
	if e := row.Scan(&report.ID, &report.UserID, &report.Timestamp, &report.Questions, &report.StandupID, &report.Status, &report.CreatedAt, &report.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrReportNotFound
		}
		return nil, e
	}

	return &report, nil
}

// FindWhere find many "report"'s by a given condition
func (m *Model) FindWhere(ctx context.Context, where *WhereClause) ([]*Report, error) {
	reports := []*Report{}

	// sql select query, primary key provided by sequence
	sqlstr := `
  SELECT "id", "user_id", "timestamp", "questions", "standup_id", "status", "created_at", "updated_at"
  FROM "jack"."reports"
  WHERE ` + where.condition

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, where.params...)
	}

	rows, err := m.DB.Query(sqlstr, where.params...)
	if err != nil {
		return reports, err
	}
	defer rows.Close()

	for rows.Next() {
		var report Report
		if e := rows.Scan(&report.ID, &report.UserID, &report.Timestamp, &report.Questions, &report.StandupID, &report.Status, &report.CreatedAt, &report.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return reports, ErrReportNotFound
			}
			return reports, err
		}
		reports = append(reports, &report)
	}
	if rows.Err() != nil {
		return reports, rows.Err()
	}

	return reports, nil
}

// FindAll find all "report"'s
func (m *Model) FindAll(ctx context.Context) ([]*Report, error) {
	reports := []*Report{}

	// sql select query, primary key provided by sequence
	sqlstr := `
  SELECT "id", "user_id", "timestamp", "questions", "standup_id", "status", "created_at", "updated_at"
  FROM "jack"."reports"`

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr)
	}

	rows, err := m.DB.Query(sqlstr)
	if err != nil {
		return reports, err
	}
	defer rows.Close()

	for rows.Next() {
		var report Report
		if e := rows.Scan(&report.ID, &report.UserID, &report.Timestamp, &report.Questions, &report.StandupID, &report.Status, &report.CreatedAt, &report.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return reports, ErrReportNotFound
			}
			return reports, err
		}
		reports = append(reports, &report)
	}
	if rows.Err() != nil {
		return reports, rows.Err()
	}

	return reports, nil
}

// Update a "report" in "jack"."reports" by its "id"
func (m *Model) Update(ctx context.Context, id string, reportInput *Input) (*Report, error) {
	fields := columns(reportInput)

	// don't update the primary key
	delete(fields, "id")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// sql query
	sqlstr := `UPDATE "jack"."reports" SET (` +
		strings.Join(_c, ", ") +
		`) = (` +
		strings.Join(_i, ", ") +
		`)
    WHERE "id" = $1
    RETURNING "id", "user_id", "timestamp", "questions", "standup_id", "status", "created_at", "updated_at"`

	// setup query
	values := append([]interface{}{&id}, _v...)

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, values...)
	}

	// run the query
	var report Report
	row := m.DB.QueryRow(sqlstr, values...)
	if e := row.Scan(&report.ID, &report.UserID, &report.Timestamp, &report.Questions, &report.StandupID, &report.Status, &report.CreatedAt, &report.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrReportNotFound
		}
		return nil, e
	}

	return &report, nil
}

// UpdateWhere rows in "jack"."reports" by a given condition
func (m *Model) UpdateWhere(ctx context.Context, where *WhereClause, reportInput *Input) ([]*Report, error) {
	reports := []*Report{}

	// prepare the slices
	_c, _i, _v := slice(columns(reportInput), len(where.params))

	// sql query
	sqlstr := `UPDATE "jack"."reports" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE ` + where.condition + ` ` +
		`RETURNING "id", "user_id", "timestamp", "questions", "standup_id", "status", "created_at", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, where.params...)
	values = append(values, _v...)

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, values...)
	}

	// run query
	rows, err := m.DB.Query(sqlstr, values...)
	if err != nil {
		return reports, err
	}
	defer rows.Close()

	for rows.Next() {
		var report Report
		if e := rows.Scan(&report.ID, &report.UserID, &report.Timestamp, &report.Questions, &report.StandupID, &report.Status, &report.CreatedAt, &report.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return reports, ErrReportNotFound
			}
			return reports, err
		}
		reports = append(reports, &report)
	}
	if rows.Err() != nil {
		return reports, rows.Err()
	}

	return reports, nil
}

// Delete a "report" from the "jack"."reports" table
func (m *Model) Delete(ctx context.Context, id string) error {
	// sql query
	sqlstr := `DELETE FROM "jack"."reports" WHERE "id" = $1`

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, id)
	}

	// run query
	if _, e := m.DB.Exec(sqlstr, id); e != nil {
		if e == pgx.ErrNoRows {
			return ErrReportNotFound
		}
		return e
	}

	return nil
}

// DeleteWhere delete many "report"'s by the given condition
func (m *Model) DeleteWhere(ctx context.Context, where *WhereClause) error {
	// sql select query, primary key provided by sequence
	sqlstr := `DELETE FROM "jack"."reports" WHERE ` + where.condition

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, where.params...)
	}

	if _, e := m.DB.Exec(sqlstr, where.params...); e != nil {
		return e
	}

	return nil
}

// Upsert the "report" by its "id".
func (m *Model) Upsert(ctx context.Context, reportInput *Input) (*Report, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(columns(reportInput), 0)

	// sql query
	sqlstr := `INSERT INTO "jack"."reports" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "id", "user_id", "timestamp", "questions", "standup_id", "status", "created_at", "updated_at"`

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, _v...)
	}

	// run query
	var report Report
	row := m.DB.QueryRow(sqlstr, _v...)
	if e := row.Scan(&report.ID, &report.UserID, &report.Timestamp, &report.Questions, &report.StandupID, &report.Status, &report.CreatedAt, &report.UpdatedAt); e != nil {
		return nil, e
	}

	return &report, nil
}

// slice converts our columns into something the sql driver can understand
func slice(columns map[string]interface{}, offset int) (c []string, i []string, v []interface{}) {
	n := offset + 1
	for col, val := range columns {
		c = append(c, `"`+col+`"`)
		i = append(i, "$"+strconv.Itoa(n))
		v = append(v, val)
		n++
	}
	return c, i, v
}

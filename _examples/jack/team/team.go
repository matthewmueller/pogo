package team

import (
	"context"
	"encoding/json"
	"errors"
	"strconv"
	"strings"
	"time"

	"github.com/jackc/pgx"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrTeamNotFound returned if the teams is not found
var ErrTeamNotFound = errors.New("teams not found")

// Team result data for "jack"."teams"
type Team struct {
	ID                   string
	SlackTeamID          string
	SlackTeamAccessToken string
	SlackBotAccessToken  string
	SlackBotID           string
	TeamName             string
	Scope                []string
	Email                *string
	StripeID             *string
	Active               bool
	FreeTeammates        int
	CostPerUser          int
	TrialEnds            time.Time
	CreatedAt            *time.Time
	UpdatedAt            *time.Time
}

// New input builder for "jack"."teams".
func New() *Input {
	return &Input{}
}

// Input data for "jack"."teams"
type Input struct {
	id                   *string
	slackTeamID          *string
	slackTeamAccessToken *string
	slackBotAccessToken  *string
	slackBotID           *string
	teamName             *string
	scope                *[]string
	email                *string
	stripeID             *string
	active               *bool
	freeTeammates        *int
	costPerUser          *int
	trialEnds            *time.Time
	createdAt            *time.Time
	updatedAt            *time.Time
}

// ID sets the "id"
func (team *Input) ID(id string) *Input {
	team.id = &id
	return team
}

// SlackTeamID sets the "slackTeamID"
func (team *Input) SlackTeamID(slackTeamID string) *Input {
	team.slackTeamID = &slackTeamID
	return team
}

// SlackTeamAccessToken sets the "slackTeamAccessToken"
func (team *Input) SlackTeamAccessToken(slackTeamAccessToken string) *Input {
	team.slackTeamAccessToken = &slackTeamAccessToken
	return team
}

// SlackBotAccessToken sets the "slackBotAccessToken"
func (team *Input) SlackBotAccessToken(slackBotAccessToken string) *Input {
	team.slackBotAccessToken = &slackBotAccessToken
	return team
}

// SlackBotID sets the "slackBotID"
func (team *Input) SlackBotID(slackBotID string) *Input {
	team.slackBotID = &slackBotID
	return team
}

// TeamName sets the "teamName"
func (team *Input) TeamName(teamName string) *Input {
	team.teamName = &teamName
	return team
}

// Scope sets the "scope"
func (team *Input) Scope(scope []string) *Input {
	team.scope = &scope
	return team
}

// Email sets the "email"
func (team *Input) Email(email string) *Input {
	team.email = &email
	return team
}

// StripeID sets the "stripeID"
func (team *Input) StripeID(stripeID string) *Input {
	team.stripeID = &stripeID
	return team
}

// Active sets the "active"
func (team *Input) Active(active bool) *Input {
	team.active = &active
	return team
}

// FreeTeammates sets the "freeTeammates"
func (team *Input) FreeTeammates(freeTeammates int) *Input {
	team.freeTeammates = &freeTeammates
	return team
}

// CostPerUser sets the "costPerUser"
func (team *Input) CostPerUser(costPerUser int) *Input {
	team.costPerUser = &costPerUser
	return team
}

// TrialEnds sets the "trialEnds"
func (team *Input) TrialEnds(trialEnds time.Time) *Input {
	team.trialEnds = &trialEnds
	return team
}

// CreatedAt sets the "createdAt"
func (team *Input) CreatedAt(createdAt time.Time) *Input {
	team.createdAt = &createdAt
	return team
}

// UpdatedAt sets the "updatedAt"
func (team *Input) UpdatedAt(updatedAt time.Time) *Input {
	team.updatedAt = &updatedAt
	return team
}

// MarshalJSON marshals the "team" into JSON
func (team *Input) MarshalJSON() ([]byte, error) {
	return json.Marshal(team)
}

// UnmarshalJSON unmarshals json to a "team"
func (team *Input) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, team)
}

func (team *Input) String() string {
	return "team"
}

func columns(team *Input) map[string]interface{} {
	columns := make(map[string]interface{})

	if team.id != nil {
		columns["id"] = *team.id
	}

	if team.slackTeamID != nil {
		columns["slack_team_id"] = *team.slackTeamID
	}

	if team.slackTeamAccessToken != nil {
		columns["slack_team_access_token"] = *team.slackTeamAccessToken
	}

	if team.slackBotAccessToken != nil {
		columns["slack_bot_access_token"] = *team.slackBotAccessToken
	}

	if team.slackBotID != nil {
		columns["slack_bot_id"] = *team.slackBotID
	}

	if team.teamName != nil {
		columns["team_name"] = *team.teamName
	}

	if team.scope != nil {
		columns["scope"] = *team.scope
	}

	if team.email != nil {
		columns["email"] = *team.email
	}

	if team.stripeID != nil {
		columns["stripe_id"] = *team.stripeID
	}

	if team.active != nil {
		columns["active"] = *team.active
	}

	if team.freeTeammates != nil {
		columns["free_teammates"] = *team.freeTeammates
	}

	if team.costPerUser != nil {
		columns["cost_per_user"] = *team.costPerUser
	}

	if team.trialEnds != nil {
		columns["trial_ends"] = *team.trialEnds
	}

	if team.createdAt != nil {
		columns["created_at"] = *team.createdAt
	}

	if team.updatedAt != nil {
		columns["updated_at"] = *team.updatedAt
	}

	return columns
}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
	condition string
	params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
	return &WhereClause{
		condition: condition,
		params:    params,
	}
}

// DB is the common interface for database operations that can be used with
// types from schema `jack`.
//
// This should work with database/sql.DB and database/sql.Tx.
type DB interface {
	Exec(string, ...interface{}) (pgx.CommandTag, error)
	Query(string, ...interface{}) (*pgx.Rows, error)
	QueryRow(string, ...interface{}) *pgx.Row
}

// Model for Team
type Model struct {
	DB  DB
	Log func(string, ...interface{})
}

// Insert a "team" into the "jack"."teams"
func (m *Model) Insert(ctx context.Context, teamInput *Input) (*Team, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(columns(teamInput), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
    INSERT INTO "jack"."teams" (` + strings.Join(_c, ", ") + `)
    VALUES (` + strings.Join(_i, ", ") + `)
    RETURNING "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"
  `

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, _v...)
	}

	var team Team
	row := m.DB.QueryRow(sqlstr, _v...)
	if e := row.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt); e != nil {
		return nil, e
	}

	return &team, nil
}

// Find a `Team` by it's primary key `id`
func (m *Model) Find(ctx context.Context, id string) (*Team, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"
    FROM "jack"."teams"
    WHERE "id" = $1
  `

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, &id)
	}

	var team Team
	row := m.DB.QueryRow(sqlstr, &id)
	if e := row.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeamNotFound
		}
		return nil, e
	}

	return &team, nil
}

// FindBySlackBotAccessToken find a team by slack_bot_access_token
func (m *Model) FindBySlackBotAccessToken(ctx context.Context, slackBotAccessToken string) (*Team, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"
    FROM "jack"."teams"
    WHERE "slack_bot_access_token" = $1
  `

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, slackBotAccessToken)
	}

	var team Team
	row := m.DB.QueryRow(sqlstr, slackBotAccessToken)
	err := row.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, ErrTeamNotFound
		}
		return nil, err
	}

	return &team, nil
}

// FindBySlackTeamAccessToken find a team by slack_team_access_token
func (m *Model) FindBySlackTeamAccessToken(ctx context.Context, slackTeamAccessToken string) (*Team, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"
    FROM "jack"."teams"
    WHERE "slack_team_access_token" = $1
  `

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, slackTeamAccessToken)
	}

	var team Team
	row := m.DB.QueryRow(sqlstr, slackTeamAccessToken)
	err := row.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, ErrTeamNotFound
		}
		return nil, err
	}

	return &team, nil
}

// FindBySlackTeamID find a team by slack_team_id
func (m *Model) FindBySlackTeamID(ctx context.Context, slackTeamID string) (*Team, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"
    FROM "jack"."teams"
    WHERE "slack_team_id" = $1
  `

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, slackTeamID)
	}

	var team Team
	row := m.DB.QueryRow(sqlstr, slackTeamID)
	err := row.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, ErrTeamNotFound
		}
		return nil, err
	}

	return &team, nil
}

// FindOne find one team by a condition
func (m *Model) FindOne(ctx context.Context, where *WhereClause) (*Team, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
  SELECT "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"
  FROM "jack"."teams"
  WHERE ` + where.condition

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, where.params...)
	}

	var team Team
	row := m.DB.QueryRow(sqlstr, where.params...)
	if e := row.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeamNotFound
		}
		return nil, e
	}

	return &team, nil
}

// FindWhere find many "team"'s by a given condition
func (m *Model) FindWhere(ctx context.Context, where *WhereClause) ([]*Team, error) {
	teams := []*Team{}

	// sql select query, primary key provided by sequence
	sqlstr := `
  SELECT "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"
  FROM "jack"."teams"
  WHERE ` + where.condition

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, where.params...)
	}

	rows, err := m.DB.Query(sqlstr, where.params...)
	if err != nil {
		return teams, err
	}
	defer rows.Close()

	for rows.Next() {
		var team Team
		if e := rows.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return teams, ErrTeamNotFound
			}
			return teams, err
		}
		teams = append(teams, &team)
	}
	if rows.Err() != nil {
		return teams, rows.Err()
	}

	return teams, nil
}

// FindAll find all "team"'s
func (m *Model) FindAll(ctx context.Context) ([]*Team, error) {
	teams := []*Team{}

	// sql select query, primary key provided by sequence
	sqlstr := `
  SELECT "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"
  FROM "jack"."teams"`

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr)
	}

	rows, err := m.DB.Query(sqlstr)
	if err != nil {
		return teams, err
	}
	defer rows.Close()

	for rows.Next() {
		var team Team
		if e := rows.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return teams, ErrTeamNotFound
			}
			return teams, err
		}
		teams = append(teams, &team)
	}
	if rows.Err() != nil {
		return teams, rows.Err()
	}

	return teams, nil
}

// Update a "team" in "jack"."teams" by its "id"
func (m *Model) Update(ctx context.Context, id string, teamInput *Input) (*Team, error) {
	fields := columns(teamInput)

	// don't update the primary key
	delete(fields, "id")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// sql query
	sqlstr := `UPDATE "jack"."teams" SET (` +
		strings.Join(_c, ", ") +
		`) = (` +
		strings.Join(_i, ", ") +
		`)
    WHERE "id" = $1
    RETURNING "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"`

	// setup query
	values := append([]interface{}{&id}, _v...)

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, values...)
	}

	// run the query
	var team Team
	row := m.DB.QueryRow(sqlstr, values...)
	if e := row.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeamNotFound
		}
		return nil, e
	}

	return &team, nil
}

// UpdateBySlackBotAccessToken find a Team
func (m *Model) UpdateBySlackBotAccessToken(ctx context.Context, slackBotAccessToken string, teamInput *Input) (*Team, error) {
	fields := columns(teamInput)

	// don't update the keys
	delete(fields, "slack_bot_access_token")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// sql query
	sqlstr := `UPDATE "jack"."teams" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE "slack_bot_access_token" = $1 ` +
		`RETURNING "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, slackBotAccessToken)
	values = append(values, _v...)

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, values...)
	}

	// run the query
	var team Team
	row := m.DB.QueryRow(sqlstr, values...)
	if e := row.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeamNotFound
		}
		return nil, e
	}

	return &team, nil
}

// UpdateBySlackTeamAccessToken find a Team
func (m *Model) UpdateBySlackTeamAccessToken(ctx context.Context, slackTeamAccessToken string, teamInput *Input) (*Team, error) {
	fields := columns(teamInput)

	// don't update the keys
	delete(fields, "slack_team_access_token")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// sql query
	sqlstr := `UPDATE "jack"."teams" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE "slack_team_access_token" = $1 ` +
		`RETURNING "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, slackTeamAccessToken)
	values = append(values, _v...)

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, values...)
	}

	// run the query
	var team Team
	row := m.DB.QueryRow(sqlstr, values...)
	if e := row.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeamNotFound
		}
		return nil, e
	}

	return &team, nil
}

// UpdateBySlackTeamID find a Team
func (m *Model) UpdateBySlackTeamID(ctx context.Context, slackTeamID string, teamInput *Input) (*Team, error) {
	fields := columns(teamInput)

	// don't update the keys
	delete(fields, "slack_team_id")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// sql query
	sqlstr := `UPDATE "jack"."teams" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE "slack_team_id" = $1 ` +
		`RETURNING "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, slackTeamID)
	values = append(values, _v...)

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, values...)
	}

	// run the query
	var team Team
	row := m.DB.QueryRow(sqlstr, values...)
	if e := row.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeamNotFound
		}
		return nil, e
	}

	return &team, nil
}

// UpdateWhere rows in "jack"."teams" by a given condition
func (m *Model) UpdateWhere(ctx context.Context, where *WhereClause, teamInput *Input) ([]*Team, error) {
	teams := []*Team{}

	// prepare the slices
	_c, _i, _v := slice(columns(teamInput), len(where.params))

	// sql query
	sqlstr := `UPDATE "jack"."teams" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE ` + where.condition + ` ` +
		`RETURNING "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, where.params...)
	values = append(values, _v...)

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, values...)
	}

	// run query
	rows, err := m.DB.Query(sqlstr, values...)
	if err != nil {
		return teams, err
	}
	defer rows.Close()

	for rows.Next() {
		var team Team
		if e := rows.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return teams, ErrTeamNotFound
			}
			return teams, err
		}
		teams = append(teams, &team)
	}
	if rows.Err() != nil {
		return teams, rows.Err()
	}

	return teams, nil
}

// Delete a "team" from the "jack"."teams" table
func (m *Model) Delete(ctx context.Context, id string) error {
	// sql query
	sqlstr := `DELETE FROM "jack"."teams" WHERE "id" = $1`

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, id)
	}

	// run query
	if _, e := m.DB.Exec(sqlstr, id); e != nil {
		if e == pgx.ErrNoRows {
			return ErrTeamNotFound
		}
		return e
	}

	return nil
}

// DeleteBySlackBotAccessToken deletes a "team"
func (m *Model) DeleteBySlackBotAccessToken(ctx context.Context, slackBotAccessToken string) error {
	// sql delete query
	sqlstr := `DELETE FROM "jack"."teams" WHERE "slack_bot_access_token" = $1`

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, slackBotAccessToken)
	}

	if _, e := m.DB.Exec(sqlstr, slackBotAccessToken); e != nil {
		if e == pgx.ErrNoRows {
			return ErrTeamNotFound
		}
		return e
	}

	return nil
}

// DeleteBySlackTeamAccessToken deletes a "team"
func (m *Model) DeleteBySlackTeamAccessToken(ctx context.Context, slackTeamAccessToken string) error {
	// sql delete query
	sqlstr := `DELETE FROM "jack"."teams" WHERE "slack_team_access_token" = $1`

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, slackTeamAccessToken)
	}

	if _, e := m.DB.Exec(sqlstr, slackTeamAccessToken); e != nil {
		if e == pgx.ErrNoRows {
			return ErrTeamNotFound
		}
		return e
	}

	return nil
}

// DeleteBySlackTeamID deletes a "team"
func (m *Model) DeleteBySlackTeamID(ctx context.Context, slackTeamID string) error {
	// sql delete query
	sqlstr := `DELETE FROM "jack"."teams" WHERE "slack_team_id" = $1`

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, slackTeamID)
	}

	if _, e := m.DB.Exec(sqlstr, slackTeamID); e != nil {
		if e == pgx.ErrNoRows {
			return ErrTeamNotFound
		}
		return e
	}

	return nil
}

// DeleteWhere delete many "team"'s by the given condition
func (m *Model) DeleteWhere(ctx context.Context, where *WhereClause) error {
	// sql select query, primary key provided by sequence
	sqlstr := `DELETE FROM "jack"."teams" WHERE ` + where.condition

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, where.params...)
	}

	if _, e := m.DB.Exec(sqlstr, where.params...); e != nil {
		return e
	}

	return nil
}

// Upsert the "team" by its "id".
func (m *Model) Upsert(ctx context.Context, teamInput *Input) (*Team, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(columns(teamInput), 0)

	// sql query
	sqlstr := `INSERT INTO "jack"."teams" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"`

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, _v...)
	}

	// run query
	var team Team
	row := m.DB.QueryRow(sqlstr, _v...)
	if e := row.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt); e != nil {
		return nil, e
	}

	return &team, nil
}

// UpsertBySlackBotAccessToken find a "Team"
func (m *Model) UpsertBySlackBotAccessToken(ctx context.Context, teamInput *Input) (*Team, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(columns(teamInput), 0)

	// sql query
	sqlstr := `INSERT INTO "jack"."teams" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("slack_bot_access_token") ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"`

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, _v...)
	}

	// run query
	var team Team
	row := m.DB.QueryRow(sqlstr, _v...)
	if e := row.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &team, nil
}

// UpsertBySlackTeamAccessToken find a "Team"
func (m *Model) UpsertBySlackTeamAccessToken(ctx context.Context, teamInput *Input) (*Team, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(columns(teamInput), 0)

	// sql query
	sqlstr := `INSERT INTO "jack"."teams" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("slack_team_access_token") ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"`

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, _v...)
	}

	// run query
	var team Team
	row := m.DB.QueryRow(sqlstr, _v...)
	if e := row.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &team, nil
}

// UpsertBySlackTeamID find a "Team"
func (m *Model) UpsertBySlackTeamID(ctx context.Context, teamInput *Input) (*Team, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(columns(teamInput), 0)

	// sql query
	sqlstr := `INSERT INTO "jack"."teams" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("slack_team_id") ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "id", "slack_team_id", "slack_team_access_token", "slack_bot_access_token", "slack_bot_id", "team_name", "scope", "email", "stripe_id", "active", "free_teammates", "cost_per_user", "trial_ends", "created_at", "updated_at"`

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, _v...)
	}

	// run query
	var team Team
	row := m.DB.QueryRow(sqlstr, _v...)
	if e := row.Scan(&team.ID, &team.SlackTeamID, &team.SlackTeamAccessToken, &team.SlackBotAccessToken, &team.SlackBotID, &team.TeamName, &team.Scope, &team.Email, &team.StripeID, &team.Active, &team.FreeTeammates, &team.CostPerUser, &team.TrialEnds, &team.CreatedAt, &team.UpdatedAt); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &team, nil
}

// slice converts our columns into something the sql driver can understand
func slice(columns map[string]interface{}, offset int) (c []string, i []string, v []interface{}) {
	n := offset + 1
	for col, val := range columns {
		c = append(c, `"`+col+`"`)
		i = append(i, "$"+strconv.Itoa(n))
		v = append(v, val)
		n++
	}
	return c, i, v
}

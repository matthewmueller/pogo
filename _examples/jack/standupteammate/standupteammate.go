package standupsteammates

import (
	"context"
	"encoding/json"
	"errors"
	"strconv"
	"strings"
	"time"

	"github.com/jackc/pgx"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrStandupTeammateNotFound returned if the standups_teammates is not found
var ErrStandupTeammateNotFound = errors.New("standups_teammates not found")

// StandupTeammate result data for "jack"."standups_teammates"
type StandupTeammate struct {
	StandupID  string
	TeammateID string
	TeamOwner  bool
	CreatedAt  *time.Time
	UpdatedAt  *time.Time
}

// New input builder for "jack"."standups_teammates".
func New() *Input {
	return &Input{}
}

// Input data for "jack"."standups_teammates"
type Input struct {
	standupID  *string
	teammateID *string
	teamOwner  *bool
	createdAt  *time.Time
	updatedAt  *time.Time
}

// StandupID sets the "standupID"
func (standupTeammate *Input) StandupID(standupID string) *Input {
	standupTeammate.standupID = &standupID
	return standupTeammate
}

// TeammateID sets the "teammateID"
func (standupTeammate *Input) TeammateID(teammateID string) *Input {
	standupTeammate.teammateID = &teammateID
	return standupTeammate
}

// TeamOwner sets the "teamOwner"
func (standupTeammate *Input) TeamOwner(teamOwner bool) *Input {
	standupTeammate.teamOwner = &teamOwner
	return standupTeammate
}

// CreatedAt sets the "createdAt"
func (standupTeammate *Input) CreatedAt(createdAt time.Time) *Input {
	standupTeammate.createdAt = &createdAt
	return standupTeammate
}

// UpdatedAt sets the "updatedAt"
func (standupTeammate *Input) UpdatedAt(updatedAt time.Time) *Input {
	standupTeammate.updatedAt = &updatedAt
	return standupTeammate
}

// MarshalJSON marshals the "standupTeammate" into JSON
func (standupTeammate *Input) MarshalJSON() ([]byte, error) {
	return json.Marshal(standupTeammate)
}

// UnmarshalJSON unmarshals json to a "standupTeammate"
func (standupTeammate *Input) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, standupTeammate)
}

func (standupTeammate *Input) String() string {
	return "standupTeammate"
}

func columns(standupTeammate *Input) map[string]interface{} {
	columns := make(map[string]interface{})

	if standupTeammate.standupID != nil {
		columns["standup_id"] = *standupTeammate.standupID
	}

	if standupTeammate.teammateID != nil {
		columns["teammate_id"] = *standupTeammate.teammateID
	}

	if standupTeammate.teamOwner != nil {
		columns["team_owner"] = *standupTeammate.teamOwner
	}

	if standupTeammate.createdAt != nil {
		columns["created_at"] = *standupTeammate.createdAt
	}

	if standupTeammate.updatedAt != nil {
		columns["updated_at"] = *standupTeammate.updatedAt
	}

	return columns
}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
	condition string
	params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
	return &WhereClause{
		condition: condition,
		params:    params,
	}
}

// DB is the common interface for database operations that can be used with
// types from schema `jack`.
//
// This should work with database/sql.DB and database/sql.Tx.
type DB interface {
	Exec(string, ...interface{}) (pgx.CommandTag, error)
	Query(string, ...interface{}) (*pgx.Rows, error)
	QueryRow(string, ...interface{}) *pgx.Row
}

// Model for StandupTeammate
type Model struct {
	DB  DB
	Log func(string, ...interface{})
}

// Insert a "standupTeammate" into "jack"."standups_teammates"
func (m *Model) Insert(ctx context.Context, standupTeammateInput *Input) (*StandupTeammate, error) {
	// get all the non-nil fields and prepare them for the query
	_c, _i, _v := slice(columns(standupTeammateInput), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
  INSERT INTO "jack"."standups_teammates" (` + strings.Join(_c, ", ") + `)
  VALUES (` + strings.Join(_i, ", ") + `)
  RETURNING "standup_id", "teammate_id", "team_owner", "created_at", "updated_at"
  `

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, _v...)
	}

	// run the query
	var standupTeammate StandupTeammate
	row := m.DB.QueryRow(sqlstr, _v...)
	if e := row.Scan(&standupTeammate.StandupID, &standupTeammate.TeammateID, &standupTeammate.TeamOwner, &standupTeammate.CreatedAt, &standupTeammate.UpdatedAt); e != nil {
		return nil, e
	}

	return &standupTeammate, nil
}

// Find a "StandupTeammate" by its standup_id and teammate_id
func (m *Model) Find(ctx context.Context, standupID string, teammateID string) (*StandupTeammate, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "standup_id", "teammate_id", "team_owner", "created_at", "updated_at"
    FROM "jack.standups_teammates"
    WHERE "standup_id" = $1 AND "teammate_id" = $2
  `

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, standupID, teammateID)
	}

	// run the query
	var standupTeammate StandupTeammate
	row := m.DB.QueryRow(sqlstr, standupID, teammateID)
	if e := row.Scan(&standupTeammate.StandupID, &standupTeammate.TeammateID, &standupTeammate.TeamOwner, &standupTeammate.CreatedAt, &standupTeammate.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupTeammateNotFound
		}
		return nil, e
	}

	return &standupTeammate, nil
}

// Update a "StandupTeammate" by its standup_id and teammate_id
func (m *Model) Update(ctx context.Context, standupID string, teammateID string, standupTeammateInput *Input) (*StandupTeammate, error) {
	fields := columns(standupTeammateInput)

	// don't update the foreign keys
	delete(fields, "standup_id")
	delete(fields, "teammate_id")

	// prepare the slices
	_c, _i, _v := slice(fields, 2)

	// sql query
	sqlstr := `UPDATE "jack"."standups_teammates" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `)
    WHERE "standup_id" = $1 AND "teammate_id" = $2
    RETURNING "standup_id", "teammate_id", "team_owner", "created_at", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, standupID)
	values = append(values, teammateID)
	values = append(values, _v...)

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, values...)
	}

	// run the query
	var standupTeammate StandupTeammate
	row := m.DB.QueryRow(sqlstr, values...)
	if e := row.Scan(&standupTeammate.StandupID, &standupTeammate.TeammateID, &standupTeammate.TeamOwner, &standupTeammate.CreatedAt, &standupTeammate.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupTeammateNotFound
		}
		return nil, e
	}

	return &standupTeammate, nil
}

// Delete a "StandupTeammate" by its standup_id and teammate_id.
func (m *Model) Delete(ctx context.Context, standupID string, teammateID string) error {
	// sql query
	const sqlstr = `
    DELETE FROM "jack"."standups_teammates"
    WHERE "standup_id" = $1 AND "teammate_id" = $2
  `

	// log query if we've provided a logger
	if m.Log != nil {
		m.Log(sqlstr, standupID, teammateID)
	}

	// run query
	if _, e := m.DB.Exec(sqlstr, standupID, teammateID); e != nil {
		if e == pgx.ErrNoRows {
			return ErrStandupTeammateNotFound
		}
		return e
	}

	return nil
}

// slice converts our columns into something the sql driver can understand
func slice(columns map[string]interface{}, offset int) (c []string, i []string, v []interface{}) {
	n := offset + 1
	for col, val := range columns {
		c = append(c, `"`+col+`"`)
		i = append(i, "$"+strconv.Itoa(n))
		v = append(v, val)
		n++
	}
	return c, i, v
}

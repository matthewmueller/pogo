package schemamigrations

import (
	"encoding/json"
	"errors"
	"strings"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/digby/pogo"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrSchemaMigrationNotFound returned if the schema_migrations is not found
var ErrSchemaMigrationNotFound = errors.New("schema_migrations not found")

// SchemaMigrationInput model for "public"."schema_migrations"
type SchemaMigrationInput struct {
	version *int
}

// SchemaMigration model for "public"."schema_migrations"
type SchemaMigration struct {
	Version int
}

// New "public"."schema_migrations" API
func New() *SchemaMigrationInput {
	return &SchemaMigrationInput{}
}

// Version sets the "version"
func (schemaMigration *SchemaMigrationInput) Version(version int) *SchemaMigrationInput {
	schemaMigration.version = &version
	return schemaMigration
}

// MarshalJSON marshals the "schemaMigration" into JSON
func (schemaMigration *SchemaMigrationInput) MarshalJSON() ([]byte, error) {
	return json.Marshal(schemaMigration)
}

// UnmarshalJSON unmarshals json to a "schemaMigration"
func (schemaMigration *SchemaMigrationInput) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, schemaMigration)
}

func (schemaMigration *SchemaMigrationInput) String() string {
	return "schemaMigration"
}

func getColumns(schemaMigration *SchemaMigrationInput) map[string]interface{} {
	columns := make(map[string]interface{})

	if schemaMigration.version != nil {
		columns["version"] = *schemaMigration.version
	}

	return columns
}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
	condition string
	params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
	return &WhereClause{
		condition: condition,
		params:    params,
	}
}

// Insert a "schemaMigration" into the "public"."schema_migrations"
func Insert(db digby.DB, schemaMigrationInput *SchemaMigrationInput) (*SchemaMigration, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := digby.Slice(getColumns(schemaMigrationInput), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
    INSERT INTO "public"."schema_migrations" (` + strings.Join(_c, ", ") + `)
    VALUES (` + strings.Join(_i, ", ") + `)
    RETURNING "version"
  `
	digby.Log(sqlstr, _v...)

	var schemaMigration SchemaMigration
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&schemaMigration.Version); e != nil {
		return nil, e
	}

	return &schemaMigration, nil
}

// Find a "SchemaMigration" by "version"
func Find(db pogo.DB, version string) (*SchemaMigration, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "version"
    FROM "public"."schema_migrations"
    WHERE "version" = $1
  `
	pogo.Log(sqlstr, &version)

	var schemaMigration SchemaMigration
	row := db.QueryRow(sqlstr, &version)
	if e := row.Scan(&schemaMigration.Version); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrSchemaMigrationNotFound
		}
		return nil, e
	}

	return &schemaMigration, nil
}

// FindByVersion find a schemaMigration by version
func FindByVersion(db digby.DB, version int) (*SchemaMigration, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "version"
    FROM "public"."schema_migrations"
    WHERE "version" = $1
  `
	digby.Log(sqlstr, version)

	var schemaMigration SchemaMigration
	row := db.QueryRow(sqlstr, version)
	err := row.Scan(&schemaMigration.Version)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, ErrSchemaMigrationNotFound
		}
		return nil, err
	}

	return &schemaMigration, nil
}

// FindOne find one schemaMigration by a condition
func FindOne(db digby.DB, where *WhereClause) (*SchemaMigration, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
  SELECT "version"
  FROM "public"."schema_migrations"
  WHERE ` + where.condition
	digby.Log(sqlstr, where.params...)

	var schemaMigration SchemaMigration
	row := db.QueryRow(sqlstr, where.params...)
	if e := row.Scan(&schemaMigration.Version); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrSchemaMigrationNotFound
		}
		return nil, e
	}

	return &schemaMigration, nil
}

// FindMany find many "schemaMigration"'s by a given condition
func FindMany(db digby.DB, where *WhereClause) (schemaMigrations []*SchemaMigration, err error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
  SELECT "version"
  FROM "public"."schema_migrations"
  WHERE ` + where.condition
	digby.Log(sqlstr, where.params...)

	rows, err := db.Query(sqlstr, where.params...)
	if err != nil {
		return schemaMigrations, err
	}
	defer rows.Close()

	for rows.Next() {
		var schemaMigration SchemaMigration
		if e := rows.Scan(&schemaMigration.Version); e != nil {
			if e == pgx.ErrNoRows {
				return schemaMigrations, ErrSchemaMigrationNotFound
			}
			return schemaMigrations, err
		}
		schemaMigrations = append(schemaMigrations, &schemaMigration)
	}
	if rows.Err() != nil {
		return schemaMigrations, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	// if len(schemaMigrations) == 0 {
	// 	return make([]*SchemaMigration, 0), nil
	// }

	return schemaMigrations, nil
}

// Update a "schemaMigration" in "public"."schema_migrations" by its "version"
func Update(db digby.DB, version int, schemaMigrationInput *SchemaMigrationInput) (*SchemaMigration, error) {
	fields := getColumns(schemaMigrationInput)

	// don't update the primary key
	delete(fields, "version")

	// prepare the slices
	_c, _i, _v := digby.Slice(fields, 1)

	// sql query
	sqlstr := `UPDATE "public"."schema_migrations" SET (` +
		strings.Join(_c, ", ") +
		`) = (` +
		strings.Join(_i, ", ") +
		`)
    WHERE "version" = $1
    RETURNING "version"`

	// setup query
	values := append([]interface{}{&version}, _v...)
	digby.Log(sqlstr, values...)

	// run the query
	var schemaMigration SchemaMigration
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&schemaMigration.Version); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrSchemaMigrationNotFound
		}
		return nil, e
	}

	return &schemaMigration, nil
}

// UpdateMany rows in "public"."schema_migrations" by a given condition
func UpdateMany(db digby.DB, where *WhereClause, schemaMigrationInput *SchemaMigrationInput) (schemaMigrations []*SchemaMigration, err error) {
	// prepare the slices
	_c, _i, _v := digby.Slice(getColumns(schemaMigrationInput), len(where.params))

	// sql query
	sqlstr := `UPDATE "public"."schema_migrations" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE ` + where.condition + ` ` +
		`RETURNING "version"`

	// setup the query
	values := []interface{}{}
	values = append(values, where.params...)
	values = append(values, _v...)
	digby.Log(sqlstr, values...)

	// run query
	rows, err := db.Query(sqlstr, values...)
	if err != nil {
		return schemaMigrations, err
	}
	defer rows.Close()

	for rows.Next() {
		var schemaMigration SchemaMigration
		if e := rows.Scan(&schemaMigration.Version); e != nil {
			if e == pgx.ErrNoRows {
				return schemaMigrations, ErrSchemaMigrationNotFound
			}
			return schemaMigrations, err
		}
		schemaMigrations = append(schemaMigrations, &schemaMigration)
	}
	if rows.Err() != nil {
		return schemaMigrations, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	// if len(schemaMigrations) == 0 {
	// 	return make([]*SchemaMigration, 0), nil
	// }

	return schemaMigrations, nil
}

// Delete a "schemaMigration" from the "public"."schema_migrations" table
func Delete(db digby.DB, version int) error {
	// sql query
	sqlstr := `DELETE FROM "public"."schema_migrations" WHERE "version" = $1`
	digby.Log(sqlstr, version)

	// run query
	if _, e := db.Exec(sqlstr, version); e != nil {
		if e == pgx.ErrNoRows {
			return ErrSchemaMigrationNotFound
		}
		return e
	}

	return nil
}

// DeleteMany delete many "schemaMigration"'s by the given condition
func DeleteMany(db digby.DB, where *WhereClause) error {
	// sql select query, primary key provided by sequence
	sqlstr := `DELETE FROM "public"."schema_migrations" WHERE ` + where.condition
	digby.Log(sqlstr, where.params...)

	if _, e := db.Exec(sqlstr, where.params...); e != nil {
		return e
	}

	return nil
}

// Upsert the "schemaMigration" by its "version".
func Upsert(db digby.DB, schemaMigrationInput *SchemaMigrationInput) (*SchemaMigration, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := digby.Slice(getColumns(schemaMigrationInput), 0)

	// sql query
	sqlstr := `INSERT INTO "public"."schema_migrations" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("version") ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "version"`
	digby.Log(sqlstr, _v...)

	// run query
	var schemaMigration SchemaMigration
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&schemaMigration.Version); e != nil {
		return nil, e
	}

	return &schemaMigration, nil
}

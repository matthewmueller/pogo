package projectsusers

import (
	"encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/jackc/pgx"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrProjectUserNotFound returned if the projects_users is not found
var ErrProjectUserNotFound = errors.New("projects_users not found")

// ProjectUserInput model for "public"."projects_users"
type ProjectUserInput struct {
	projectID *string
	userID    *string
	alias     *string
	isOwner   *bool
	joinedAt  *time.Time
	createdAt *time.Time
	updatedAt *time.Time
}

// ProjectUser model for "public"."projects_users"
type ProjectUser struct {
	ProjectID string
	UserID    string
	Alias     *string
	IsOwner   bool
	JoinedAt  *time.Time
	CreatedAt *time.Time
	UpdatedAt *time.Time
}

// New "public"."projects_users" API
func New() *ProjectUserInput {
	return &ProjectUserInput{}
}

// ProjectID sets the "projectID"
func (projectUser *ProjectUserInput) ProjectID(projectID string) *ProjectUserInput {
	projectUser.projectID = &projectID
	return projectUser
}

// UserID sets the "userID"
func (projectUser *ProjectUserInput) UserID(userID string) *ProjectUserInput {
	projectUser.userID = &userID
	return projectUser
}

// Alias sets the "alias"
func (projectUser *ProjectUserInput) Alias(alias string) *ProjectUserInput {
	projectUser.alias = &alias
	return projectUser
}

// IsOwner sets the "isOwner"
func (projectUser *ProjectUserInput) IsOwner(isOwner bool) *ProjectUserInput {
	projectUser.isOwner = &isOwner
	return projectUser
}

// JoinedAt sets the "joinedAt"
func (projectUser *ProjectUserInput) JoinedAt(joinedAt time.Time) *ProjectUserInput {
	projectUser.joinedAt = &joinedAt
	return projectUser
}

// CreatedAt sets the "createdAt"
func (projectUser *ProjectUserInput) CreatedAt(createdAt time.Time) *ProjectUserInput {
	projectUser.createdAt = &createdAt
	return projectUser
}

// UpdatedAt sets the "updatedAt"
func (projectUser *ProjectUserInput) UpdatedAt(updatedAt time.Time) *ProjectUserInput {
	projectUser.updatedAt = &updatedAt
	return projectUser
}

// MarshalJSON marshals the "projectUser" into JSON
func (projectUser *ProjectUserInput) MarshalJSON() ([]byte, error) {
	return json.Marshal(projectUser)
}

// UnmarshalJSON unmarshals json to a "projectUser"
func (projectUser *ProjectUserInput) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, projectUser)
}

func (projectUser *ProjectUserInput) String() string {
	return "projectUser"
}

func getColumns(projectUser *ProjectUserInput) map[string]interface{} {
	columns := make(map[string]interface{})

	if projectUser.projectID != nil {
		columns["project_id"] = *projectUser.projectID
	}

	if projectUser.userID != nil {
		columns["user_id"] = *projectUser.userID
	}

	if projectUser.alias != nil {
		columns["alias"] = *projectUser.alias
	}

	if projectUser.isOwner != nil {
		columns["is_owner"] = *projectUser.isOwner
	}

	if projectUser.joinedAt != nil {
		columns["joined_at"] = *projectUser.joinedAt
	}

	if projectUser.createdAt != nil {
		columns["created_at"] = *projectUser.createdAt
	}

	if projectUser.updatedAt != nil {
		columns["updated_at"] = *projectUser.updatedAt
	}

	return columns
}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
	condition string
	params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
	return &WhereClause{
		condition: condition,
		params:    params,
	}
}

// Insert a "projectUser" into "public"."projects_users"
func Insert(db digby.DB, projectUserInput *ProjectUserInput) (*ProjectUser, error) {
	// get all the non-nil fields and prepare them for the query
	_c, _i, _v := digby.Slice(getColumns(projectUserInput), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
  INSERT INTO "public"."projects_users" (` + strings.Join(_c, ", ") + `)
  VALUES (` + strings.Join(_i, ", ") + `)
  RETURNING "project_id", "user_id", "alias", "is_owner", "joined_at", "created_at", "updated_at"
  `
	digby.Log(sqlstr, _v...)

	// run the query
	var projectUser ProjectUser
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&projectUser.ProjectID, &projectUser.UserID, &projectUser.Alias, &projectUser.IsOwner, &projectUser.JoinedAt, &projectUser.CreatedAt, &projectUser.UpdatedAt); e != nil {
		return nil, e
	}

	return &projectUser, nil
}

// Find a "ProjectUser" by its project_id and user_id
func Find(db digby.DB, projectID string, userID string) (*ProjectUser, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "project_id", "user_id", "alias", "is_owner", "joined_at", "created_at", "updated_at"
    FROM "public.projects_users"
    WHERE "project_id" = $1 AND "user_id" = $2
  `
	digby.Log(sqlstr, projectID, userID)

	// run the query
	var projectUser ProjectUser
	row := db.QueryRow(sqlstr, projectID, userID)
	if e := row.Scan(&projectUser.ProjectID, &projectUser.UserID, &projectUser.Alias, &projectUser.IsOwner, &projectUser.JoinedAt, &projectUser.CreatedAt, &projectUser.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrProjectUserNotFound
		}
		return nil, e
	}

	return &projectUser, nil
}

// Update a "ProjectUser" by its project_id and user_id
func Update(db digby.DB, projectID string, userID string, projectUserInput *ProjectUserInput) (*ProjectUser, error) {
	fields := getColumns(projectUserInput)

	// don't update the foreign keys
	delete(fields, "project_id")
	delete(fields, "user_id")

	// prepare the slices
	_c, _i, _v := digby.Slice(fields, 2)

	// sql query
	sqlstr := `UPDATE "public"."projects_users" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `)
    WHERE "project_id" = $1 AND "user_id" = $2
    RETURNING "project_id", "user_id", "alias", "is_owner", "joined_at", "created_at", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, projectID)
	values = append(values, userID)
	values = append(values, _v...)
	digby.Log(sqlstr, values...)

	// run the query
	var projectUser ProjectUser
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&projectUser.ProjectID, &projectUser.UserID, &projectUser.Alias, &projectUser.IsOwner, &projectUser.JoinedAt, &projectUser.CreatedAt, &projectUser.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrProjectUserNotFound
		}
		return nil, e
	}

	return &projectUser, nil
}

// Delete a "ProjectUser" by its project_id and user_id.
func Delete(db digby.DB, projectID string, userID string) error {
	// sql query
	const sqlstr = `
    DELETE FROM "public"."projects_users"
    WHERE "project_id" = $1 AND "user_id" = $2
  `
	digby.Log(sqlstr, projectID, userID)

	// run query
	if _, e := db.Exec(sqlstr, projectID, userID); e != nil {
		if e == pgx.ErrNoRows {
			return ErrProjectUserNotFound
		}
		return e
	}

	return nil
}

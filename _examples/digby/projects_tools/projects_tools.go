package projectstools

import (
	"encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/jackc/pgx"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrProjectToolNotFound returned if the projects_tools is not found
var ErrProjectToolNotFound = errors.New("projects_tools not found")

// ProjectToolInput model for "public"."projects_tools"
type ProjectToolInput struct {
	projectID *string
	toolID    *string
	createdAt *time.Time
	updatedAt *time.Time
}

// ProjectTool model for "public"."projects_tools"
type ProjectTool struct {
	ProjectID string
	ToolID    string
	CreatedAt *time.Time
	UpdatedAt *time.Time
}

// New "public"."projects_tools" API
func New() *ProjectToolInput {
	return &ProjectToolInput{}
}

// ProjectID sets the "projectID"
func (projectTool *ProjectToolInput) ProjectID(projectID string) *ProjectToolInput {
	projectTool.projectID = &projectID
	return projectTool
}

// ToolID sets the "toolID"
func (projectTool *ProjectToolInput) ToolID(toolID string) *ProjectToolInput {
	projectTool.toolID = &toolID
	return projectTool
}

// CreatedAt sets the "createdAt"
func (projectTool *ProjectToolInput) CreatedAt(createdAt time.Time) *ProjectToolInput {
	projectTool.createdAt = &createdAt
	return projectTool
}

// UpdatedAt sets the "updatedAt"
func (projectTool *ProjectToolInput) UpdatedAt(updatedAt time.Time) *ProjectToolInput {
	projectTool.updatedAt = &updatedAt
	return projectTool
}

// MarshalJSON marshals the "projectTool" into JSON
func (projectTool *ProjectToolInput) MarshalJSON() ([]byte, error) {
	return json.Marshal(projectTool)
}

// UnmarshalJSON unmarshals json to a "projectTool"
func (projectTool *ProjectToolInput) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, projectTool)
}

func (projectTool *ProjectToolInput) String() string {
	return "projectTool"
}

func getColumns(projectTool *ProjectToolInput) map[string]interface{} {
	columns := make(map[string]interface{})

	if projectTool.projectID != nil {
		columns["project_id"] = *projectTool.projectID
	}

	if projectTool.toolID != nil {
		columns["tool_id"] = *projectTool.toolID
	}

	if projectTool.createdAt != nil {
		columns["created_at"] = *projectTool.createdAt
	}

	if projectTool.updatedAt != nil {
		columns["updated_at"] = *projectTool.updatedAt
	}

	return columns
}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
	condition string
	params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
	return &WhereClause{
		condition: condition,
		params:    params,
	}
}

// Insert a "projectTool" into "public"."projects_tools"
func Insert(db digby.DB, projectToolInput *ProjectToolInput) (*ProjectTool, error) {
	// get all the non-nil fields and prepare them for the query
	_c, _i, _v := digby.Slice(getColumns(projectToolInput), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
  INSERT INTO "public"."projects_tools" (` + strings.Join(_c, ", ") + `)
  VALUES (` + strings.Join(_i, ", ") + `)
  RETURNING "project_id", "tool_id", "created_at", "updated_at"
  `
	digby.Log(sqlstr, _v...)

	// run the query
	var projectTool ProjectTool
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&projectTool.ProjectID, &projectTool.ToolID, &projectTool.CreatedAt, &projectTool.UpdatedAt); e != nil {
		return nil, e
	}

	return &projectTool, nil
}

// Find a "ProjectTool" by its project_id and tool_id
func Find(db digby.DB, projectID string, toolID string) (*ProjectTool, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "project_id", "tool_id", "created_at", "updated_at"
    FROM "public.projects_tools"
    WHERE "project_id" = $1 AND "tool_id" = $2
  `
	digby.Log(sqlstr, projectID, toolID)

	// run the query
	var projectTool ProjectTool
	row := db.QueryRow(sqlstr, projectID, toolID)
	if e := row.Scan(&projectTool.ProjectID, &projectTool.ToolID, &projectTool.CreatedAt, &projectTool.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrProjectToolNotFound
		}
		return nil, e
	}

	return &projectTool, nil
}

// Update a "ProjectTool" by its project_id and tool_id
func Update(db digby.DB, projectID string, toolID string, projectToolInput *ProjectToolInput) (*ProjectTool, error) {
	fields := getColumns(projectToolInput)

	// don't update the foreign keys
	delete(fields, "project_id")
	delete(fields, "tool_id")

	// prepare the slices
	_c, _i, _v := digby.Slice(fields, 2)

	// sql query
	sqlstr := `UPDATE "public"."projects_tools" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `)
    WHERE "project_id" = $1 AND "tool_id" = $2
    RETURNING "project_id", "tool_id", "created_at", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, projectID)
	values = append(values, toolID)
	values = append(values, _v...)
	digby.Log(sqlstr, values...)

	// run the query
	var projectTool ProjectTool
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&projectTool.ProjectID, &projectTool.ToolID, &projectTool.CreatedAt, &projectTool.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrProjectToolNotFound
		}
		return nil, e
	}

	return &projectTool, nil
}

// Delete a "ProjectTool" by its project_id and tool_id.
func Delete(db digby.DB, projectID string, toolID string) error {
	// sql query
	const sqlstr = `
    DELETE FROM "public"."projects_tools"
    WHERE "project_id" = $1 AND "tool_id" = $2
  `
	digby.Log(sqlstr, projectID, toolID)

	// run query
	if _, e := db.Exec(sqlstr, projectID, toolID); e != nil {
		if e == pgx.ErrNoRows {
			return ErrProjectToolNotFound
		}
		return e
	}

	return nil
}

package activities

import (
	"encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/jack/slack/pogo"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrActivityNotFound returned if the activities is not found
var ErrActivityNotFound = errors.New("activities not found")

// ActivityInput model for "public"."activities"
type ActivityInput struct {
	id         *string
	projectID  *string
	creatorID  *string
	subject    *string
	icon       *string
	eventCount *int
	readAt     *time.Time
	createdAt  *time.Time
	updatedAt  *time.Time
}

// Activity model for "public"."activities"
type Activity struct {
	ID         string
	ProjectID  string
	CreatorID  string
	Subject    string
	Icon       string
	EventCount int
	ReadAt     *time.Time
	CreatedAt  *time.Time
	UpdatedAt  *time.Time
}

// New "public"."activities" API
func New() *ActivityInput {
	return &ActivityInput{}
}

// ID sets the "id"
func (activity *ActivityInput) ID(id string) *ActivityInput {
	activity.id = &id
	return activity
}

// ProjectID sets the "projectID"
func (activity *ActivityInput) ProjectID(projectID string) *ActivityInput {
	activity.projectID = &projectID
	return activity
}

// CreatorID sets the "creatorID"
func (activity *ActivityInput) CreatorID(creatorID string) *ActivityInput {
	activity.creatorID = &creatorID
	return activity
}

// Subject sets the "subject"
func (activity *ActivityInput) Subject(subject string) *ActivityInput {
	activity.subject = &subject
	return activity
}

// Icon sets the "icon"
func (activity *ActivityInput) Icon(icon string) *ActivityInput {
	activity.icon = &icon
	return activity
}

// EventCount sets the "eventCount"
func (activity *ActivityInput) EventCount(eventCount int) *ActivityInput {
	activity.eventCount = &eventCount
	return activity
}

// ReadAt sets the "readAt"
func (activity *ActivityInput) ReadAt(readAt time.Time) *ActivityInput {
	activity.readAt = &readAt
	return activity
}

// CreatedAt sets the "createdAt"
func (activity *ActivityInput) CreatedAt(createdAt time.Time) *ActivityInput {
	activity.createdAt = &createdAt
	return activity
}

// UpdatedAt sets the "updatedAt"
func (activity *ActivityInput) UpdatedAt(updatedAt time.Time) *ActivityInput {
	activity.updatedAt = &updatedAt
	return activity
}

// MarshalJSON marshals the "activity" into JSON
func (activity *ActivityInput) MarshalJSON() ([]byte, error) {
	return json.Marshal(activity)
}

// UnmarshalJSON unmarshals json to a "activity"
func (activity *ActivityInput) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, activity)
}

func (activity *ActivityInput) String() string {
	return "activity"
}

func getColumns(activity *ActivityInput) map[string]interface{} {
	columns := make(map[string]interface{})

	if activity.id != nil {
		columns["id"] = *activity.id
	}

	if activity.projectID != nil {
		columns["project_id"] = *activity.projectID
	}

	if activity.creatorID != nil {
		columns["creator_id"] = *activity.creatorID
	}

	if activity.subject != nil {
		columns["subject"] = *activity.subject
	}

	if activity.icon != nil {
		columns["icon"] = *activity.icon
	}

	if activity.eventCount != nil {
		columns["event_count"] = *activity.eventCount
	}

	if activity.readAt != nil {
		columns["read_at"] = *activity.readAt
	}

	if activity.createdAt != nil {
		columns["created_at"] = *activity.createdAt
	}

	if activity.updatedAt != nil {
		columns["updated_at"] = *activity.updatedAt
	}

	return columns
}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
	condition string
	params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
	return &WhereClause{
		condition: condition,
		params:    params,
	}
}

// Insert a "activity" into the "public"."activities"
func Insert(db digby.DB, activityInput *ActivityInput) (*Activity, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := digby.Slice(getColumns(activityInput), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
    INSERT INTO "public"."activities" (` + strings.Join(_c, ", ") + `)
    VALUES (` + strings.Join(_i, ", ") + `)
    RETURNING "id", "project_id", "creator_id", "subject", "icon", "event_count", "read_at", "created_at", "updated_at"
  `
	digby.Log(sqlstr, _v...)

	var activity Activity
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&activity.ID, &activity.ProjectID, &activity.CreatorID, &activity.Subject, &activity.Icon, &activity.EventCount, &activity.ReadAt, &activity.CreatedAt, &activity.UpdatedAt); e != nil {
		return nil, e
	}

	return &activity, nil
}

// Find a "Activity" by "id"
func Find(db pogo.DB, id string) (*Activity, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "project_id", "creator_id", "subject", "icon", "event_count", "read_at", "created_at", "updated_at"
    FROM "public"."activities"
    WHERE "id" = $1
  `
	pogo.Log(sqlstr, &id)

	var activity Activity
	row := db.QueryRow(sqlstr, &id)
	if e := row.Scan(&activity.ID, &activity.ProjectID, &activity.CreatorID, &activity.Subject, &activity.Icon, &activity.EventCount, &activity.ReadAt, &activity.CreatedAt, &activity.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrActivityNotFound
		}
		return nil, e
	}

	return &activity, nil
}

// FindByID find a activity by id
func FindByID(db digby.DB, id string) (*Activity, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "project_id", "creator_id", "subject", "icon", "event_count", "read_at", "created_at", "updated_at"
    FROM "public"."activities"
    WHERE "id" = $1
  `
	digby.Log(sqlstr, id)

	var activity Activity
	row := db.QueryRow(sqlstr, id)
	err := row.Scan(&activity.ID, &activity.ProjectID, &activity.CreatorID, &activity.Subject, &activity.Icon, &activity.EventCount, &activity.ReadAt, &activity.CreatedAt, &activity.UpdatedAt)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, ErrActivityNotFound
		}
		return nil, err
	}

	return &activity, nil
}

// FindOne find one activity by a condition
func FindOne(db digby.DB, where *WhereClause) (*Activity, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
  SELECT "id", "project_id", "creator_id", "subject", "icon", "event_count", "read_at", "created_at", "updated_at"
  FROM "public"."activities"
  WHERE ` + where.condition
	digby.Log(sqlstr, where.params...)

	var activity Activity
	row := db.QueryRow(sqlstr, where.params...)
	if e := row.Scan(&activity.ID, &activity.ProjectID, &activity.CreatorID, &activity.Subject, &activity.Icon, &activity.EventCount, &activity.ReadAt, &activity.CreatedAt, &activity.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrActivityNotFound
		}
		return nil, e
	}

	return &activity, nil
}

// FindMany find many "activity"'s by a given condition
func FindMany(db digby.DB, where *WhereClause) ([]*Activity, error) {
	activities := []*Activity{}

	// sql select query, primary key provided by sequence
	sqlstr := `
  SELECT "id", "project_id", "creator_id", "subject", "icon", "event_count", "read_at", "created_at", "updated_at"
  FROM "public"."activities"
  WHERE ` + where.condition
	digby.Log(sqlstr, where.params...)

	rows, err := db.Query(sqlstr, where.params...)
	if err != nil {
		return activities, err
	}
	defer rows.Close()

	for rows.Next() {
		var activity Activity
		if e := rows.Scan(&activity.ID, &activity.ProjectID, &activity.CreatorID, &activity.Subject, &activity.Icon, &activity.EventCount, &activity.ReadAt, &activity.CreatedAt, &activity.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return activities, ErrActivityNotFound
			}
			return activities, err
		}
		activities = append(activities, &activity)
	}
	if rows.Err() != nil {
		return activities, rows.Err()
	}

	return activities, nil
}

// Update a "activity" in "public"."activities" by its "id"
func Update(db digby.DB, id string, activityInput *ActivityInput) (*Activity, error) {
	fields := getColumns(activityInput)

	// don't update the primary key
	delete(fields, "id")

	// prepare the slices
	_c, _i, _v := digby.Slice(fields, 1)

	// sql query
	sqlstr := `UPDATE "public"."activities" SET (` +
		strings.Join(_c, ", ") +
		`) = (` +
		strings.Join(_i, ", ") +
		`)
    WHERE "id" = $1
    RETURNING "id", "project_id", "creator_id", "subject", "icon", "event_count", "read_at", "created_at", "updated_at"`

	// setup query
	values := append([]interface{}{&id}, _v...)
	digby.Log(sqlstr, values...)

	// run the query
	var activity Activity
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&activity.ID, &activity.ProjectID, &activity.CreatorID, &activity.Subject, &activity.Icon, &activity.EventCount, &activity.ReadAt, &activity.CreatedAt, &activity.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrActivityNotFound
		}
		return nil, e
	}

	return &activity, nil
}

// UpdateMany rows in "public"."activities" by a given condition
func UpdateMany(db digby.DB, where *WhereClause, activityInput *ActivityInput) ([]*Activity, error) {
	activities := []*Activity{}

	// prepare the slices
	_c, _i, _v := digby.Slice(getColumns(activityInput), len(where.params))

	// sql query
	sqlstr := `UPDATE "public"."activities" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE ` + where.condition + ` ` +
		`RETURNING "id", "project_id", "creator_id", "subject", "icon", "event_count", "read_at", "created_at", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, where.params...)
	values = append(values, _v...)
	digby.Log(sqlstr, values...)

	// run query
	rows, err := db.Query(sqlstr, values...)
	if err != nil {
		return activities, err
	}
	defer rows.Close()

	for rows.Next() {
		var activity Activity
		if e := rows.Scan(&activity.ID, &activity.ProjectID, &activity.CreatorID, &activity.Subject, &activity.Icon, &activity.EventCount, &activity.ReadAt, &activity.CreatedAt, &activity.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return activities, ErrActivityNotFound
			}
			return activities, err
		}
		activities = append(activities, &activity)
	}
	if rows.Err() != nil {
		return activities, rows.Err()
	}

	return activities, nil
}

// Delete a "activity" from the "public"."activities" table
func Delete(db digby.DB, id string) error {
	// sql query
	sqlstr := `DELETE FROM "public"."activities" WHERE "id" = $1`
	digby.Log(sqlstr, id)

	// run query
	if _, e := db.Exec(sqlstr, id); e != nil {
		if e == pgx.ErrNoRows {
			return ErrActivityNotFound
		}
		return e
	}

	return nil
}

// DeleteMany delete many "activity"'s by the given condition
func DeleteMany(db digby.DB, where *WhereClause) error {
	// sql select query, primary key provided by sequence
	sqlstr := `DELETE FROM "public"."activities" WHERE ` + where.condition
	digby.Log(sqlstr, where.params...)

	if _, e := db.Exec(sqlstr, where.params...); e != nil {
		return e
	}

	return nil
}

// Upsert the "activity" by its "id".
func Upsert(db digby.DB, activityInput *ActivityInput) (*Activity, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := digby.Slice(getColumns(activityInput), 0)

	// sql query
	sqlstr := `INSERT INTO "public"."activities" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "id", "project_id", "creator_id", "subject", "icon", "event_count", "read_at", "created_at", "updated_at"`
	digby.Log(sqlstr, _v...)

	// run query
	var activity Activity
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&activity.ID, &activity.ProjectID, &activity.CreatorID, &activity.Subject, &activity.Icon, &activity.EventCount, &activity.ReadAt, &activity.CreatedAt, &activity.UpdatedAt); e != nil {
		return nil, e
	}

	return &activity, nil
}

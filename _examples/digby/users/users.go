package users

import (
	"encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/jack/slack/pogo"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrUserNotFound returned if the users is not found
var ErrUserNotFound = errors.New("users not found")

// UserInput model for "public"."users"
type UserInput struct {
	id          *string
	firstName   *string
	lastName    *string
	email       *string
	password    *string
	confirmedAt *time.Time
	createdAt   *time.Time
	updatedAt   *time.Time
}

// User model for "public"."users"
type User struct {
	ID          string
	FirstName   string
	LastName    string
	Email       string
	Password    string
	ConfirmedAt *time.Time
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

// New "public"."users" API
func New() *UserInput {
	return &UserInput{}
}

// ID sets the "id"
func (user *UserInput) ID(id string) *UserInput {
	user.id = &id
	return user
}

// FirstName sets the "firstName"
func (user *UserInput) FirstName(firstName string) *UserInput {
	user.firstName = &firstName
	return user
}

// LastName sets the "lastName"
func (user *UserInput) LastName(lastName string) *UserInput {
	user.lastName = &lastName
	return user
}

// Email sets the "email"
func (user *UserInput) Email(email string) *UserInput {
	user.email = &email
	return user
}

// Password sets the "password"
func (user *UserInput) Password(password string) *UserInput {
	user.password = &password
	return user
}

// ConfirmedAt sets the "confirmedAt"
func (user *UserInput) ConfirmedAt(confirmedAt time.Time) *UserInput {
	user.confirmedAt = &confirmedAt
	return user
}

// CreatedAt sets the "createdAt"
func (user *UserInput) CreatedAt(createdAt time.Time) *UserInput {
	user.createdAt = &createdAt
	return user
}

// UpdatedAt sets the "updatedAt"
func (user *UserInput) UpdatedAt(updatedAt time.Time) *UserInput {
	user.updatedAt = &updatedAt
	return user
}

// MarshalJSON marshals the "user" into JSON
func (user *UserInput) MarshalJSON() ([]byte, error) {
	return json.Marshal(user)
}

// UnmarshalJSON unmarshals json to a "user"
func (user *UserInput) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, user)
}

func (user *UserInput) String() string {
	return "user"
}

func getColumns(user *UserInput) map[string]interface{} {
	columns := make(map[string]interface{})

	if user.id != nil {
		columns["id"] = *user.id
	}

	if user.firstName != nil {
		columns["first_name"] = *user.firstName
	}

	if user.lastName != nil {
		columns["last_name"] = *user.lastName
	}

	if user.email != nil {
		columns["email"] = *user.email
	}

	if user.password != nil {
		columns["password"] = *user.password
	}

	if user.confirmedAt != nil {
		columns["confirmed_at"] = *user.confirmedAt
	}

	if user.createdAt != nil {
		columns["created_at"] = *user.createdAt
	}

	if user.updatedAt != nil {
		columns["updated_at"] = *user.updatedAt
	}

	return columns
}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
	condition string
	params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
	return &WhereClause{
		condition: condition,
		params:    params,
	}
}

// Insert a "user" into the "public"."users"
func Insert(db digby.DB, userInput *UserInput) (*User, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := digby.Slice(getColumns(userInput), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
    INSERT INTO "public"."users" (` + strings.Join(_c, ", ") + `)
    VALUES (` + strings.Join(_i, ", ") + `)
    RETURNING "id", "first_name", "last_name", "email", "password", "confirmed_at", "created_at", "updated_at"
  `
	digby.Log(sqlstr, _v...)

	var user User
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&user.ID, &user.FirstName, &user.LastName, &user.Email, &user.Password, &user.ConfirmedAt, &user.CreatedAt, &user.UpdatedAt); e != nil {
		return nil, e
	}

	return &user, nil
}

// Find a "User" by "id"
func Find(db pogo.DB, id string) (*User, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "first_name", "last_name", "email", "password", "confirmed_at", "created_at", "updated_at"
    FROM "public"."users"
    WHERE "id" = $1
  `
	pogo.Log(sqlstr, &id)

	var user User
	row := db.QueryRow(sqlstr, &id)
	if e := row.Scan(&user.ID, &user.FirstName, &user.LastName, &user.Email, &user.Password, &user.ConfirmedAt, &user.CreatedAt, &user.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrUserNotFound
		}
		return nil, e
	}

	return &user, nil
}

// FindByEmail find a user by email
func FindByEmail(db digby.DB, email string) (*User, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "first_name", "last_name", "email", "password", "confirmed_at", "created_at", "updated_at"
    FROM "public"."users"
    WHERE "email" = $1
  `
	digby.Log(sqlstr, email)

	var user User
	row := db.QueryRow(sqlstr, email)
	err := row.Scan(&user.ID, &user.FirstName, &user.LastName, &user.Email, &user.Password, &user.ConfirmedAt, &user.CreatedAt, &user.UpdatedAt)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, ErrUserNotFound
		}
		return nil, err
	}

	return &user, nil
}

// FindByID find a user by id
func FindByID(db digby.DB, id string) (*User, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "id", "first_name", "last_name", "email", "password", "confirmed_at", "created_at", "updated_at"
    FROM "public"."users"
    WHERE "id" = $1
  `
	digby.Log(sqlstr, id)

	var user User
	row := db.QueryRow(sqlstr, id)
	err := row.Scan(&user.ID, &user.FirstName, &user.LastName, &user.Email, &user.Password, &user.ConfirmedAt, &user.CreatedAt, &user.UpdatedAt)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, ErrUserNotFound
		}
		return nil, err
	}

	return &user, nil
}

// FindOne find one user by a condition
func FindOne(db digby.DB, where *WhereClause) (*User, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
  SELECT "id", "first_name", "last_name", "email", "password", "confirmed_at", "created_at", "updated_at"
  FROM "public"."users"
  WHERE ` + where.condition
	digby.Log(sqlstr, where.params...)

	var user User
	row := db.QueryRow(sqlstr, where.params...)
	if e := row.Scan(&user.ID, &user.FirstName, &user.LastName, &user.Email, &user.Password, &user.ConfirmedAt, &user.CreatedAt, &user.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrUserNotFound
		}
		return nil, e
	}

	return &user, nil
}

// FindMany find many "user"'s by a given condition
func FindMany(db digby.DB, where *WhereClause) ([]*User, error) {
	users := []*User{}

	// sql select query, primary key provided by sequence
	sqlstr := `
  SELECT "id", "first_name", "last_name", "email", "password", "confirmed_at", "created_at", "updated_at"
  FROM "public"."users"
  WHERE ` + where.condition
	digby.Log(sqlstr, where.params...)

	rows, err := db.Query(sqlstr, where.params...)
	if err != nil {
		return users, err
	}
	defer rows.Close()

	for rows.Next() {
		var user User
		if e := rows.Scan(&user.ID, &user.FirstName, &user.LastName, &user.Email, &user.Password, &user.ConfirmedAt, &user.CreatedAt, &user.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return users, ErrUserNotFound
			}
			return users, err
		}
		users = append(users, &user)
	}
	if rows.Err() != nil {
		return users, rows.Err()
	}

	return users, nil
}

// Update a "user" in "public"."users" by its "id"
func Update(db digby.DB, id string, userInput *UserInput) (*User, error) {
	fields := getColumns(userInput)

	// don't update the primary key
	delete(fields, "id")

	// prepare the slices
	_c, _i, _v := digby.Slice(fields, 1)

	// sql query
	sqlstr := `UPDATE "public"."users" SET (` +
		strings.Join(_c, ", ") +
		`) = (` +
		strings.Join(_i, ", ") +
		`)
    WHERE "id" = $1
    RETURNING "id", "first_name", "last_name", "email", "password", "confirmed_at", "created_at", "updated_at"`

	// setup query
	values := append([]interface{}{&id}, _v...)
	digby.Log(sqlstr, values...)

	// run the query
	var user User
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&user.ID, &user.FirstName, &user.LastName, &user.Email, &user.Password, &user.ConfirmedAt, &user.CreatedAt, &user.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrUserNotFound
		}
		return nil, e
	}

	return &user, nil
}

// UpdateByEmail find a User
func UpdateByEmail(db digby.DB, email string, userInput *UserInput) (*User, error) {
	fields := getColumns(userInput)

	// don't update the keys
	delete(fields, "email")

	// prepare the slices
	_c, _i, _v := digby.Slice(fields, 1)

	// sql query
	sqlstr := `UPDATE "public"."users" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE "email" = $1 ` +
		`RETURNING "id", "first_name", "last_name", "email", "password", "confirmed_at", "created_at", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, email)
	values = append(values, _v...)
	digby.Log(sqlstr, values...)

	// run the query
	var user User
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&user.ID, &user.FirstName, &user.LastName, &user.Email, &user.Password, &user.ConfirmedAt, &user.CreatedAt, &user.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrUserNotFound
		}
		return nil, e
	}

	return &user, nil
}

// UpdateMany rows in "public"."users" by a given condition
func UpdateMany(db digby.DB, where *WhereClause, userInput *UserInput) ([]*User, error) {
	users := []*User{}

	// prepare the slices
	_c, _i, _v := digby.Slice(getColumns(userInput), len(where.params))

	// sql query
	sqlstr := `UPDATE "public"."users" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE ` + where.condition + ` ` +
		`RETURNING "id", "first_name", "last_name", "email", "password", "confirmed_at", "created_at", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, where.params...)
	values = append(values, _v...)
	digby.Log(sqlstr, values...)

	// run query
	rows, err := db.Query(sqlstr, values...)
	if err != nil {
		return users, err
	}
	defer rows.Close()

	for rows.Next() {
		var user User
		if e := rows.Scan(&user.ID, &user.FirstName, &user.LastName, &user.Email, &user.Password, &user.ConfirmedAt, &user.CreatedAt, &user.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return users, ErrUserNotFound
			}
			return users, err
		}
		users = append(users, &user)
	}
	if rows.Err() != nil {
		return users, rows.Err()
	}

	return users, nil
}

// Delete a "user" from the "public"."users" table
func Delete(db digby.DB, id string) error {
	// sql query
	sqlstr := `DELETE FROM "public"."users" WHERE "id" = $1`
	digby.Log(sqlstr, id)

	// run query
	if _, e := db.Exec(sqlstr, id); e != nil {
		if e == pgx.ErrNoRows {
			return ErrUserNotFound
		}
		return e
	}

	return nil
}

// DeleteByEmail deletes a "user"
func DeleteByEmail(db digby.DB, email string) error {
	// sql delete query
	sqlstr := `DELETE FROM "public"."users" WHERE "email" = $1`
	digby.Log(sqlstr, email)

	if _, e := db.Exec(sqlstr, email); e != nil {
		if e == pgx.ErrNoRows {
			return ErrUserNotFound
		}
		return e
	}

	return nil
}

// DeleteMany delete many "user"'s by the given condition
func DeleteMany(db digby.DB, where *WhereClause) error {
	// sql select query, primary key provided by sequence
	sqlstr := `DELETE FROM "public"."users" WHERE ` + where.condition
	digby.Log(sqlstr, where.params...)

	if _, e := db.Exec(sqlstr, where.params...); e != nil {
		return e
	}

	return nil
}

// Upsert the "user" by its "id".
func Upsert(db digby.DB, userInput *UserInput) (*User, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := digby.Slice(getColumns(userInput), 0)

	// sql query
	sqlstr := `INSERT INTO "public"."users" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "id", "first_name", "last_name", "email", "password", "confirmed_at", "created_at", "updated_at"`
	digby.Log(sqlstr, _v...)

	// run query
	var user User
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&user.ID, &user.FirstName, &user.LastName, &user.Email, &user.Password, &user.ConfirmedAt, &user.CreatedAt, &user.UpdatedAt); e != nil {
		return nil, e
	}

	return &user, nil
}

// UpsertByEmail find a "User"
func UpsertByEmail(db digby.DB, userInput *UserInput) (*User, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := digby.Slice(getColumns(userInput), 0)

	// sql query
	sqlstr := `INSERT INTO "public"."users" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT (email) ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "id", "first_name", "last_name", "email", "password", "confirmed_at", "created_at", "updated_at"`
	digby.Log(sqlstr, _v...)

	// run query
	var user User
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&user.ID, &user.FirstName, &user.LastName, &user.Email, &user.Password, &user.ConfirmedAt, &user.CreatedAt, &user.UpdatedAt); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &user, nil
}

package historicals

import (
	"encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/pogo/testgambit"
	"github.com/matthewmueller/pogo/testgambit/enum"
	uuid "github.com/satori/go.uuid"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrHistoricalNotFound returned if the historical is not found
var ErrHistoricalNotFound = errors.New("historical not found")

// columns in `"1"."historicals"`
type columns struct {
	ID        *string        `json:"id,omitempty"`
	Timestamp *time.Time     `json:"timestamp,omitempty"`
	Exchange  *enum.Exchange `json:"exchange,omitempty"`
	Currency  *enum.Currency `json:"currency,omitempty"`
	High      *int           `json:"high,omitempty"`
	Low       *int           `json:"low,omitempty"`
	Open      *int           `json:"open,omitempty"`
	Close     *int           `json:"close,omitempty"`
	CreatedAt *time.Time     `json:"created_at,omitempty"`
}

// Historical fluent API
type Historical struct {
	columns *columns
}

// New `"1"."historicals"` API
func New() *Historical {
	return &Historical{&columns{}}
}

// ID sets the `id`
func (historical *Historical) ID(id uuid.UUID) *Historical {
	historical.columns.ID = testgambit.DecodeUUID(id)
	return historical
}

// GetID returns the `id` if set
func (historical *Historical) GetID() (id *uuid.UUID) {
	return testgambit.EncodeUUID(historical.columns.ID)
}

// Timestamp sets the `timestamp`
func (historical *Historical) Timestamp(timestamp time.Time) *Historical {
	historical.columns.Timestamp = &timestamp
	return historical
}

// GetTimestamp returns the `timestamp` if set
func (historical *Historical) GetTimestamp() (timestamp *time.Time) {
	return historical.columns.Timestamp
}

// Exchange sets the `exchange`
func (historical *Historical) Exchange(exchange enum.Exchange) *Historical {
	historical.columns.Exchange = &exchange
	return historical
}

// GetExchange returns the `exchange` if set
func (historical *Historical) GetExchange() (exchange *enum.Exchange) {
	return historical.columns.Exchange
}

// Currency sets the `currency`
func (historical *Historical) Currency(currency enum.Currency) *Historical {
	historical.columns.Currency = &currency
	return historical
}

// GetCurrency returns the `currency` if set
func (historical *Historical) GetCurrency() (currency *enum.Currency) {
	return historical.columns.Currency
}

// High sets the `high`
func (historical *Historical) High(high int) *Historical {
	historical.columns.High = &high
	return historical
}

// GetHigh returns the `high` if set
func (historical *Historical) GetHigh() (high *int) {
	return historical.columns.High
}

// Low sets the `low`
func (historical *Historical) Low(low int) *Historical {
	historical.columns.Low = &low
	return historical
}

// GetLow returns the `low` if set
func (historical *Historical) GetLow() (low *int) {
	return historical.columns.Low
}

// Open sets the `open`
func (historical *Historical) Open(open int) *Historical {
	historical.columns.Open = &open
	return historical
}

// GetOpen returns the `open` if set
func (historical *Historical) GetOpen() (open *int) {
	return historical.columns.Open
}

// Close sets the `close`
func (historical *Historical) Close(cls int) *Historical {
	historical.columns.Close = &cls
	return historical
}

// GetClose returns the `close` if set
func (historical *Historical) GetClose() (cls *int) {
	return historical.columns.Close
}

// CreatedAt sets the `created_at`
func (historical *Historical) CreatedAt(createdAt time.Time) *Historical {
	historical.columns.CreatedAt = &createdAt
	return historical
}

// GetCreatedAt returns the `created_at` if set
func (historical *Historical) GetCreatedAt() (createdAt *time.Time) {
	return historical.columns.CreatedAt
}

// MarshalJSON marshals the `historical` into JSON
func (historical *Historical) MarshalJSON() ([]byte, error) {
	return json.Marshal(historical.columns)
}

// UnmarshalJSON unmarshals json to a `historical`
func (historical *Historical) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, historical.columns)
}

func (historical *Historical) String() string {
	return "historical"
}

// get all the non-nil columns
func getColumns(historical *Historical) map[string]interface{} {
	columns := make(map[string]interface{})

	if historical.columns.ID != nil {
		columns["id"] = *historical.columns.ID
	}
	if historical.columns.Timestamp != nil {
		columns["timestamp"] = *historical.columns.Timestamp
	}
	if historical.columns.Exchange != nil {
		columns["exchange"] = *historical.columns.Exchange
	}
	if historical.columns.Currency != nil {
		columns["currency"] = *historical.columns.Currency
	}
	if historical.columns.High != nil {
		columns["high"] = *historical.columns.High
	}
	if historical.columns.Low != nil {
		columns["low"] = *historical.columns.Low
	}
	if historical.columns.Open != nil {
		columns["open"] = *historical.columns.Open
	}
	if historical.columns.Close != nil {
		columns["close"] = *historical.columns.Close
	}
	if historical.columns.CreatedAt != nil {
		columns["created_at"] = *historical.columns.CreatedAt
	}

	return columns
}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
	condition string
	params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
	return &WhereClause{
		condition: condition,
		params:    params,
	}
}

// Find a historical by "id"
func Find(db testgambit.DB, id uuid.UUID) (*Historical, error) {
	_id := testgambit.DecodeUUID(id)

	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "timestamp", "exchange", "currency", "high", "low", "open", "close", "created_at"
	FROM "1"."historicals"
	WHERE "id" = $1
	`
	testgambit.Log(sqlstr, _id)

	cols := &columns{}
	row := db.QueryRow(sqlstr, _id)
	if e := row.Scan(&cols.ID, &cols.Timestamp, &cols.Exchange, &cols.Currency, &cols.High, &cols.Low, &cols.Open, &cols.Close, &cols.CreatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrHistoricalNotFound
		}
		return nil, e
	}

	return &Historical{cols}, nil
}

// FindMany find many `historical`s by a given condition
func FindMany(db testgambit.DB, where *WhereClause) ([]*Historical, error) {
	var _o []*Historical

	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "timestamp", "exchange", "currency", "high", "low", "open", "close", "created_at"
	FROM "1"."historicals"
	WHERE ` + where.condition
	testgambit.Log(sqlstr, where.params...)

	rows, err := db.Query(sqlstr, where.params...)
	if err != nil {
		return _o, err
	}
	defer rows.Close()

	for rows.Next() {
		cols := &columns{}
		if e := rows.Scan(&cols.ID, &cols.Timestamp, &cols.Exchange, &cols.Currency, &cols.High, &cols.Low, &cols.Open, &cols.Close, &cols.CreatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return _o, ErrHistoricalNotFound
			}
			return _o, err
		}
		_o = append(_o, &Historical{cols})
	}
	if rows.Err() != nil {
		return _o, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	if len(_o) == 0 {
		return make([]*Historical, 0), nil
	}

	return _o, nil
}

// FindOne find one historical by a condition
func FindOne(db testgambit.DB, where *WhereClause) (*Historical, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "timestamp", "exchange", "currency", "high", "low", "open", "close", "created_at"
	FROM "1"."historicals"
	WHERE ` + where.condition
	testgambit.Log(sqlstr, where.params...)

	cols := &columns{}
	row := db.QueryRow(sqlstr, where.params...)
	if e := row.Scan(&cols.ID, &cols.Timestamp, &cols.Exchange, &cols.Currency, &cols.High, &cols.Low, &cols.Open, &cols.Close, &cols.CreatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrHistoricalNotFound
		}
		return nil, e
	}

	return &Historical{cols}, nil
}

// Insert a `historical` into the `"1"."historicals"` table.
func Insert(db testgambit.DB, historical *Historical) (*Historical, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := testgambit.Slice(getColumns(historical), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
	INSERT INTO "1"."historicals" (` + strings.Join(_c, ", ") + `)
	VALUES (` + strings.Join(_i, ", ") + `)
	RETURNING "id", "timestamp", "exchange", "currency", "high", "low", "open", "close", "created_at"
	`
	testgambit.Log(sqlstr, _v...)

	cols := &columns{}
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&cols.ID, &cols.Timestamp, &cols.Exchange, &cols.Currency, &cols.High, &cols.Low, &cols.Open, &cols.Close, &cols.CreatedAt); e != nil {
		return nil, e
	}

	return &Historical{cols}, nil
}

// Update a historical by its `id`
func Update(db testgambit.DB, id uuid.UUID, historical *Historical) (*Historical, error) {
	_id := testgambit.DecodeUUID(id)
	fields := getColumns(historical)

	// don't update the primary key
	delete(fields, "id")

	// prepare the slices
	_c, _i, _v := testgambit.Slice(fields, 1)

	// sql query
	sqlstr := `UPDATE "1"."historicals" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `)
		WHERE "id" = $1
		RETURNING "id", "timestamp", "exchange", "currency", "high", "low", "open", "close", "created_at"`

	// setup query
	values := append([]interface{}{_id}, _v...)
	testgambit.Log(sqlstr, values...)

	// run the query
	cols := &columns{}
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&cols.ID, &cols.Timestamp, &cols.Exchange, &cols.Currency, &cols.High, &cols.Low, &cols.Open, &cols.Close, &cols.CreatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrHistoricalNotFound
		}
		return nil, e
	}

	return &Historical{cols}, nil
}

// UpdateMany rows in `"1"."historicals"` by a given condition
func UpdateMany(db testgambit.DB, where *WhereClause, historical *Historical) ([]*Historical, error) {
	var _o []*Historical

	// prepare the slices
	_c, _i, _v := testgambit.Slice(getColumns(historical), len(where.params))

	// sql query
	sqlstr := `UPDATE "1"."historicals" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE ` + where.condition + ` ` +
		`RETURNING "id", "timestamp", "exchange", "currency", "high", "low", "open", "close", "created_at"`

		// setup the query
	values := []interface{}{}
	values = append(values, where.params...)
	values = append(values, _v...)
	testgambit.Log(sqlstr, values...)

	// run query
	rows, err := db.Query(sqlstr, values...)
	if err != nil {
		return _o, err
	}
	defer rows.Close()

	for rows.Next() {
		cols := &columns{}
		if e := rows.Scan(&cols.ID, &cols.Timestamp, &cols.Exchange, &cols.Currency, &cols.High, &cols.Low, &cols.Open, &cols.Close, &cols.CreatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return _o, ErrHistoricalNotFound
			}
			return _o, err
		}
		_o = append(_o, &Historical{cols})
	}
	if rows.Err() != nil {
		return _o, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	if len(_o) == 0 {
		return make([]*Historical, 0), nil
	}

	return _o, nil
}

// Delete a `historical` from the `"1"."historicals"` table
func Delete(db testgambit.DB, id uuid.UUID) error {
	_id := testgambit.DecodeUUID(id)

	// sql query
	sqlstr := `DELETE FROM "1"."historicals" WHERE "id" = $1`
	testgambit.Log(sqlstr, _id)

	// run query
	if _, e := db.Exec(sqlstr, _id); e != nil {
		if e == pgx.ErrNoRows {
			return ErrHistoricalNotFound
		}
		return e
	}

	return nil
}

// DeleteMany delete many `historical`'s by the given condition
func DeleteMany(db testgambit.DB, where *WhereClause) error {
	// sql select query, primary key provided by sequence
	sqlstr := `DELETE FROM "1"."historicals" WHERE ` + where.condition
	testgambit.Log(sqlstr, where.params...)

	if _, e := db.Exec(sqlstr, where.params...); e != nil {
		return e
	}

	return nil
}

// Upsert the `historical` by its `id`.
func Upsert(db testgambit.DB, historical *Historical) (*Historical, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := testgambit.Slice(getColumns(historical), 0)

	// sql query
	sqlstr := `INSERT INTO "1"."historicals" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "id", "timestamp", "exchange", "currency", "high", "low", "open", "close", "created_at"`
	testgambit.Log(sqlstr, _v...)

	// run query
	cols := &columns{}
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&cols.ID, &cols.Timestamp, &cols.Exchange, &cols.Currency, &cols.High, &cols.Low, &cols.Open, &cols.Close, &cols.CreatedAt); e != nil {
		return nil, e
	}

	return &Historical{cols}, nil
}

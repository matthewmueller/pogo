package postgres

import (
	"github.com/matthewmueller/pogo/db"
)

// GENERATED BY XO. DO NOT EDIT.

// Enum represents a enum.
type Enum struct {
	Name   string
	Values []*Value
}

// Value represents a enum value.
type Value struct {
	Label string
	Order int
}

// Enums runs a custom query, returning results as Enum.
func Enums(db db.DB, schema string) ([]*Enum, error) {
	var err error

	// sql query
	const sqlstr = `
    SELECT DISTINCT
		t.typname
		FROM pg_type t
		JOIN ONLY pg_namespace n ON n.oid = t.typnamespace
		JOIN ONLY pg_enum e ON t.oid = e.enumtypid
		WHERE n.nspname = $1
  `

	// run query
	// DBLog(sqlstr, schema)
	q, err := db.Query(sqlstr, schema)
	if err != nil {
		return nil, err
	}

	// load results
	res := []*Enum{}
	for q.Next() {
		e := Enum{}

		// scan
		err = q.Scan(&e.Name)
		if err != nil {
			return nil, err
		}

		res = append(res, &e)
	}
	q.Close()

	for _, re := range res {
		values, err := Values(db, schema, re.Name)
		if err != nil {
			return nil, err
		}
		re.Values = values
	}

	return res, nil
}

// Values runs a custom query, returning results as Value.
func Values(db db.DB, schema string, enum string) ([]*Value, error) {
	var err error

	// sql query
	const sqlstr = `
    SELECT
		e.enumlabel,
		e.enumsortorder::int
		FROM pg_type t
		JOIN ONLY pg_namespace n ON n.oid = t.typnamespace
		LEFT JOIN pg_enum e ON t.oid = e.enumtypid
		WHERE n.nspname = $1 AND t.typname = $2
  `

	// run query
	// DBLog(sqlstr, schema, enum)
	q, err := db.Query(sqlstr, schema, enum)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Value{}
	for q.Next() {
		ev := Value{}

		// scan
		err = q.Scan(&ev.Label, &ev.Order)
		if err != nil {
			return nil, err
		}

		res = append(res, &ev)
	}

	return res, nil
}

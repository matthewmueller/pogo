package {{$.Package}}

import (
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"

	"{{ $.Importer.Import "./" }}"
	{{- if $.HasEnums }}
	"{{ $.Importer.Import "./enum" }}"
	{{- end }}
)

// GENERATED BY POGO. DO NOT EDIT.

// Err{{$.Table.Pascal}}NotFound returned if the {{$.Table.SQLName}} is not found
var Err{{$.Table.Pascal}}NotFound = errors.New("{{$.Table.Camel}} not found")

// {{$.Table.Pascal}} result data for {{$.Table.SQLName}}
type {{$.Table.Pascal}} struct {
  {{- range $col := $.Table.Columns }}
  {{$col.Pascal}} {{if $col.Nullable}}*{{$col.Type}}{{ else }}{{$col.Type}}{{ end }} `json:"{{$col.JSONKey}},omitempty"`
  {{- end }}
}

var _ pogo.Row = (*{{$.Table.Pascal}})(nil)

// Decode implements pogo.Row
func ({{$.Table.Short}} *{{$.Table.Pascal}}) Decode({{$.Table.Camel}} interface{}) error {
  _{{$.Table.Camel}}, ok := {{$.Table.Camel}}.(*{{$.Table.Pascal}})
  if !ok {
    return fmt.Errorf(`{{$.Table.Camel}} decode: "%T" is not a "*{{$.Table.Pascal}}"`, {{$.Table.Camel}})
  }
  *_{{$.Table.Camel}} = *{{$.Table.Short}}
  return nil
}

// New {{$.Table.SQLName}} input
func New() *Input {
  return &Input{}
}

// Input data for {{$.Table.SQLName}}
type Input struct {
  {{- range $col := $.Table.Columns }}
  {{ $col.Camel }} *{{ $col.Type }}
  {{- if $col.Nullable }}
    nullable{{ $col.Pascal }} **{{ $col.Type }}
  {{- end }}
  {{- end }}
}

var _ pogo.Insertable = (*Input)(nil)

{{ range $col := $.Table.Columns }}
// {{$col.Pascal}} sets the {{$col.Name}}
func ({{$.Table.Short}} *Input) {{$col.Pascal}}({{$col.Camel}} {{$col.Type}}) *Input {
  {{$.Table.Short}}.{{$col.Camel}} = &{{$col.Camel}}
  return {{$.Table.Short}}
}

{{- if $col.Nullable }}
// Nullable{{ $col.Pascal }} will set the {{ $col.Name }} to NULL if `{{$col.Camel}}` is null
func ({{$.Table.Short}} *Input) Nullable{{ $col.Pascal }}({{$col.Camel}} *{{ $col.Type }}) *Input {
  {{$.Table.Short}}.nullable{{ $col.Pascal }} = &{{$col.Camel}}
  return {{$.Table.Short}}
}
{{- end }}
{{- end }}

// MarshalJSON marshals the "{{$.Table.Camel}}" into JSON
func ({{$.Table.Short}} *Input) MarshalJSON() ([]byte, error) {
  return json.Marshal({{$.Table.Short}})
}

// UnmarshalJSON unmarshals json to a "{{$.Table.Camel}}"
func ({{$.Table.Short}} *Input) UnmarshalJSON(data []byte) error {
  return json.Unmarshal(data, {{$.Table.Short}})
}

// String of the input
// TODO: make this more useful
func ({{$.Table.Short}} *Input) String() string {
  return `{{$.Table.SQLName}}`
}

func ({{$.Table.Short}} *Input) columns() map[string]interface{} {
  columns := make(map[string]interface{})

  {{ range $col := $.Table.Columns }}
    {{- if $col.Nullable }}
      if {{$.Table.Short}}.nullable{{ $col.Pascal }} != nil {
        columns["{{$col.Name}}"] = *{{$.Table.Short}}.nullable{{ $col.Pascal }}
      }
    {{- end }}
    if {{$.Table.Short}}.{{$col.Camel}} != nil {
      columns["{{$col.Name}}"] = *{{$.Table.Short}}.{{$col.Camel}}
    }
  {{ end }}

  return columns
}

// Insert implements pogo.Insertable
func ({{$.Table.Short}} *Input) Insert(db pogo.DB) (pogo.Row, error) {
  return Insert(db, {{$.Table.Short}})
}

// NewFilter creates a new filter
func NewFilter() *Filter {
  return &Filter{}
}

// Filter filters for {{$.Table.SQLName}}
type Filter struct {
	formats []string
	values  []interface{}
  error   error
}

var _ pogo.Condition = (*Filter)(nil)

// Clause fn
func (f *Filter) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "WHERE",
		Format: strings.Join(f.formats, " AND "),
		Params: f.values,
    Error:  f.error,
	}
}

// And filter
// func (f *Filter) And(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " AND "))
//   return f
// }

// Or filter
// func (f *Filter) Or(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " OR "))
//   return f
// }

{{ range $filter := $.Table.Filters }}
{{ range $field := $filter.Fields }}
// {{ $field.Pascal }} {{ $field.Description }}
func (f *Filter) {{ $field.Pascal }}(v {{ $field.Type }}) *Filter {
  {{- if $field.Spread }}
  var rs []string
  if len(v) == 0 {
    f.formats = append(f.formats, `false`)
    return f
  }
	for range v {
		rs = append(rs, "%s")
	}
  f.formats = append(f.formats, fmt.Sprintf(`{{ $field.Format }}`, strings.Join(rs, `{{ $field.Spread }}`)))
  for _, i := range v {
    f.values = append(f.values, {{ $field.Coerce "i" }})
  }
  {{- else }}
  {{- if $field.Nullable }}
  if v == nil {
    f.formats = append(f.formats, `{{ $field.NullFormat }}`)
    return f
  }
  {{- end }}
  f.formats = append(f.formats, `{{ $field.Format }}`)
	f.values = append(f.values, {{ $field.Coerce "v" }})
  {{- end }}
	return f
}
{{- end }}
{{- end }}

// OrderBy specificies the ORDERBy BY <order>
type OrderBy string

const (
	// ASC sorts by ascending order
	ASC OrderBy = "ASC"

	// DESC sorts by descending order
	DESC OrderBy = "DESC"
)

// NewOrder fn
func NewOrder() *Orderer {
	return &Orderer{}
}

var _ pogo.Condition = (*Orderer)(nil)

// Orderer orders the given fields
type Orderer struct {
	formats []string
}

// Clause fn
func (o *Orderer) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "ORDER BY",
		Format: strings.Join(o.formats, ", "),
	}
}

{{ range $field := $.Table.Orders }}
// {{ $field.Pascal }} sorts {{ $field.Name }} by an expression
func (o *Orderer) {{ $field.Pascal }}(order OrderBy) *Orderer {
	o.formats = append(o.formats, fmt.Sprintf(`{{ $field.Format }}`, order))
	return o
}
{{- end }}

{{/* Model struct */}}
// Model is an empty struct that has all the methods.
// It's primarly used for embedding the methods
// into higher-level models.
type Model struct { }

{{/* Function: Insert */}}
// Insert a "{{$.Table.SQLName}}" into the {{$.Table.SQLName}}
func Insert(db pogo.DB, {{$.Table.Camel}} *Input) (*{{$.Table.Pascal}}, error) {
  // get all the non-nil columns and prepare them for the query
  _c, _i, _v := slice({{$.Table.Camel}}.columns(), 0)
  _ = _i

  // sql insert query, primary key provided by sequence
  var sqlstr string
  if len(_c) == 0 {
    sqlstr = `
      INSERT INTO {{$.Table.SQLName}}
      DEFAULT VALUES
      RETURNING {{$.Table.Returning}}
    `
  } else {
    sqlstr = `
      INSERT INTO {{$.Table.SQLName}} (` + strings.Join(_c, ", ") + `)
      VALUES (` + strings.Join(_i, ", ") + `)
      RETURNING {{$.Table.Returning}}
    `
  }

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* Model: Insert */}}
// Insert a "{{$.Table.SQLName}}" into the {{$.Table.SQLName}}
func (*Model) Insert(db pogo.DB, {{$.Table.Camel}} *Input) (*{{$.Table.Pascal}}, error) {
  // get all the non-nil columns and prepare them for the query
  _c, _i, _v := slice({{$.Table.Camel}}.columns(), 0)
  _ = _i

  // sql insert query, primary key provided by sequence
  var sqlstr string
  if len(_c) == 0 {
    sqlstr = `
      INSERT INTO {{$.Table.SQLName}}
      DEFAULT VALUES
      RETURNING {{$.Table.Returning}}
    `
  } else {
    sqlstr = `
      INSERT INTO {{$.Table.SQLName}} (` + strings.Join(_c, ", ") + `)
      VALUES (` + strings.Join(_i, ", ") + `)
      RETURNING {{$.Table.Returning}}
    `
  }

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* Function: InsertMany */}}
// InsertMany "{{$.Table.SQLName}}" into the {{$.Table.SQLName}}
func InsertMany(db pogo.DB, {{$.Table.PluralCamel}} ...*Input) ([]*{{$.Table.Pascal}}, error) {
	_{{$.Table.PluralCamel}} := []*{{$.Table.Pascal}}{}
	for _, {{$.Table.Camel}} := range {{$.Table.PluralCamel}} {
		_{{$.Table.Camel}}, err := Insert(db, {{$.Table.Camel}})
		if err != nil {
			return _{{$.Table.PluralCamel}}, err
		}
		_{{$.Table.PluralCamel}} = append(_{{$.Table.PluralCamel}}, _{{$.Table.Camel}})
	}
	return _{{$.Table.PluralCamel}}, nil
}

{{/* Model: InsertMany */}}
// InsertMany "{{$.Table.SQLName}}" into the {{$.Table.SQLName}}
func (*Model) InsertMany(db pogo.DB, {{$.Table.PluralCamel}} ...*Input) ([]*{{$.Table.Pascal}}, error) {
	_{{$.Table.PluralCamel}} := []*{{$.Table.Pascal}}{}
	for _, {{$.Table.Camel}} := range {{$.Table.PluralCamel}} {
		_{{$.Table.Camel}}, err := Insert(db, {{$.Table.Camel}})
		if err != nil {
			return _{{$.Table.PluralCamel}}, err
		}
		_{{$.Table.PluralCamel}} = append(_{{$.Table.PluralCamel}}, _{{$.Table.Camel}})
	}
	return _{{$.Table.PluralCamel}}, nil
}

{{/* Function: Find a row by a set of conditions */}}
// Find a `{{$.Table.Pascal}}` by some conditions.
func Find(db pogo.DB, conds ...pogo.Condition) (*{{$.Table.Pascal}}, error) {
  _s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

  // sql select query, primary key provided by sequence
  sqlstr := `SELECT {{.Table.Select}} ` +
    `FROM {{$.Table.SQLName}} ` +
    _s

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if pogo.IsNoRows(e) {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* Model: Find a row by a set of conditions */}}
// Find a `{{$.Table.Pascal}}` by some conditions.
func (*Model) Find(db pogo.DB, conds ...pogo.Condition) (*{{$.Table.Pascal}}, error) {
  _s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

  // sql select query, primary key provided by sequence
  sqlstr := `SELECT {{.Table.Select}} ` +
    `FROM {{$.Table.SQLName}} ` +
    _s

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if pogo.IsNoRows(e) {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* FindBy Primary Key */}}
{{ if .Table.PrimaryKey }}
{{ $pk := .Table.PrimaryKey }}
{{/* Function: FindBy(PK) */}}
// FindBy{{$pk.Method}} a `{{$.Table.Pascal}}` by some conditions.
func FindBy{{$pk.Method}}(db pogo.DB, {{$pk.Params}}) (*{{$.Table.Pascal}}, error) {
  // sql select query, primary key provided by sequence
  sqlstr := `
    SELECT {{.Table.Select}}
    FROM {{$.Table.SQLName}}
    WHERE {{$pk.Where}}
  `

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, {{$pk.Variables}})
  }

  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, {{$pk.Variables}})
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if pogo.IsNoRows(e) {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* Model: FindBy(PK) */}}
// FindBy{{$pk.Method}} a `{{$.Table.Pascal}}` by some conditions.
func (*Model) FindBy{{$pk.Method}}(db pogo.DB, {{$pk.Params}}) (*{{$.Table.Pascal}}, error) {
  // sql select query, primary key provided by sequence
  sqlstr := `
    SELECT {{.Table.Select}}
    FROM {{$.Table.SQLName}}
    WHERE {{$pk.Where}}
  `

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, {{$pk.Variables}})
  }

  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, {{$pk.Variables}})
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if pogo.IsNoRows(e) {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}
{{ end }}

{{/* FindBy Unique column */}}
{{ range $idx := .Table.Indexes }}
{{- if (and $idx.IsUnique (not $idx.IsPrimary)) }}
{{/* Function: FindBy(FK) */}}
// FindBy{{$idx.Method}} find a {{$.Table.Camel}} by {{$idx.Description}}
func FindBy{{$idx.Method}}(db pogo.DB, {{$idx.Params}}) (*{{$.Table.Pascal}}, error) {
  // sql select query, primary key provided by sequence
  sqlstr := `
    SELECT {{$.Table.Select}}
    FROM {{$.Table.SQLName}}
    WHERE {{$idx.Where}}
  `

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, {{$idx.Variables}})
  }

  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, {{$idx.Variables}})
  err := row.Scan({{$.Table.Scan}})
  if err != nil {
    if pogo.IsNoRows(err) {
      return nil,  Err{{$.Table.Pascal}}NotFound
    }
    return nil, err
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* Model: FindBy(FK) */}}
// FindBy{{$idx.Method}} find a {{$.Table.Camel}} by {{$idx.Description}}
func (*Model) FindBy{{$idx.Method}}(db pogo.DB, {{$idx.Params}}) (*{{$.Table.Pascal}}, error) {
  // sql select query, primary key provided by sequence
  sqlstr := `
    SELECT {{$.Table.Select}}
    FROM {{$.Table.SQLName}}
    WHERE {{$idx.Where}}
  `

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, {{$idx.Variables}})
  }

  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, {{$idx.Variables}})
  err := row.Scan({{$.Table.Scan}})
  if err != nil {
    if pogo.IsNoRows(err) {
      return nil,  Err{{$.Table.Pascal}}NotFound
    }
    return nil, err
  }
  return &_{{$.Table.Camel}}, nil
}
{{- end }}
{{ end }}

{{/* Function: FindMany by a condition */}}
// FindMany finds many {{$.Table.SQLName}} by a condition
func FindMany(db pogo.DB, conds ...pogo.Condition) ([]*{{$.Table.Pascal}}, error) {
  {{$.Table.PluralCamel}} := []*{{$.Table.Pascal}}{}

  _s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return {{$.Table.PluralCamel}}, err
	}

  // sql select query, primary key provided by sequence
  sqlstr := `SELECT {{.Table.Select}} ` +
    `FROM {{$.Table.SQLName}} ` +
    _s

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  rows, err := db.Query(sqlstr, _v...)
  if err != nil {
    return {{$.Table.PluralCamel}}, err
  }
  defer rows.Close()

  for rows.Next() {
    var _{{$.Table.Camel}} {{$.Table.Pascal}}
    if e := rows.Scan({{$.Table.Scan}}); e != nil {
      if pogo.IsNoRows(e) {
        return {{$.Table.PluralCamel}}, Err{{$.Table.Pascal}}NotFound
      }
      return {{$.Table.PluralCamel}}, err
    }
    {{$.Table.PluralCamel}} = append({{$.Table.PluralCamel}}, &_{{$.Table.Camel}})
  }
  if rows.Err() != nil {
    return {{$.Table.PluralCamel}}, rows.Err()
  }

  return {{$.Table.PluralCamel}}, nil
}

{{/* Model: FindMany by a condition */}}
// FindMany finds many {{$.Table.SQLName}} by a condition
func (*Model) FindMany(db pogo.DB, conds ...pogo.Condition) ([]*{{$.Table.Pascal}}, error) {
  {{$.Table.PluralCamel}} := []*{{$.Table.Pascal}}{}

  _s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return {{$.Table.PluralCamel}}, err
	}

  // sql select query, primary key provided by sequence
  sqlstr := `SELECT {{.Table.Select}} ` +
    `FROM {{$.Table.SQLName}} ` +
    _s

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  rows, err := db.Query(sqlstr, _v...)
  if err != nil {
    return {{$.Table.PluralCamel}}, err
  }
  defer rows.Close()

  for rows.Next() {
    var _{{$.Table.Camel}} {{$.Table.Pascal}}
    if e := rows.Scan({{$.Table.Scan}}); e != nil {
      if pogo.IsNoRows(e) {
        return {{$.Table.PluralCamel}}, Err{{$.Table.Pascal}}NotFound
      }
      return {{$.Table.PluralCamel}}, err
    }
    {{$.Table.PluralCamel}} = append({{$.Table.PluralCamel}}, &_{{$.Table.Camel}})
  }
  if rows.Err() != nil {
    return {{$.Table.PluralCamel}}, rows.Err()
  }

  return {{$.Table.PluralCamel}}, nil
}

{{/* Function: Update matching rows by a condition, returning 1 result */}}
// Update "{{$.Table.SQLName}}" rows in {{$.Table.SQLName}} by a condition, returning 1 result
func Update(db pogo.DB, {{$.Table.Camel}} *Input, conds ...pogo.Condition) (*{{$.Table.Pascal}}, error) {
  _s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

  fields := {{$.Table.Camel}}.columns()

  // prepare the slices
  _c, _i, _v2 := slice(fields, len(_v))
  _v = append(_v, _v2...)

  // setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

  // return an error if no update input is provided
  if len(_u) == 0 {
    return nil, errors.New("{{$.Package}}.Update: no input provided")
  }

	// sql query
	sqlstr := `UPDATE {{$.Table.SQLName}} SET ` +
		strings.Join(_u, ", ") + ` ` +
		_s + ` ` +
		`RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  // run the query
  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if pogo.IsNoRows(e) {
      return nil,  Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* Model: Update matching rows by a condition, returning 1 result */}}
// Update "{{$.Table.SQLName}}" rows in {{$.Table.SQLName}} by a condition, returning 1 result
func (*Model) Update(db pogo.DB, {{$.Table.Camel}} *Input, conds ...pogo.Condition) (*{{$.Table.Pascal}}, error) {
  _s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

  fields := {{$.Table.Camel}}.columns()

  // prepare the slices
  _c, _i, _v2 := slice(fields, len(_v))
  _v = append(_v, _v2...)

  // setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

  // return an error if no update input is provided
  if len(_u) == 0 {
    return nil, errors.New("{{$.Package}}.Update: no input provided")
  }

	// sql query
	sqlstr := `UPDATE {{$.Table.SQLName}} SET ` +
		strings.Join(_u, ", ") + ` ` +
		_s + ` ` +
		`RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  // run the query
  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if pogo.IsNoRows(e) {
      return nil,  Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* Function: Update matching rows by a condition, returning 1 result */}}
// UpdateMany updates "{{$.Table.SQLName}}" rows in {{$.Table.SQLName}} by conditions, returning all results
func UpdateMany(db pogo.DB, {{$.Table.Camel}} *Input, conds ...pogo.Condition) ([]*{{$.Table.Pascal}}, error) {
  {{$.Table.PluralCamel}} := []*{{$.Table.Pascal}}{}

  _s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

  fields := {{$.Table.Camel}}.columns()

  // prepare the slices
  _c, _i, _v2 := slice(fields, len(_v))
  _v = append(_v, _v2...)

  // setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

  // return an error if no update input is provided
  if len(_u) == 0 {
    return nil, errors.New("{{$.Package}}.UpdateMany: no input provided")
  }

	// sql query
	sqlstr := `UPDATE {{$.Table.SQLName}} SET ` +
		strings.Join(_u, ", ") + ` ` +
		_s + ` ` +
		`RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  rows, err := db.Query(sqlstr, _v...)
  if err != nil {
    return {{$.Table.PluralCamel}}, err
  }
  defer rows.Close()

  for rows.Next() {
    var _{{$.Table.Camel}} {{$.Table.Pascal}}
    if e := rows.Scan({{$.Table.Scan}}); e != nil {
      if pogo.IsNoRows(e) {
        return {{$.Table.PluralCamel}}, Err{{$.Table.Pascal}}NotFound
      }
      return {{$.Table.PluralCamel}}, err
    }
    {{$.Table.PluralCamel}} = append({{$.Table.PluralCamel}}, &_{{$.Table.Camel}})
  }
  if rows.Err() != nil {
    return {{$.Table.PluralCamel}}, rows.Err()
  }

  return {{$.Table.PluralCamel}}, nil
}

{{/* Model: Update matching rows by a condition, returning 1 result */}}
// UpdateMany updates "{{$.Table.SQLName}}" rows in {{$.Table.SQLName}} by conditions, returning all results
func (*Model) UpdateMany(db pogo.DB, {{$.Table.Camel}} *Input, conds ...pogo.Condition) ([]*{{$.Table.Pascal}}, error) {
  {{$.Table.PluralCamel}} := []*{{$.Table.Pascal}}{}

  _s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

  fields := {{$.Table.Camel}}.columns()

  // prepare the slices
  _c, _i, _v2 := slice(fields, len(_v))
  _v = append(_v, _v2...)

  // setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

  // return an error if no update input is provided
  if len(_u) == 0 {
    return nil, errors.New("{{$.Package}}.UpdateMany: no input provided")
  }

	// sql query
	sqlstr := `UPDATE {{$.Table.SQLName}} SET ` +
		strings.Join(_u, ", ") + ` ` +
		_s + ` ` +
		`RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  rows, err := db.Query(sqlstr, _v...)
  if err != nil {
    return {{$.Table.PluralCamel}}, err
  }
  defer rows.Close()

  for rows.Next() {
    var _{{$.Table.Camel}} {{$.Table.Pascal}}
    if e := rows.Scan({{$.Table.Scan}}); e != nil {
      if pogo.IsNoRows(e) {
        return {{$.Table.PluralCamel}}, Err{{$.Table.Pascal}}NotFound
      }
      return {{$.Table.PluralCamel}}, err
    }
    {{$.Table.PluralCamel}} = append({{$.Table.PluralCamel}}, &_{{$.Table.Camel}})
  }
  if rows.Err() != nil {
    return {{$.Table.PluralCamel}}, rows.Err()
  }

  return {{$.Table.PluralCamel}}, nil
}

{{/* Update by primary key */}}
{{ if .Table.PrimaryKey }}
{{ $pk := .Table.PrimaryKey }}
{{/* Function: UpdateBy(PK) */}}
// UpdateBy{{$pk.Method}} a "{{$.Table.Camel}}" in {{$.Table.SQLName}} by its "{{$pk.ColumnList}}"
func UpdateBy{{$pk.Method}}(db pogo.DB, {{$pk.Params}}, {{$.Table.Camel}} *Input) (*{{$.Table.Pascal}}, error) {
  // add values to input, overriding existing keys if present in the input
  {{$.Table.Camel}} = {{$.Table.Camel}}{{ range $col := $pk.Columns }}.{{$col.Pascal}}({{$col.Camel}}){{ end }}


  // get the columns
  fields := {{$.Table.Camel}}.columns()

  // don't update the keys
  {{- range $col := $pk.Columns}}
  delete(fields, "{{$col.Name}}")
  {{- end }}

  // prepare the slices
  _c, _i, _v := slice(fields, {{len $pk.Columns}})

  // setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

  // return an error if no update input is provided
  if len(_u) == 0 {
    return nil, errors.New("{{$.Package}}.UpdateBy{{$pk.Method}}: no input provided")
  }

  // sql query
  sqlstr := `UPDATE {{$.Table.SQLName}} SET ` +
    strings.Join(_u, ", ") + ` ` +
    `WHERE {{$pk.Where}} ` +
    `RETURNING {{$.Table.Returning}}`

  // setup the query
  values := []interface{}{}
  {{- range $col := $pk.Columns}}
  values = append(values, {{$col.Camel}})
  {{- end }}
  values = append(values, _v...)

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, values...)
  }

  // run the query
  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, values...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if pogo.IsNoRows(e) {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* Model: UpdateBy(PK) */}}
// UpdateBy{{$pk.Method}} a "{{$.Table.Camel}}" in {{$.Table.SQLName}} by its "{{$pk.ColumnList}}"
func (*Model) UpdateBy{{$pk.Method}}(db pogo.DB, {{$pk.Params}}, {{$.Table.Camel}} *Input) (*{{$.Table.Pascal}}, error) {
  // add values to input, overriding existing keys if present in the input
  {{$.Table.Camel}} = {{$.Table.Camel}}{{ range $col := $pk.Columns }}.{{$col.Pascal}}({{$col.Camel}}){{ end }}


  // get the columns
  fields := {{$.Table.Camel}}.columns()

  // don't update the keys
  {{- range $col := $pk.Columns}}
  delete(fields, "{{$col.Name}}")
  {{- end }}

  // prepare the slices
  _c, _i, _v := slice(fields, {{len $pk.Columns}})

  // setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

  // return an error if no update input is provided
  if len(_u) == 0 {
    return nil, errors.New("{{$.Package}}.UpdateBy{{$pk.Method}}: no input provided")
  }

  // sql query
  sqlstr := `UPDATE {{$.Table.SQLName}} SET ` +
    strings.Join(_u, ", ") + ` ` +
    `WHERE {{$pk.Where}} ` +
    `RETURNING {{$.Table.Returning}}`

  // setup the query
  values := []interface{}{}
  {{- range $col := $pk.Columns}}
  values = append(values, {{$col.Camel}})
  {{- end }}
  values = append(values, _v...)

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, values...)
  }

  // run the query
  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, values...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if pogo.IsNoRows(e) {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}
{{ end }}

{{/* Update by unique indexes */}}
{{ range $idx := .Table.Uniques }}
{{/* Function: UpdateBy(FK) */}}
// UpdateBy{{$idx.Method}} find a {{$.Table.Pascal}}
func UpdateBy{{$idx.Method}}(db pogo.DB, {{$idx.Params}}, {{$.Table.Camel}} *Input) (*{{$.Table.Pascal}}, error) {
  // add values to input, overriding existing keys if present in the input
  {{$.Table.Camel}} = {{$.Table.Camel}}{{ range $col := $idx.Columns }}.{{$col.Pascal}}({{$col.Camel}}){{ end }}

  // get the columns
  fields := {{$.Table.Camel}}.columns()

  // don't update the keys
  {{- range $col := $idx.Columns}}
  delete(fields, "{{$col.Name}}")
  {{- end }}

  // prepare the slices
  _c, _i, _v := slice(fields, {{len $idx.Columns}})

  // setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

  // return an error if no update input is provided
  if len(_u) == 0 {
    return nil, errors.New("{{$.Package}}.UpdateBy{{$idx.Method}}: no input provided")
  }

  // sql query
  sqlstr := `UPDATE {{$.Table.SQLName}} SET ` +
    strings.Join(_u, ", ") + ` ` +
    `WHERE {{$idx.Where}} ` +
    `RETURNING {{$.Table.Returning}}`

  // setup the query
  values := []interface{}{}
  {{- range $col := $idx.Columns}}
  values = append(values, {{$col.Camel}})
  {{- end }}
  values = append(values, _v...)

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, values...)
  }

  // run the query
  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, values...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if pogo.IsNoRows(e) {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* Function: UpdateBy(FK) */}}
// UpdateBy{{$idx.Method}} find a {{$.Table.Pascal}}
func (*Model) UpdateBy{{$idx.Method}}(db pogo.DB, {{$idx.Params}}, {{$.Table.Camel}} *Input) (*{{$.Table.Pascal}}, error) {
  // add values to input, overriding existing keys if present in the input
  {{$.Table.Camel}} = {{$.Table.Camel}}{{ range $col := $idx.Columns }}.{{$col.Pascal}}({{$col.Camel}}){{ end }}

  // get the columns
  fields := {{$.Table.Camel}}.columns()

  // don't update the keys
  {{- range $col := $idx.Columns}}
  delete(fields, "{{$col.Name}}")
  {{- end }}

  // prepare the slices
  _c, _i, _v := slice(fields, {{len $idx.Columns}})

  // setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

  // return an error if no update input is provided
  if len(_u) == 0 {
    return nil, errors.New("{{$.Package}}.UpdateBy{{$idx.Method}}: no input provided")
  }

  // sql query
  sqlstr := `UPDATE {{$.Table.SQLName}} SET ` +
    strings.Join(_u, ", ") + ` ` +
    `WHERE {{$idx.Where}} ` +
    `RETURNING {{$.Table.Returning}}`

  // setup the query
  values := []interface{}{}
  {{- range $col := $idx.Columns}}
  values = append(values, {{$col.Camel}})
  {{- end }}
  values = append(values, _v...)

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, values...)
  }

  // run the query
  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, values...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if pogo.IsNoRows(e) {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}
{{ end }}

{{/* Function: Delete row(s) by a set of conditions, returning the first result */}}
// Delete `{{$.Table.Pascal}}`s by some conditions. Returns the first result.
// Warning: This can delete more than 1 row
func Delete(db pogo.DB, conds ...pogo.Condition) (*{{$.Table.Pascal}}, error) {
  _s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

  // sql delete query
  sqlstr := `DELETE FROM {{$.Table.SQLName}} ` +
    _s + ` ` +
    `RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if pogo.IsNoRows(e) {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* Model: Delete row(s) by a set of conditions, returning the first result */}}
// Delete `{{$.Table.Pascal}}`s by some conditions. Returns the first result.
// Warning: This can delete more than 1 row
func (*Model) Delete(db pogo.DB, conds ...pogo.Condition) (*{{$.Table.Pascal}}, error) {
  _s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

  // sql delete query
  sqlstr := `DELETE FROM {{$.Table.SQLName}} ` +
    _s + ` ` +
    `RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if pogo.IsNoRows(e) {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* Function: Delete many rows by a condiation, returning all of them */}}
// DeleteMany `{{$.Table.Pascal}}`s by some conditions, returning all results.
func DeleteMany(db pogo.DB, conds ...pogo.Condition) ([]*{{$.Table.Pascal}}, error) {
  {{$.Table.PluralCamel}} := []*{{$.Table.Pascal}}{}

  _s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return {{$.Table.PluralCamel}}, err
	}

  // sql delete query
  sqlstr := `DELETE FROM {{$.Table.SQLName}} ` +
    _s + ` ` +
    `RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  rows, err := db.Query(sqlstr, _v...)
  if err != nil {
    return {{$.Table.PluralCamel}}, err
  }
  defer rows.Close()

  for rows.Next() {
    var _{{$.Table.Camel}} {{$.Table.Pascal}}
    if e := rows.Scan({{$.Table.Scan}}); e != nil {
      if pogo.IsNoRows(e) {
        return {{$.Table.PluralCamel}}, Err{{$.Table.Pascal}}NotFound
      }
      return {{$.Table.PluralCamel}}, err
    }
    {{$.Table.PluralCamel}} = append({{$.Table.PluralCamel}}, &_{{$.Table.Camel}})
  }
  if rows.Err() != nil {
    return {{$.Table.PluralCamel}}, rows.Err()
  }

  return {{$.Table.PluralCamel}}, nil
}

{{/* Model: Find a row by a set of conditions */}}
// DeleteMany `{{$.Table.Pascal}}`s by some conditions, returning all results.
func (*Model) DeleteMany(db pogo.DB, conds ...pogo.Condition) ([]*{{$.Table.Pascal}}, error) {
  {{$.Table.PluralCamel}} := []*{{$.Table.Pascal}}{}

  _s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return {{$.Table.PluralCamel}}, err
	}

  // sql delete query
  sqlstr := `DELETE FROM {{$.Table.SQLName}} ` +
    _s + ` ` +
    `RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  rows, err := db.Query(sqlstr, _v...)
  if err != nil {
    return {{$.Table.PluralCamel}}, err
  }
  defer rows.Close()

  for rows.Next() {
    var _{{$.Table.Camel}} {{$.Table.Pascal}}
    if e := rows.Scan({{$.Table.Scan}}); e != nil {
      if pogo.IsNoRows(e) {
        return {{$.Table.PluralCamel}}, Err{{$.Table.Pascal}}NotFound
      }
      return {{$.Table.PluralCamel}}, err
    }
    {{$.Table.PluralCamel}} = append({{$.Table.PluralCamel}}, &_{{$.Table.Camel}})
  }
  if rows.Err() != nil {
    return {{$.Table.PluralCamel}}, rows.Err()
  }

  return {{$.Table.PluralCamel}}, nil
}

{{ if .Table.PrimaryKey }}
{{ $pk := .Table.PrimaryKey }}
{{/* Function: DeleteBy(PK) */}}
// DeleteBy{{$pk.Method}} deletes a "{{$.Table.Camel}}"
func DeleteBy{{$pk.Method}}(db pogo.DB, {{$pk.Params}}) (*{{$.Table.Pascal}}, error) {
  // sql delete query
  sqlstr := `DELETE FROM {{$.Table.SQLName}} ` +
    `WHERE {{$pk.Where}} ` +
    `RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, {{$pk.Variables}})
  }

  // run the query
  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, {{$pk.Variables}})
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if pogo.IsNoRows(e) {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* Model: DeleteBy(PK) */}}
// DeleteBy{{$pk.Method}} deletes a "{{$.Table.Camel}}"
func (*Model) DeleteBy{{$pk.Method}}(db pogo.DB, {{$pk.Params}}) (*{{$.Table.Pascal}}, error) {
  // sql delete query
  sqlstr := `DELETE FROM {{$.Table.SQLName}} ` +
    `WHERE {{$pk.Where}} ` +
    `RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, {{$pk.Variables}})
  }

  // run the query
  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, {{$pk.Variables}})
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if pogo.IsNoRows(e) {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}
{{ end }}

{{/* Delete by unique indices */}}
{{ range $idx := .Table.Uniques }}
{{/* Function: DeleteBy(FK) */}}
// DeleteBy{{$idx.Method}} deletes a "{{$.Table.Camel}}"
func DeleteBy{{$idx.Method}}(db pogo.DB, {{$idx.Params}}) (*{{$.Table.Pascal}}, error) {
  // sql delete query
  sqlstr := `DELETE FROM {{$.Table.SQLName}} ` +
    `WHERE {{$idx.Where}} ` +
    `RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, {{$idx.Variables}})
  }

  // run the query
  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, {{$idx.Variables}})
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if pogo.IsNoRows(e) {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* Model: DeleteBy(FK) */}}
// DeleteBy{{$idx.Method}} deletes a "{{$.Table.Camel}}"
func (*Model) DeleteBy{{$idx.Method}}(db pogo.DB, {{$idx.Params}}) (*{{$.Table.Pascal}}, error) {
  // sql delete query
  sqlstr := `DELETE FROM {{$.Table.SQLName}} ` +
    `WHERE {{$idx.Where}} ` +
    `RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, {{$idx.Variables}})
  }

  // run the query
  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, {{$idx.Variables}})
  if e := row.Scan({{$.Table.Scan}}); e != nil {
    if pogo.IsNoRows(e) {
      return nil, Err{{$.Table.Pascal}}NotFound
    }
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}
{{ end }}

{{/* Upsert by a primary key */}}
{{ if .Table.PrimaryKey }}
{{ $pk := .Table.PrimaryKey }}
{{/* Function: Upsert(PK) */}}
// Upsert inserts a `{{$.Table.SQLName}}`, updating the row if `{{$pk.ColumnList}}` already exists.
func Upsert(db pogo.DB, {{$.Table.Camel}} *Input) (*{{$.Table.Pascal}}, error) {
  // get all the non-nil columns and prepare them for the query
  _c, _i, _v := slice({{$.Table.Camel}}.columns(), 0)

  // setup the update fields
	var _u []string
	for _, c := range _c {
		_u = append(_u, c+" = excluded."+c)
	}

  // sql query
  sqlstr := `INSERT INTO {{$.Table.SQLName}} (` + strings.Join(_c, ", ") + `) ` +
  `VALUES (` + strings.Join(_i, ", ") + `) ` +
  `ON CONFLICT ({{$pk.ColumnList}}) ` +
  `DO UPDATE SET ` + strings.Join(_u, ", ") + ` ` +
  `RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  // run query
  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil && !pogo.IsNoRows(e) {
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* Model: Upsert(PK) */}}
// Upsert inserts a `{{$.Table.SQLName}}`, updating the row if `{{$pk.ColumnList}}` already exists.
func (*Model) Upsert(db pogo.DB, {{$.Table.Camel}} *Input) (*{{$.Table.Pascal}}, error) {
  // get all the non-nil columns and prepare them for the query
  _c, _i, _v := slice({{$.Table.Camel}}.columns(), 0)

  // setup the update fields
	var _u []string
	for _, c := range _c {
		_u = append(_u, c+" = excluded."+c)
	}

  // sql query
  sqlstr := `INSERT INTO {{$.Table.SQLName}} (` + strings.Join(_c, ", ") + `) ` +
  `VALUES (` + strings.Join(_i, ", ") + `) ` +
  `ON CONFLICT ({{$pk.ColumnList}}) ` +
  `DO UPDATE SET ` + strings.Join(_u, ", ") + ` ` +
  `RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  // run query
  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil && !pogo.IsNoRows(e) {
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}
{{ end }}

{{/* Upsert by indices */}}
{{ range $idx := .Table.Indexes }}
{{/* Function: UpsertBy(FK) */}}
// UpsertBy{{$idx.Method}} inserts a `{{$.Table.SQLName}}`, updating the row if `{{$idx.ColumnList}}` already exists.
func UpsertBy{{$idx.Method}}(db pogo.DB, {{ $idx.Params}}, {{$.Table.Camel}} *Input) (*{{$.Table.Pascal}}, error) {
  // add values to input, overriding existing keys if present in the input
  {{$.Table.Camel}} = {{$.Table.Camel}}{{ range $col := $idx.Columns }}.{{$col.Pascal}}({{$col.Camel}}){{ end }}

  // get all the non-nil columns and prepare them for the query
  _c, _i, _v := slice({{$.Table.Camel}}.columns(), 0)

  // setup the update fields
	var _u []string
	for _, c := range _c {
		_u = append(_u, c+" = excluded."+c)
	}

  // sql query
  sqlstr := `INSERT INTO {{$.Table.SQLName}} (` + strings.Join(_c, ", ") + `) ` +
  `VALUES (` + strings.Join(_i, ", ") + `) ` +
  `ON CONFLICT ({{$idx.ColumnList}}) ` +
  `DO UPDATE SET ` + strings.Join(_u, ", ") + ` ` +
  `RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  // run query
  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil && !pogo.IsNoRows(e) {
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}

{{/* Model: UpsertBy(FK) */}}
// UpsertBy{{$idx.Method}} inserts a `{{$.Table.SQLName}}`, updating the row if `{{$idx.ColumnList}}` already exists.
func (*Model) UpsertBy{{$idx.Method}}(db pogo.DB, {{ $idx.Params}}, {{$.Table.Camel}} *Input) (*{{$.Table.Pascal}}, error) {
  // add values to input, overriding existing keys if present in the input
  {{$.Table.Camel}} = {{$.Table.Camel}}{{ range $col := $idx.Columns }}.{{$col.Pascal}}({{$col.Camel}}){{ end }}

  // get all the non-nil columns and prepare them for the query
  _c, _i, _v := slice({{$.Table.Camel}}.columns(), 0)

  // setup the update fields
	var _u []string
	for _, c := range _c {
		_u = append(_u, c+" = excluded."+c)
	}

  // sql query
  sqlstr := `INSERT INTO {{$.Table.SQLName}} (` + strings.Join(_c, ", ") + `) ` +
  `VALUES (` + strings.Join(_i, ", ") + `) ` +
  `ON CONFLICT ({{$idx.ColumnList}}) ` +
  `DO UPDATE SET ` + strings.Join(_u, ", ") + ` ` +
  `RETURNING {{$.Table.Returning}}`

  // log query if we've provided a logger
  if pogo.Log != nil {
    pogo.Log(sqlstr, _v...)
  }

  // run query
  var _{{$.Table.Camel}} {{$.Table.Pascal}}
  row := db.QueryRow(sqlstr, _v...)
  if e := row.Scan({{$.Table.Scan}}); e != nil && !pogo.IsNoRows(e) {
    return nil, e
  }

  return &_{{$.Table.Camel}}, nil
}
{{ end }}

// slice converts our columns into something the sql driver can understand
func slice(columns map[string]interface{}, offset int) (c []string, i []string, v []interface{}) {
	n := offset + 1
	for col, val := range columns {
		c = append(c, strconv.Quote(col))
		i = append(i, "$"+strconv.Itoa(n))
		v = append(v, val)
		n++
	}
	return c, i, v
}

package standups

import (
	"encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/pogo/testjack"
	uuid "github.com/satori/go.uuid"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrStandupNotFound returned if the standup is not found
var ErrStandupNotFound = errors.New("standup not found")

// columns in `jack.standups`
type columns struct {
	ID             *string                 `json:"id,omitempty"`
	Name           *string                 `json:"name,omitempty"`
	SlackChannelID *string                 `json:"slack_channel_id,omitempty"`
	Time           *string                 `json:"time,omitempty"`
	Timezone       *string                 `json:"timezone,omitempty"`
	Questions      *map[string]interface{} `json:"questions,omitempty"`
	TeamID         *string                 `json:"team_id,omitempty"`
	CreatedAt      *time.Time              `json:"created_at,omitempty"`
	UpdatedAt      *time.Time              `json:"updated_at,omitempty"`
}

// Standup fluent API
type Standup struct {
	columns *columns
}

// New `jack.standups` API
func New() *Standup {
	return &Standup{&columns{}}
}

// ID sets the `id`
func (standup *Standup) ID(id uuid.UUID) *Standup {
	standup.columns.ID = testjack.DecodeUUID(id)
	return standup
}

// GetID returns the `id` if set
func (standup *Standup) GetID() (id *uuid.UUID) {
	return testjack.EncodeUUID(standup.columns.ID)
}

// Name sets the `name`
func (standup *Standup) Name(name string) *Standup {
	standup.columns.Name = &name
	return standup
}

// GetName returns the `name` if set
func (standup *Standup) GetName() (name *string) {
	return standup.columns.Name
}

// SlackChannelID sets the `slack_channel_id`
func (standup *Standup) SlackChannelID(slackChannelID string) *Standup {
	standup.columns.SlackChannelID = &slackChannelID
	return standup
}

// GetSlackChannelID returns the `slack_channel_id` if set
func (standup *Standup) GetSlackChannelID() (slackChannelID *string) {
	return standup.columns.SlackChannelID
}

// Time sets the `time`
func (standup *Standup) Time(time string) *Standup {
	standup.columns.Time = &time
	return standup
}

// GetTime returns the `time` if set
func (standup *Standup) GetTime() (time *string) {
	return standup.columns.Time
}

// Timezone sets the `timezone`
func (standup *Standup) Timezone(timezone string) *Standup {
	standup.columns.Timezone = &timezone
	return standup
}

// GetTimezone returns the `timezone` if set
func (standup *Standup) GetTimezone() (timezone *string) {
	return standup.columns.Timezone
}

// Questions sets the `questions`
func (standup *Standup) Questions(questions map[string]interface{}) *Standup {
	standup.columns.Questions = &questions
	return standup
}

// GetQuestions returns the `questions` if set
func (standup *Standup) GetQuestions() (questions *map[string]interface{}) {
	return standup.columns.Questions
}

// TeamID sets the `team_id`
func (standup *Standup) TeamID(teamID uuid.UUID) *Standup {
	standup.columns.TeamID = testjack.DecodeUUID(teamID)
	return standup
}

// GetTeamID returns the `team_id` if set
func (standup *Standup) GetTeamID() (teamID *uuid.UUID) {
	return testjack.EncodeUUID(standup.columns.TeamID)
}

// CreatedAt sets the `created_at`
func (standup *Standup) CreatedAt(createdAt time.Time) *Standup {
	standup.columns.CreatedAt = &createdAt
	return standup
}

// GetCreatedAt returns the `created_at` if set
func (standup *Standup) GetCreatedAt() (createdAt *time.Time) {
	return standup.columns.CreatedAt
}

// UpdatedAt sets the `updated_at`
func (standup *Standup) UpdatedAt(updatedAt time.Time) *Standup {
	standup.columns.UpdatedAt = &updatedAt
	return standup
}

// GetUpdatedAt returns the `updated_at` if set
func (standup *Standup) GetUpdatedAt() (updatedAt *time.Time) {
	return standup.columns.UpdatedAt
}

// MarshalJSON marshals the `standup` into JSON
func (standup *Standup) MarshalJSON() ([]byte, error) {
	return json.Marshal(standup.columns)
}

// UnmarshalJSON unmarshals json to a `standup`
func (standup *Standup) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, standup.columns)
}

func (standup *Standup) String() string {
	return "standup TODO"
}

// get all the non-nil columns
func getColumns(standup *Standup) map[string]interface{} {
	columns := make(map[string]interface{})

	if standup.columns.ID != nil {
		columns["id"] = *standup.columns.ID
	}
	if standup.columns.Name != nil {
		columns["name"] = *standup.columns.Name
	}
	if standup.columns.SlackChannelID != nil {
		columns["slack_channel_id"] = *standup.columns.SlackChannelID
	}
	if standup.columns.Time != nil {
		columns["time"] = *standup.columns.Time
	}
	if standup.columns.Timezone != nil {
		columns["timezone"] = *standup.columns.Timezone
	}
	if standup.columns.Questions != nil {
		columns["questions"] = *standup.columns.Questions
	}
	if standup.columns.TeamID != nil {
		columns["team_id"] = *standup.columns.TeamID
	}
	if standup.columns.CreatedAt != nil {
		columns["created_at"] = *standup.columns.CreatedAt
	}
	if standup.columns.UpdatedAt != nil {
		columns["updated_at"] = *standup.columns.UpdatedAt
	}

	return columns
}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
	condition string
	params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
	return &WhereClause{
		condition: condition,
		params:    params,
	}
}

// Find a standup by "id"
func Find(db testjack.DB, id uuid.UUID) (*Standup, error) {
	_id := testjack.DecodeUUID(id)

	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"
	FROM jack.standups
	WHERE "id" = $1
	`
	testjack.Log(sqlstr, _id)

	cols := &columns{}
	row := db.QueryRow(sqlstr, _id)
	if e := row.Scan(&cols.ID, &cols.Name, &cols.SlackChannelID, &cols.Time, &cols.Timezone, &cols.Questions, &cols.TeamID, &cols.CreatedAt, &cols.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, e
	}

	return &Standup{cols}, nil
}

// FindBySlackChannelID find a standup by `slack_channel_id`
func FindBySlackChannelID(db testjack.DB, slackChannelID string) (*Standup, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"
	FROM jack.standups
	WHERE "slack_channel_id" = $1
	`
	testjack.Log(sqlstr, slackChannelID)

	cols := &columns{}
	row := db.QueryRow(sqlstr, slackChannelID)
	err := row.Scan(&cols.ID, &cols.Name, &cols.SlackChannelID, &cols.Time, &cols.Timezone, &cols.Questions, &cols.TeamID, &cols.CreatedAt, &cols.UpdatedAt)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, err
	}

	return &Standup{cols}, nil
}

// FindMany find many `standup`s by a given condition
func FindMany(db testjack.DB, where *WhereClause) ([]*Standup, error) {
	var _o []*Standup

	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"
	FROM jack.standups
	WHERE ` + where.condition
	testjack.Log(sqlstr, where.params...)

	rows, err := db.Query(sqlstr, where.params...)
	if err != nil {
		return _o, err
	}
	defer rows.Close()

	for rows.Next() {
		cols := &columns{}
		if e := rows.Scan(&cols.ID, &cols.Name, &cols.SlackChannelID, &cols.Time, &cols.Timezone, &cols.Questions, &cols.TeamID, &cols.CreatedAt, &cols.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return _o, ErrStandupNotFound
			}
			return _o, err
		}
		_o = append(_o, &Standup{cols})
	}
	if rows.Err() != nil {
		return _o, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	if len(_o) == 0 {
		return make([]*Standup, 0), nil
	}

	return _o, nil
}

// FindOne find one standup by a condition
func FindOne(db testjack.DB, where *WhereClause) (*Standup, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"
	FROM jack.standups
	WHERE ` + where.condition
	testjack.Log(sqlstr, where.params...)

	cols := &columns{}
	row := db.QueryRow(sqlstr, where.params...)
	if e := row.Scan(&cols.ID, &cols.Name, &cols.SlackChannelID, &cols.Time, &cols.Timezone, &cols.Questions, &cols.TeamID, &cols.CreatedAt, &cols.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, e
	}

	return &Standup{cols}, nil
}

// Insert a `standup` into the `jack.standups` table.
func Insert(db testjack.DB, standup *Standup) (*Standup, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := testjack.Slice(getColumns(standup), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
	INSERT INTO jack.standups (` + strings.Join(_c, ", ") + `)
	VALUES (` + strings.Join(_i, ", ") + `)
	RETURNING "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"
	`
	testjack.Log(sqlstr, _v...)

	cols := &columns{}
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&cols.ID, &cols.Name, &cols.SlackChannelID, &cols.Time, &cols.Timezone, &cols.Questions, &cols.TeamID, &cols.CreatedAt, &cols.UpdatedAt); e != nil {
		return nil, e
	}

	return &Standup{cols}, nil
}

// Update a standup by its `id`
func Update(db testjack.DB, id uuid.UUID, standup *Standup) (*Standup, error) {
	_id := testjack.DecodeUUID(id)
	fields := getColumns(standup)

	// don't update the primary key
	delete(fields, "id")

	// prepare the slices
	_c, _i, _v := testjack.Slice(fields, 1)

	// sql query
	sqlstr := `UPDATE jack.standups SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `)
		WHERE "id" = $1
		RETURNING "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"`

	// setup query
	values := append([]interface{}{_id}, _v...)
	testjack.Log(sqlstr, values...)

	// run the query
	cols := &columns{}
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&cols.ID, &cols.Name, &cols.SlackChannelID, &cols.Time, &cols.Timezone, &cols.Questions, &cols.TeamID, &cols.CreatedAt, &cols.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, e
	}

	return &Standup{cols}, nil
}

// UpdateBySlackChannelID find a Standup
func UpdateBySlackChannelID(db testjack.DB, slackChannelID string, standup *Standup) (*Standup, error) {
	fields := getColumns(standup)

	// don't update the keys
	delete(fields, "slack_channel_id")

	// prepare the slices
	_c, _i, _v := testjack.Slice(fields, 1)

	// sql query
	sqlstr := `UPDATE jack.standups SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE "slack_channel_id" = $1 ` +
		`RETURNING "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"`

	// setup the query
	values := []interface{}{}
	values = append(values, slackChannelID)

	values = append(values, _v...)
	testjack.Log(sqlstr, values...)

	// run the query
	cols := &columns{}
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&cols.ID, &cols.Name, &cols.SlackChannelID, &cols.Time, &cols.Timezone, &cols.Questions, &cols.TeamID, &cols.CreatedAt, &cols.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrStandupNotFound
		}
		return nil, e
	}

	return &Standup{cols}, nil
}

// UpdateMany rows in `jack.standups` by a given condition
func UpdateMany(db testjack.DB, where *WhereClause, standup *Standup) ([]*Standup, error) {
	var _o []*Standup

	// prepare the slices
	_c, _i, _v := testjack.Slice(getColumns(standup), len(where.params))

	// sql query
	sqlstr := `UPDATE jack.standups SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE ` + where.condition + ` ` +
		`RETURNING "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"`

		// setup the query
	values := []interface{}{}
	values = append(values, where.params...)
	values = append(values, _v...)
	testjack.Log(sqlstr, values...)

	// run query
	rows, err := db.Query(sqlstr, values...)
	if err != nil {
		return _o, err
	}
	defer rows.Close()

	for rows.Next() {
		cols := &columns{}
		if e := rows.Scan(&cols.ID, &cols.Name, &cols.SlackChannelID, &cols.Time, &cols.Timezone, &cols.Questions, &cols.TeamID, &cols.CreatedAt, &cols.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return _o, ErrStandupNotFound
			}
			return _o, err
		}
		_o = append(_o, &Standup{cols})
	}
	if rows.Err() != nil {
		return _o, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	if len(_o) == 0 {
		return make([]*Standup, 0), nil
	}

	return _o, nil
}

// Delete a `standup` from the `jack.standups` table
func Delete(db testjack.DB, id uuid.UUID) error {
	_id := testjack.DecodeUUID(id)

	// sql query
	sqlstr := `DELETE FROM jack.standups WHERE "id" = $1`
	testjack.Log(sqlstr, _id)

	// run query
	if _, e := db.Exec(sqlstr, _id); e != nil {
		if e == pgx.ErrNoRows {
			return ErrStandupNotFound
		}
		return e
	}

	return nil
}

// DeleteBySlackChannelID find a Standup
func DeleteBySlackChannelID(db testjack.DB, slackChannelID string) error {
	// sql delete query
	sqlstr := `DELETE FROM jack.standups WHERE "slack_channel_id" = $1`
	testjack.Log(sqlstr, slackChannelID)

	if _, e := db.Exec(sqlstr, slackChannelID); e != nil {
		if e == pgx.ErrNoRows {
			return ErrStandupNotFound
		}
		return e
	}

	return nil
}

// DeleteMany delete many `standup`'s by the given condition
func DeleteMany(db testjack.DB, where *WhereClause) error {
	// sql select query, primary key provided by sequence
	sqlstr := `DELETE FROM jack.standups WHERE ` + where.condition
	testjack.Log(sqlstr, where.params...)

	if _, e := db.Exec(sqlstr, where.params...); e != nil {
		return e
	}

	return nil
}

// Upsert the `standup` by its `id`.
func Upsert(db testjack.DB, standup *Standup, action string) (*Standup, error) {
	// prepare the slices
	_c, _i, _v := testjack.Slice(getColumns(standup), 0)

	// determine on conflict action
	var upsertAction string
	if action == testjack.UpsertDoUpdate {
		upsertAction = `DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `)`
	} else if action == testjack.UpsertDoNothing {
		upsertAction = testjack.UpsertDoNothing
	} else {
		return nil, errors.New("invalid upsert action")
	}

	// sql query
	sqlstr := `INSERT INTO jack.standups (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		upsertAction + ` ` +
		`RETURNING "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"`
	testjack.Log(sqlstr, _v...)

	// run query
	cols := &columns{}
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&cols.ID, &cols.Name, &cols.SlackChannelID, &cols.Time, &cols.Timezone, &cols.Questions, &cols.TeamID, &cols.CreatedAt, &cols.UpdatedAt); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &Standup{cols}, nil
}

// UpsertBySlackChannelID find a Standup
func UpsertBySlackChannelID(db testjack.DB, standup *Standup, action string) (*Standup, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := testjack.Slice(getColumns(standup), 0)

	// determine on conflict action
	var upsertAction string
	if action == testjack.UpsertDoUpdate {
		upsertAction = `DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `)`
	} else if action == testjack.UpsertDoNothing {
		upsertAction = testjack.UpsertDoNothing
	} else {
		return nil, errors.New("invalid upsert action")
	}

	// sql query
	sqlstr := `INSERT INTO jack.standups (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("slack_channel_id") ` +
		upsertAction + ` ` +
		`RETURNING "id", "name", "slack_channel_id", "time", "timezone", "questions", "team_id", "created_at", "updated_at"`
	testjack.Log(sqlstr, _v...)

	// run query
	cols := &columns{}
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&cols.ID, &cols.Name, &cols.SlackChannelID, &cols.Time, &cols.Timezone, &cols.Questions, &cols.TeamID, &cols.CreatedAt, &cols.UpdatedAt); e != nil && e != pgx.ErrNoRows {
		return nil, e
	}

	return &Standup{cols}, nil
}

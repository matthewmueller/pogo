package teaminvites

import (
	"encoding/json"
	"errors"
	"strings"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/pogo/testjack"
	uuid "github.com/satori/go.uuid"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrTeamInviteNotFound returned if the teaminvite is not found
var ErrTeamInviteNotFound = errors.New("teaminvite not found")

// columns in `"jack"."team-invites"`
type columns struct {
	ID     *string   `json:"id,omitempty"`
	Emails *[]string `json:"emails,omitempty"`
}

// TeamInvite fluent API
type TeamInvite struct {
	columns *columns
}

// New `"jack"."team-invites"` API
func New() *TeamInvite {
	return &TeamInvite{&columns{}}
}

// ID sets the `id`
func (teaminvite *TeamInvite) ID(id uuid.UUID) *TeamInvite {
	teaminvite.columns.ID = testjack.DecodeUUID(id)
	return teaminvite
}

// GetID returns the `id` if set
func (teaminvite *TeamInvite) GetID() (id *uuid.UUID) {
	return testjack.EncodeUUID(teaminvite.columns.ID)
}

// Emails sets the `emails`
func (teaminvite *TeamInvite) Emails(emails []string) *TeamInvite {
	teaminvite.columns.Emails = &emails
	return teaminvite
}

// GetEmails returns the `emails` if set
func (teaminvite *TeamInvite) GetEmails() (emails *[]string) {
	return teaminvite.columns.Emails
}

// MarshalJSON marshals the `teaminvite` into JSON
func (teaminvite *TeamInvite) MarshalJSON() ([]byte, error) {
	return json.Marshal(teaminvite.columns)
}

// UnmarshalJSON unmarshals json to a `teaminvite`
func (teaminvite *TeamInvite) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, teaminvite.columns)
}

func (teaminvite *TeamInvite) String() string {
	return "teaminvite"
}

// get all the non-nil columns
func getColumns(teaminvite *TeamInvite) map[string]interface{} {
	columns := make(map[string]interface{})

	if teaminvite.columns.ID != nil {
		columns["id"] = *teaminvite.columns.ID
	}
	if teaminvite.columns.Emails != nil {
		columns["emails"] = *teaminvite.columns.Emails
	}

	return columns
}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
	condition string
	params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
	return &WhereClause{
		condition: condition,
		params:    params,
	}
}

// Find a teaminvite by "id"
func Find(db testjack.DB, id uuid.UUID) (*TeamInvite, error) {
	_id := testjack.DecodeUUID(id)

	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "emails"
	FROM "jack"."team-invites"
	WHERE "id" = $1
	`
	testjack.Log(sqlstr, _id)

	cols := &columns{}
	row := db.QueryRow(sqlstr, _id)
	if e := row.Scan(&cols.ID, &cols.Emails); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeamInviteNotFound
		}
		return nil, e
	}

	return &TeamInvite{cols}, nil
}

// FindMany find many `teaminvite`s by a given condition
func FindMany(db testjack.DB, where *WhereClause) ([]*TeamInvite, error) {
	var _o []*TeamInvite

	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "emails"
	FROM "jack"."team-invites"
	WHERE ` + where.condition
	testjack.Log(sqlstr, where.params...)

	rows, err := db.Query(sqlstr, where.params...)
	if err != nil {
		return _o, err
	}
	defer rows.Close()

	for rows.Next() {
		cols := &columns{}
		if e := rows.Scan(&cols.ID, &cols.Emails); e != nil {
			if e == pgx.ErrNoRows {
				return _o, ErrTeamInviteNotFound
			}
			return _o, err
		}
		_o = append(_o, &TeamInvite{cols})
	}
	if rows.Err() != nil {
		return _o, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	if len(_o) == 0 {
		return make([]*TeamInvite, 0), nil
	}

	return _o, nil
}

// FindOne find one teaminvite by a condition
func FindOne(db testjack.DB, where *WhereClause) (*TeamInvite, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "emails"
	FROM "jack"."team-invites"
	WHERE ` + where.condition
	testjack.Log(sqlstr, where.params...)

	cols := &columns{}
	row := db.QueryRow(sqlstr, where.params...)
	if e := row.Scan(&cols.ID, &cols.Emails); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeamInviteNotFound
		}
		return nil, e
	}

	return &TeamInvite{cols}, nil
}

// Insert a `teaminvite` into the `"jack"."team-invites"` table.
func Insert(db testjack.DB, teaminvite *TeamInvite) (*TeamInvite, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := testjack.Slice(getColumns(teaminvite), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
	INSERT INTO "jack"."team-invites" (` + strings.Join(_c, ", ") + `)
	VALUES (` + strings.Join(_i, ", ") + `)
	RETURNING "id", "emails"
	`
	testjack.Log(sqlstr, _v...)

	cols := &columns{}
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&cols.ID, &cols.Emails); e != nil {
		return nil, e
	}

	return &TeamInvite{cols}, nil
}

// Update a teaminvite by its `id`
func Update(db testjack.DB, id uuid.UUID, teaminvite *TeamInvite) (*TeamInvite, error) {
	_id := testjack.DecodeUUID(id)
	fields := getColumns(teaminvite)

	// don't update the primary key
	delete(fields, "id")

	// prepare the slices
	_c, _i, _v := testjack.Slice(fields, 1)

	// sql query
	sqlstr := `UPDATE "jack"."team-invites" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `)
		WHERE "id" = $1
		RETURNING "id", "emails"`

	// setup query
	values := append([]interface{}{_id}, _v...)
	testjack.Log(sqlstr, values...)

	// run the query
	cols := &columns{}
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&cols.ID, &cols.Emails); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrTeamInviteNotFound
		}
		return nil, e
	}

	return &TeamInvite{cols}, nil
}

// UpdateMany rows in `"jack"."team-invites"` by a given condition
func UpdateMany(db testjack.DB, where *WhereClause, teaminvite *TeamInvite) ([]*TeamInvite, error) {
	var _o []*TeamInvite

	// prepare the slices
	_c, _i, _v := testjack.Slice(getColumns(teaminvite), len(where.params))

	// sql query
	sqlstr := `UPDATE "jack"."team-invites" SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE ` + where.condition + ` ` +
		`RETURNING "id", "emails"`

		// setup the query
	values := []interface{}{}
	values = append(values, where.params...)
	values = append(values, _v...)
	testjack.Log(sqlstr, values...)

	// run query
	rows, err := db.Query(sqlstr, values...)
	if err != nil {
		return _o, err
	}
	defer rows.Close()

	for rows.Next() {
		cols := &columns{}
		if e := rows.Scan(&cols.ID, &cols.Emails); e != nil {
			if e == pgx.ErrNoRows {
				return _o, ErrTeamInviteNotFound
			}
			return _o, err
		}
		_o = append(_o, &TeamInvite{cols})
	}
	if rows.Err() != nil {
		return _o, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	if len(_o) == 0 {
		return make([]*TeamInvite, 0), nil
	}

	return _o, nil
}

// Delete a `teaminvite` from the `"jack"."team-invites"` table
func Delete(db testjack.DB, id uuid.UUID) error {
	_id := testjack.DecodeUUID(id)

	// sql query
	sqlstr := `DELETE FROM "jack"."team-invites" WHERE "id" = $1`
	testjack.Log(sqlstr, _id)

	// run query
	if _, e := db.Exec(sqlstr, _id); e != nil {
		if e == pgx.ErrNoRows {
			return ErrTeamInviteNotFound
		}
		return e
	}

	return nil
}

// DeleteMany delete many `teaminvite`'s by the given condition
func DeleteMany(db testjack.DB, where *WhereClause) error {
	// sql select query, primary key provided by sequence
	sqlstr := `DELETE FROM "jack"."team-invites" WHERE ` + where.condition
	testjack.Log(sqlstr, where.params...)

	if _, e := db.Exec(sqlstr, where.params...); e != nil {
		return e
	}

	return nil
}

// Upsert the `teaminvite` by its `id`.
func Upsert(db testjack.DB, teaminvite *TeamInvite) (*TeamInvite, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := testjack.Slice(getColumns(teaminvite), 0)

	// sql query
	sqlstr := `INSERT INTO "jack"."team-invites" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "id", "emails"`
	testjack.Log(sqlstr, _v...)

	// run query
	cols := &columns{}
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&cols.ID, &cols.Emails); e != nil {
		return nil, e
	}

	return &TeamInvite{cols}, nil
}

package reports

import (
	"encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/jackc/pgx"
	"github.com/matthewmueller/pogo/testjack"
	"github.com/matthewmueller/pogo/testjack/enum"
	uuid "github.com/satori/go.uuid"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrReportNotFound returned if the report is not found
var ErrReportNotFound = errors.New("report not found")

// columns in `jack.reports`
type columns struct {
	ID        *string            `json:"id,omitempty"`
	UserID    *string            `json:"user_id,omitempty"`
	Timestamp *time.Time         `json:"timestamp,omitempty"`
	Questions *json.RawMessage   `json:"questions,omitempty"`
	StandupID *string            `json:"standup_id,omitempty"`
	Status    *enum.ReportStatus `json:"status,omitempty"`
	CreatedAt *time.Time         `json:"created_at,omitempty"`
	UpdatedAt *time.Time         `json:"updated_at,omitempty"`
}

// Report fluent API
type Report struct {
	columns *columns
}

// New `jack.reports` API
func New() *Report {
	return &Report{&columns{}}
}

// ID sets the `id`
func (report *Report) ID(id uuid.UUID) *Report {
	report.columns.ID = testjack.DecodeUUID(id)
	return report
}

// GetID returns the `id` if set
func (report *Report) GetID() (id *uuid.UUID) {
	return testjack.EncodeUUID(report.columns.ID)
}

// UserID sets the `user_id`
func (report *Report) UserID(userID uuid.UUID) *Report {
	report.columns.UserID = testjack.DecodeUUID(userID)
	return report
}

// GetUserID returns the `user_id` if set
func (report *Report) GetUserID() (userID *uuid.UUID) {
	return testjack.EncodeUUID(report.columns.UserID)
}

// Timestamp sets the `timestamp`
func (report *Report) Timestamp(timestamp time.Time) *Report {
	report.columns.Timestamp = &timestamp
	return report
}

// GetTimestamp returns the `timestamp` if set
func (report *Report) GetTimestamp() (timestamp *time.Time) {
	return report.columns.Timestamp
}

// Questions sets the `questions`
func (report *Report) Questions(questions json.RawMessage) *Report {
	report.columns.Questions = &questions
	return report
}

// GetQuestions returns the `questions` if set
func (report *Report) GetQuestions() (questions *json.RawMessage) {
	return report.columns.Questions
}

// StandupID sets the `standup_id`
func (report *Report) StandupID(standupID uuid.UUID) *Report {
	report.columns.StandupID = testjack.DecodeUUID(standupID)
	return report
}

// GetStandupID returns the `standup_id` if set
func (report *Report) GetStandupID() (standupID *uuid.UUID) {
	return testjack.EncodeUUID(report.columns.StandupID)
}

// Status sets the `status`
func (report *Report) Status(status enum.ReportStatus) *Report {
	report.columns.Status = &status
	return report
}

// GetStatus returns the `status` if set
func (report *Report) GetStatus() (status *enum.ReportStatus) {
	return report.columns.Status
}

// CreatedAt sets the `created_at`
func (report *Report) CreatedAt(createdAt time.Time) *Report {
	report.columns.CreatedAt = &createdAt
	return report
}

// GetCreatedAt returns the `created_at` if set
func (report *Report) GetCreatedAt() (createdAt *time.Time) {
	return report.columns.CreatedAt
}

// UpdatedAt sets the `updated_at`
func (report *Report) UpdatedAt(updatedAt time.Time) *Report {
	report.columns.UpdatedAt = &updatedAt
	return report
}

// GetUpdatedAt returns the `updated_at` if set
func (report *Report) GetUpdatedAt() (updatedAt *time.Time) {
	return report.columns.UpdatedAt
}

// MarshalJSON marshals the `report` into JSON
func (report *Report) MarshalJSON() ([]byte, error) {
	return json.Marshal(report.columns)
}

// UnmarshalJSON unmarshals json to a `report`
func (report *Report) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, report.columns)
}

func (report *Report) String() string {
	return "report TODO"
}

// get all the non-nil columns
func getColumns(report *Report) map[string]interface{} {
	columns := make(map[string]interface{})

	if report.columns.ID != nil {
		columns["id"] = *report.columns.ID
	}
	if report.columns.UserID != nil {
		columns["user_id"] = *report.columns.UserID
	}
	if report.columns.Timestamp != nil {
		columns["timestamp"] = *report.columns.Timestamp
	}
	if report.columns.Questions != nil {
		columns["questions"] = *report.columns.Questions
	}
	if report.columns.StandupID != nil {
		columns["standup_id"] = *report.columns.StandupID
	}
	if report.columns.Status != nil {
		columns["status"] = *report.columns.Status
	}
	if report.columns.CreatedAt != nil {
		columns["created_at"] = *report.columns.CreatedAt
	}
	if report.columns.UpdatedAt != nil {
		columns["updated_at"] = *report.columns.UpdatedAt
	}

	return columns
}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
	condition string
	params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
	return &WhereClause{
		condition: condition,
		params:    params,
	}
}

// Find a report by "id"
func Find(db testjack.DB, id uuid.UUID) (*Report, error) {
	_id := testjack.DecodeUUID(id)

	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "user_id", "timestamp", "questions", "standup_id", "status", "created_at", "updated_at"
	FROM jack.reports
	WHERE "id" = $1
	`
	testjack.Log(sqlstr, _id)

	cols := &columns{}
	row := db.QueryRow(sqlstr, _id)
	if e := row.Scan(&cols.ID, &cols.UserID, &cols.Timestamp, &cols.Questions, &cols.StandupID, &cols.Status, &cols.CreatedAt, &cols.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrReportNotFound
		}
		return nil, e
	}

	return &Report{cols}, nil
}

// FindMany find many `report`s by a given condition
func FindMany(db testjack.DB, where *WhereClause) ([]*Report, error) {
	var _o []*Report

	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "user_id", "timestamp", "questions", "standup_id", "status", "created_at", "updated_at"
	FROM jack.reports
	WHERE ` + where.condition
	testjack.Log(sqlstr, where.params...)

	rows, err := db.Query(sqlstr, where.params...)
	if err != nil {
		return _o, err
	}
	defer rows.Close()

	for rows.Next() {
		cols := &columns{}
		if e := rows.Scan(&cols.ID, &cols.UserID, &cols.Timestamp, &cols.Questions, &cols.StandupID, &cols.Status, &cols.CreatedAt, &cols.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return _o, ErrReportNotFound
			}
			return _o, err
		}
		_o = append(_o, &Report{cols})
	}
	if rows.Err() != nil {
		return _o, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	if len(_o) == 0 {
		return make([]*Report, 0), nil
	}

	return _o, nil
}

// FindOne find one report by a condition
func FindOne(db testjack.DB, where *WhereClause) (*Report, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
	SELECT "id", "user_id", "timestamp", "questions", "standup_id", "status", "created_at", "updated_at"
	FROM jack.reports
	WHERE ` + where.condition
	testjack.Log(sqlstr, where.params...)

	cols := &columns{}
	row := db.QueryRow(sqlstr, where.params...)
	if e := row.Scan(&cols.ID, &cols.UserID, &cols.Timestamp, &cols.Questions, &cols.StandupID, &cols.Status, &cols.CreatedAt, &cols.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrReportNotFound
		}
		return nil, e
	}

	return &Report{cols}, nil
}

// Insert a `report` into the `jack.reports` table.
func Insert(db testjack.DB, report *Report) (*Report, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := testjack.Slice(getColumns(report), 0)

	// sql insert query, primary key provided by sequence
	sqlstr := `
	INSERT INTO jack.reports (` + strings.Join(_c, ", ") + `)
	VALUES (` + strings.Join(_i, ", ") + `)
	RETURNING "id", "user_id", "timestamp", "questions", "standup_id", "status", "created_at", "updated_at"
	`
	testjack.Log(sqlstr, _v...)

	cols := &columns{}
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&cols.ID, &cols.UserID, &cols.Timestamp, &cols.Questions, &cols.StandupID, &cols.Status, &cols.CreatedAt, &cols.UpdatedAt); e != nil {
		return nil, e
	}

	return &Report{cols}, nil
}

// Update a report by its `id`
func Update(db testjack.DB, id uuid.UUID, report *Report) (*Report, error) {
	_id := testjack.DecodeUUID(id)
	fields := getColumns(report)

	// don't update the primary key
	delete(fields, "id")

	// prepare the slices
	_c, _i, _v := testjack.Slice(fields, 1)

	// sql query
	sqlstr := `UPDATE jack.reports SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `)
		WHERE "id" = $1
		RETURNING "id", "user_id", "timestamp", "questions", "standup_id", "status", "created_at", "updated_at"`

	// setup query
	values := append([]interface{}{_id}, _v...)
	testjack.Log(sqlstr, values...)

	// run the query
	cols := &columns{}
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&cols.ID, &cols.UserID, &cols.Timestamp, &cols.Questions, &cols.StandupID, &cols.Status, &cols.CreatedAt, &cols.UpdatedAt); e != nil {
		if e == pgx.ErrNoRows {
			return nil, ErrReportNotFound
		}
		return nil, e
	}

	return &Report{cols}, nil
}

// UpdateMany rows in `jack.reports` by a given condition
func UpdateMany(db testjack.DB, where *WhereClause, report *Report) ([]*Report, error) {
	var _o []*Report

	// prepare the slices
	_c, _i, _v := testjack.Slice(getColumns(report), len(where.params))

	// sql query
	sqlstr := `UPDATE jack.reports SET (` +
		strings.Join(_c, ", ") + `) = (` +
		strings.Join(_i, ", ") + `) ` +
		`WHERE ` + where.condition + ` ` +
		`RETURNING "id", "user_id", "timestamp", "questions", "standup_id", "status", "created_at", "updated_at"`

		// setup the query
	values := []interface{}{}
	values = append(values, where.params...)
	values = append(values, _v...)
	testjack.Log(sqlstr, values...)

	// run query
	rows, err := db.Query(sqlstr, values...)
	if err != nil {
		return _o, err
	}
	defer rows.Close()

	for rows.Next() {
		cols := &columns{}
		if e := rows.Scan(&cols.ID, &cols.UserID, &cols.Timestamp, &cols.Questions, &cols.StandupID, &cols.Status, &cols.CreatedAt, &cols.UpdatedAt); e != nil {
			if e == pgx.ErrNoRows {
				return _o, ErrReportNotFound
			}
			return _o, err
		}
		_o = append(_o, &Report{cols})
	}
	if rows.Err() != nil {
		return _o, rows.Err()
	}

	// ensure we return an empty array
	// rather than nil when we marshal
	if len(_o) == 0 {
		return make([]*Report, 0), nil
	}

	return _o, nil
}

// Delete a `report` from the `jack.reports` table
func Delete(db testjack.DB, id uuid.UUID) error {
	_id := testjack.DecodeUUID(id)

	// sql query
	sqlstr := `DELETE FROM jack.reports WHERE "id" = $1`
	testjack.Log(sqlstr, _id)

	// run query
	if _, e := db.Exec(sqlstr, _id); e != nil {
		if e == pgx.ErrNoRows {
			return ErrReportNotFound
		}
		return e
	}

	return nil
}

// DeleteMany delete many `report`'s by the given condition
func DeleteMany(db testjack.DB, where *WhereClause) error {
	// sql select query, primary key provided by sequence
	sqlstr := `DELETE FROM jack.reports WHERE ` + where.condition
	testjack.Log(sqlstr, where.params...)

	if _, e := db.Exec(sqlstr, where.params...); e != nil {
		return e
	}

	return nil
}

// Upsert the `report` by its `id`.
func Upsert(db testjack.DB, report *Report) (*Report, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := testjack.Slice(getColumns(report), 0)

	// sql query
	sqlstr := `INSERT INTO jack.reports (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("id") ` +
		`DO UPDATE SET (` + strings.Join(_c, ", ") + `) = ( EXCLUDED.` + strings.Join(_c, ", EXCLUDED.") + `) ` +
		`RETURNING "id", "user_id", "timestamp", "questions", "standup_id", "status", "created_at", "updated_at"`
	testjack.Log(sqlstr, _v...)

	// run query
	cols := &columns{}
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&cols.ID, &cols.UserID, &cols.Timestamp, &cols.Questions, &cols.StandupID, &cols.Status, &cols.CreatedAt, &cols.UpdatedAt); e != nil {
		return nil, e
	}

	return &Report{cols}, nil
}

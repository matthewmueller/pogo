package template

import (
	"fmt"

	"github.com/matthewmueller/pogo/database"
)

// Base struct
type Base struct {
	Package string
	Schema  *database.Schema
}

// Generate the base template
func (b *Base) Generate() (string, error) {
	lines := ""

	// package
	lines += fmt.Sprintf("package %s\n", b.Package)

	// marker
	lines += "// GENERATED BY POGO. DO NOT EDIT.\n"

	// db interface
	lines += fmt.Sprintf(`
		// DB is the common interface for database operations that can be used with
		// types from schema '%s'.
		//
		// This should work with database/sql.DB and database/sql.Tx.
		type DB interface {
			Exec(string, ...interface{}) (pgx.CommandTag, error)
			Query(string, ...interface{}) (*pgx.Rows, error)
			QueryRow(string, ...interface{}) *pgx.Row
		}
	`, b.Schema.Name)

	// log interface
	lines += `
		// Log provides the log func used by generated queries.
		var Log = func(string, ...interface{}) {}
	`

	lines += `
		const (
			// UpsertDoNothing Do nothing if there's a conflict
			UpsertDoNothing = "DO NOTHING"
			// UpsertDoUpdate Perform an update when there's a conflict
			UpsertDoUpdate = "DO UPDATE"
		)
	`

	lines += `
		// Slice converts our columns into something the sql driver can understand
		func Slice(columns map[string]interface{}, offset int) (c []string, i []string, v []interface{}) {
			n := offset + 1
			for col, val := range columns {
				c = append(c, '"'+col+'"')
				i = append(i, "$"+strconv.Itoa(n))
				v = append(v, val)
				n++
			}
			return c, i, v
		}
	`

	return lines, nil
}

package template

import (
	"fmt"
	"sort"
	"strings"

	gen "github.com/matthewmueller/go-gen"
	"github.com/matthewmueller/pogo/database"
)

// Model struct
type Model struct {
	Package string
	Schema  *database.Schema
	Table   *database.Table
}

// Generate the base template
func (m *Model) Generate() (string, error) {
	type V map[string]interface{}

	template := gen.MustCreate("model")

	pkg := m.Package
	Model := gen.Pascal(gen.Singular(m.Table.Name))
	model := gen.Lower(gen.Singular(m.Table.Name))
	models := gen.Lower(gen.Plural(m.Table.Name))
	schema := gen.Lower(gen.Snake(m.Schema.Name))
	table := gen.Lower(gen.Snake(m.Table.Name))

	lines := ""

	// package
	lines += fmt.Sprintf("package %s\n", m.Package)

	// marker
	lines += "// GENERATED BY POGO. DO NOT EDIT.\n"

	// error handling
	lines += template(`
		// Err{{.Model}}NotFound returned if the {{.model}} is not found
		var Err{{.Model}}NotFound = errors.New("{{.model}} not found")
	`, V{
		"Model": Model,
		"model": model,
	})

	fields := ""
	for _, col := range m.Table.Columns {
		fields += fmt.Sprintf("%s *%s\n", gen.Camel(col.Name), col.GoType)
	}

	// user input struct
	lines += template(`
		// {{.Model}}Input model for '{{.schema}}.{{.table}}'
		type {{.Model}}Input struct {
			{{.fields}}
		}
	`, V{
		"Model":  Model,
		"schema": schema,
		"table":  table,
		"fields": fields,
	})

	fields = ""
	for _, col := range m.Table.Columns {
		if col.NotNull {
			fields += fmt.Sprintf("%s %s\n", gen.Pascal(col.Name), col.GoType)
		} else {
			fields += fmt.Sprintf("%s *%s\n", gen.Pascal(col.Name), col.GoType)
		}
	}

	// user struct
	lines += template(`
		// {{.Model}} model for "{{.schema}}"."{{.table}}"
		type {{.Model}} struct {
			{{.fields}}
		}
	`, V{
		"Model":  Model,
		"schema": schema,
		"table":  table,
		"fields": fields,
	})

	// new input struct
	lines += template(`
		// New "{{.schema}}"."{{.table}}" API
		func New() *{{.Model}}Input {
			return &{{.Model}}Input{}
		}	
	`, V{
		"Model":  Model,
		"schema": schema,
		"table":  table,
	})

	// setters
	for _, col := range m.Table.Columns {
		lines += template(`
		// {{.Name}} sets the "{{.name}}"
		func ({{.model}} *{{.Model}}Input) {{.Name}}({{.name}} {{.type}}) *{{.Model}}Input {
			{{.model}}.{{.name}} = &{{.name}}
			return {{.model}}
		}
	`, V{
			"Name":  gen.Pascal(col.Name),
			"name":  gen.Camel(col.Name),
			"type":  col.GoType,
			"Model": Model,
			"model": model,
			// "schema": schema,
			// "table":  table,
		})
	}

	// interfaces
	lines += template(`
		// MarshalJSON marshals the "{{.model}}" into JSON
		func ({{.model}} *{{.Model}}Input) MarshalJSON() ([]byte, error) {
			return json.Marshal({{.model}})
		}

		// UnmarshalJSON unmarshals json to a "{{.model}}"
		func ({{.model}} *{{.Model}}Input) UnmarshalJSON(data []byte) error {
			return json.Unmarshal(data, {{.model}})
		}

		func ({{.model}} *{{.Model}}Input) String() string {
			return "{{.model}}"
		}
	`, V{
		"Model": Model,
		"model": model,
	})

	fields = ""
	for _, col := range m.Table.Columns {
		fields += template(`
			if {{.model}}.{{.name}} != nil {
				columns["{{.column}}"] = *{{.model}}.{{.name}}
			}
		`, V{
			"column": col.Name,
			"name":   gen.Camel(col.Name),
			"model":  model,
		})
	}

	// get all the non-nil columns
	lines += template(`
		func getColumns({{.model}} *{{.Model}}Input) map[string]interface{} {
			columns := make(map[string]interface{})
			
			{{.fields}}

			return columns
		}
	`, V{
		"Model":  Model,
		"model":  model,
		"fields": fields,
	})

	// where clause
	lines += `
		// WhereClause is a struct to handle where clauses
		type WhereClause struct {
			condition string
			params    []interface{}
		}

		// Where specifies the conditions
		func Where(condition string, params ...interface{}) *WhereClause {
			return &WhereClause{
				condition: condition,
				params:    params,
			}
		}
	`

	var selectlist []string
	var scanlist []string
	var returnlist []string
	for _, col := range m.Table.Columns {
		selectlist = append(selectlist, `"`+col.Name+`"`)

		scan := fmt.Sprintf("&%s.%s", model, gen.Pascal(col.Name))
		scanlist = append(scanlist, scan)

		returnlist = append(returnlist, `"`+col.Name+`"`)
	}
	sort.Strings(selectlist)
	sort.Strings(scanlist)
	sort.Strings(returnlist)

	selects := strings.Join(selectlist, ", ")
	scans := strings.Join(scanlist, ", ")
	returns := strings.Join(returnlist, ", ")

	// primary key ops
	for _, col := range m.Table.Columns {
		if !col.IsPrimaryKey {
			continue
		}

		// find
		lines += template(`
			// Find a {{.Model}} by "{{.column}}"
			func Find(db pogo.DB, {{.name}} string) (*{{.Model}}, error) {
				// sql select query, primary key provided by sequence
				sqlstr := {{.tick}}
		SELECT {{.selects}}
		FROM "{{.schema}}"."{{.table}}"
		WHERE "{{.column}}" = $1
	{{.tick}}
				pogo.Log(sqlstr, &{{.name}})

				var {{.model}} {{.Model}}
				row := db.QueryRow(sqlstr, &{{.name}})
				if e := row.Scan({{.scans}}); e != nil {
					if e == pgx.ErrNoRows {
						return nil, Err{{.Model}}InputNotFound
					}
					return nil, e
				}

				return &u, nil
			}
		`, V{
			"tick":    "`",
			"pkg":     pkg,
			"column":  col.Name,
			"name":    gen.Camel(col.Name),
			"type":    col.GoType,
			"selects": selects,
			"scans":   scans,
			"returns": returns,
			"schema":  schema,
			"table":   table,
			"Model":   Model,
			"model":   model,
		})

		// update
		lines += template(`
		// Update a "{{.model}}" in "{{.schema}}"."{{.table}}" by its "{{.column}}"
		func Update(db {{.pkg}}.DB, {{.column}} {{.type}}, {{.model}}Input *{{.Model}}Input) (*{{.Model}}, error) {
			fields := getColumns({{.model}}Input)

			// don't update the primary key
			delete(fields, "{{.column}}")

			// prepare the slices
			_c, _i, _v := {{.pkg}}.Slice(fields, 1)

			// sql query
			sqlstr := {{.tick}}UPDATE "{{.schema}}"."{{.table}}" SET ({{.tick}} +
					strings.Join(_c, ", ") + 
				{{.tick}}) = ({{.tick}} +
					strings.Join(_i, ", ") + 
				{{.tick}})
				WHERE "{{.column}}" = $1
				RETURNING {{.returns}}{{.tick}}

			// setup query
			values := append([]interface{}{ &{{.name}} }, _v...)
			{{.pkg}}.Log(sqlstr, values...)

			// run the query
			var {{.model}} {{.Model}}
			row := db.QueryRow(sqlstr, values...)
			if e := row.Scan({{.scans}}); e != nil {
				if e == pgx.ErrNoRows {
					return nil,  Err{{.Model}}NotFound
				}
				return nil, e
			}

			return &{{.model}}, nil
		}	
	`, V{
			"tick":    "`",
			"pkg":     pkg,
			"column":  col.Name,
			"name":    gen.Camel(col.Name),
			"type":    col.GoType,
			"selects": selects,
			"scans":   scans,
			"returns": returns,
			"schema":  schema,
			"table":   table,
			"Model":   Model,
			"model":   model,
		})

		// delete
		lines += template(`
			// Delete a "{{.model}}" from the "{{.schema}}"."{{.table}}" table
			func Delete(db {{.pkg}}.DB, {{.name}} {{.type}}) error {
				// sql query
				sqlstr := {{.tick}}DELETE FROM "{{.schema}}"."{{.table}}" WHERE "{{.name}}" = $1{{.tick}}
				{{.pkg}}.Log(sqlstr, {{.name}})

				// run query
				if _, e := db.Exec(sqlstr, {{.name}}); e != nil {
					if e == pgx.ErrNoRows {
						return Err{{.Model}}NotFound
					}
					return e
				}

				return nil
			}
		`, V{
			"tick":    "`",
			"pkg":     pkg,
			"column":  col.Name,
			"name":    gen.Camel(col.Name),
			"type":    col.GoType,
			"selects": selects,
			"scans":   scans,
			"returns": returns,
			"schema":  schema,
			"table":   table,
			"Model":   Model,
			"model":   model,
		})

		// upsert
		lines += template(`
			// Upsert the "{{.model}}" by its "{{.name}}".
			func Upsert(db {{.pkg}}.DB, {{.model}}Input *{{.Model}}Input) (*{{.Model}}, error) {
				// get all the non-nil columns and prepare them for the query
				_c, _i, _v := {{.pkg}}.Slice(getColumns({{.model}}Input), 0)

				// sql query
				sqlstr := {{.tick}}INSERT INTO "{{.schema}}"."{{.table}}" ({{.tick}} + strings.Join(_c, ", ") + {{.tick}}) {{.tick}} +
				{{.tick}}VALUES ({{.tick}} + strings.Join(_i, ", ") + {{.tick}}) {{.tick}} +
				{{.tick}}ON CONFLICT ("{{.name}}") {{.tick}} +
				{{.tick}}DO UPDATE SET ({{.tick}} + strings.Join(_c, ", ") + {{.tick}}) = ( EXCLUDED.{{.tick}} + strings.Join(_c, ", EXCLUDED.") + {{.tick}}) {{.tick}} +
				{{.tick}}RETURNING {{.returns}}{{.tick}}
				{{.pkg}}.Log(sqlstr, _v...)

				// run query
				var {{.model}} {{.Model}}
				row := db.QueryRow(sqlstr, _v...)
				if e := row.Scan({{.scans}}); e != nil {
					return nil, e
				}

				return &{{.model}}, nil
			}
		`, V{
			"tick":    "`",
			"pkg":     pkg,
			"column":  col.Name,
			"name":    gen.Camel(col.Name),
			"type":    col.GoType,
			"selects": selects,
			"scans":   scans,
			"returns": returns,
			"schema":  schema,
			"table":   table,
			"Model":   Model,
			"model":   model,
		})
	}

	// unique indexes
	for _, idx := range m.Table.Indexes {
		if idx.IsPrimary || !idx.IsUnique {
			continue
		}

		var columnlist []string
		var namelist []string
		var paramlist []string
		var wherelist []string
		var deletelist []string
		var appendlist []string
		for i, col := range idx.Columns {
			columnlist = append(columnlist, col.Name)
			namelist = append(namelist, gen.Camel(col.Name))

			param := fmt.Sprintf("%s %s", gen.Camel(col.Name), col.GoType)
			paramlist = append(paramlist, param)

			where := fmt.Sprintf("\"%s\" = $%d", col.Name, i+1)
			wherelist = append(wherelist, where)

			delete := fmt.Sprintf("delete(fields, \"%s\")", col.Name)
			deletelist = append(deletelist, delete)

			a := fmt.Sprintf("append(values, \"%s\")", gen.Camel(col.Name))
			appendlist = append(appendlist, a)
		}
		sort.Strings(columnlist)
		sort.Strings(paramlist)
		sort.Strings(wherelist)
		sort.Strings(deletelist)
		sort.Strings(appendlist)

		method := gen.Pascal(strings.Join(columnlist, " "))
		description := fmt.Sprintf("\"%s\"", strings.Join(columnlist, "\" and \""))
		columns := strings.Join(columnlist, ", ")
		params := strings.Join(paramlist, ", ")
		wheres := strings.Join(wherelist, " AND ")
		vars := strings.Join(namelist, ", ")
		deletes := strings.Join(deletelist, "\n")
		appends := strings.Join(appendlist, "\n")

		// find by
		lines += template(`
			// FindBy{{.method}} find a {{.model}} by {{.description}}
			func FindBy{{.method}}(db {{.pkg}}.DB, {{.params}}) (*{{.Model}}, error) {
				// sql select query, primary key provided by sequence
				sqlstr := {{.tick}}
		SELECT {{.selects}}
		FROM "{{.schema}}"."{{.table}}"
		WHERE {{.wheres}}
	{{.tick}}
				{{.pkg}}.Log(sqlstr, {{.vars}})

				var {{.model}} {{.Model}}
				row := db.QueryRow(sqlstr, {{.vars}})
				err := row.Scan({{.scans}})
				if err != nil {
					if err == pgx.ErrNoRows {
						return nil,  Err{{.Model}}NotFound
					}
					return nil, err
				}

				return &{{.model}}, nil
			}
		`, V{
			"tick":        "`",
			"pkg":         pkg,
			"method":      method,
			"description": description,
			"columns":     columns,
			"params":      params,
			"wheres":      wheres,
			"vars":        vars,
			"selects":     selects,
			"scans":       scans,
			"returns":     returns,
			"schema":      schema,
			"table":       table,
			"Model":       Model,
			"model":       model,
		})

		lines += template(`
		// UpdateBy{{.method}} find a {{.Model}}
		func UpdateBy{{.method}}(db {{.pkg}}.DB, {{.params}}, {{.model}}Input *{{.Model}}Input) (*{{.Model}}, error) {
			fields := getColumns({{.model}}Input)

			// don't update the keys
			{{.deletes}}

			// prepare the slices
			_c, _i, _v := {{.pkg}}.Slice(fields, {{.numcols}})

			// sql query
			sqlstr := {{.tick}}UPDATE "{{.schema}}"."{{.table}}" SET ({{.tick}} +
				strings.Join(_c, ", ") + {{.tick}}) = ({{.tick}} +
				strings.Join(_i, ", ") + {{.tick}}) {{.tick}} +
				{{.tick}}WHERE {{.wheres}} {{.tick}} +
				{{.tick}}RETURNING {{.returns}}{{.tick}}

			// setup the query
			values := []interface{}{}
			{{.appends}}
			values = append(values, _v...)
			{{.pkg}}.Log(sqlstr, values...)

			// run the query
			var {{.model}} {{.Model}}
			row := db.QueryRow(sqlstr, values...)
			if e := row.Scan({{.scans}}); e != nil {
				if e == pgx.ErrNoRows {
					return nil, Err{{.Model}}NotFound
				}
				return nil, e
			}

			return &{{.model}}, nil
		}
		`, V{
			"tick":        "`",
			"pkg":         pkg,
			"method":      method,
			"description": description,
			"numcols":     len(columnlist),
			"columns":     columns,
			"params":      params,
			"wheres":      wheres,
			"deletes":     deletes,
			"appends":     appends,
			"vars":        vars,
			"selects":     selects,
			"scans":       scans,
			"returns":     returns,
			"schema":      schema,
			"table":       table,
			"Model":       Model,
			"model":       model,
		})

		lines += template(`
			// DeleteBy{{.method}} deletes a "{{.model}}"
			func DeleteBy{{.method}}(db {{.pkg}}.DB, {{.params}}) error {
				// sql delete query
				sqlstr := {{.tick}}DELETE FROM "{{.schema}}"."{{.table}}" WHERE {{.wheres}}{{.tick}}
				{{.pkg}}.Log(sqlstr, {{.vars}})

				if _, e := db.Exec(sqlstr, {{.vars}}); e != nil {
					if e == pgx.ErrNoRows {
						return Err{{.model}}NotFound
					}
					return e
				}

				return nil
			}	
		`, V{
			"tick":        "`",
			"pkg":         pkg,
			"method":      method,
			"description": description,
			"numcols":     len(columnlist),
			"columns":     columns,
			"params":      params,
			"wheres":      wheres,
			"deletes":     deletes,
			"appends":     appends,
			"vars":        vars,
			"selects":     selects,
			"scans":       scans,
			"returns":     returns,
			"schema":      schema,
			"table":       table,
			"Model":       Model,
			"model":       model,
		})

		lines += template(`
			// UpsertBy{{.method}} find a "{{.Model}}"
			func UpsertBy{{.method}}(db {{.pkg}}.DB, {{.model}}Input *{{.Model}}Input) (*{{.Model}}, error) {
				// get all the non-nil columns and prepare them for the query
				_c, _i, _v := {{.pkg}}.Slice(getColumns({{.model}}Input), 0)

				// sql query
				sqlstr := {{.tick}}INSERT INTO "{{.schema}}"."{{.table}}" ({{.tick}} + strings.Join(_c, ", ") + {{.tick}}) {{.tick}} +
				{{.tick}}VALUES ({{.tick}} + strings.Join(_i, ", ") + {{.tick}}) {{.tick}} +
				{{.tick}}ON CONFLICT ({{.columns}}) {{.tick}} +
				{{.tick}}DO UPDATE SET ({{.tick}} + strings.Join(_c, ", ") + {{.tick}}) = ( EXCLUDED.{{.tick}} + strings.Join(_c, ", EXCLUDED.") + {{.tick}}) {{.tick}} +
				{{.tick}}RETURNING {{.returns}}{{.tick}}
				{{.pkg}}.Log(sqlstr, _v...)

				// run query
				var {{.model}} {{.Model}}
				row := db.QueryRow(sqlstr, _v...)
				if e := row.Scan({{.scans}}); e != nil && e != pgx.ErrNoRows {
					return nil, e
				}

				return &{{.model}}, nil
			}	
		`, V{
			"tick":        "`",
			"pkg":         pkg,
			"method":      method,
			"description": description,
			"numcols":     len(columnlist),
			"columns":     columns,
			"params":      params,
			"wheres":      wheres,
			"deletes":     deletes,
			"appends":     appends,
			"vars":        vars,
			"selects":     selects,
			"scans":       scans,
			"returns":     returns,
			"schema":      schema,
			"table":       table,
			"Model":       Model,
			"model":       model,
		})
	}

	// find many
	lines += template(`
		// FindMany find many "{{.model}}"'s by a given condition
		func FindMany(db {{.pkg}}.DB, where *WhereClause) ({{.models}} []*{{.Model}}, err error) {
			// sql select query, primary key provided by sequence
			sqlstr := {{.tick}}
			SELECT {{.selects}}
			FROM "{{.schema}}"."{{.table}}"
			WHERE {{.tick}} + where.condition
			{{.pkg}}.Log(sqlstr, where.params...)

			rows, err := db.Query(sqlstr, where.params...)
			if err != nil {
				return {{.models}}, err
			}
			defer rows.Close()

			for rows.Next() {
				var {{.model}} {{.Model}}
				if e := rows.Scan({{.scans}}); e != nil {
					if e == pgx.ErrNoRows {
						return {{.models}}, Err{{.Model}}NotFound
					}
					return {{.models}}, err
				}
				{{.models}} = append({{.models}}, &{{.model}})
			}
			if rows.Err() != nil {
				return {{.models}}, rows.Err()
			}

			// ensure we return an empty array
			// rather than nil when we marshal
			// if len({{.models}}) == 0 {
			// 	return make([]*{{.Model}}, 0), nil
			// }

			return {{.models}}, nil
		}
	`, V{
		"tick":    "`",
		"pkg":     pkg,
		"selects": selects,
		"scans":   scans,
		"returns": returns,
		"schema":  schema,
		"table":   table,
		"Model":   Model,
		"model":   model,
		"models":  models,
	})

	// update many
	lines += template(`
		// UpdateMany rows in "{{.schema}}"."{{.table}}" by a given condition
		func UpdateMany(db {{.pkg}}.DB, where *WhereClause, {{.model}}Input *{{.Model}}Input) ({{.models}} []*{{.Model}}, err error) {
			// prepare the slices
			_c, _i, _v := {{.pkg}}.Slice(getColumns({{.model}}Input), len(where.params))

			// sql query
			sqlstr := {{.tick}}UPDATE "{{.schema}}"."{{.table}}" SET ({{.tick}} +
				strings.Join(_c, ", ") + {{.tick}}) = ({{.tick}} +
				strings.Join(_i, ", ") + {{.tick}}) {{.tick}} +
				{{.tick}}WHERE {{.tick}} + where.condition + {{.tick}} {{.tick}} +
				{{.tick}}RETURNING {{.returns}}{{.tick}}

			// setup the query
			values := []interface{}{}
			values = append(values, where.params...)
			values = append(values, _v...)
			{{.pkg}}.Log(sqlstr, values...)

			// run query
			rows, err := db.Query(sqlstr, values...)
			if err != nil {
				return {{.models}}, err
			}
			defer rows.Close()

			for rows.Next() {
				var {{.model}} {{.Model}}
				if e := rows.Scan({{.scans}}); e != nil {
					if e == pgx.ErrNoRows {
						return {{.models}}, Err{{.Model}}NotFound
					}
					return {{.models}}, err
				}
				{{.models}} = append({{.models}}, &{{.model}})
			}
			if rows.Err() != nil {
				return {{.models}}, rows.Err()
			}

			// ensure we return an empty array
			// rather than nil when we marshal
			// if len({{.models}}) == 0 {
			// 	return make([]*{{.Model}}, 0), nil
			// }

			return {{.models}}, nil
		}
	`, V{
		"tick":    "`",
		"pkg":     pkg,
		"selects": selects,
		"scans":   scans,
		"returns": returns,
		"schema":  schema,
		"table":   table,
		"Model":   Model,
		"model":   model,
		"models":  models,
	})

	lines += template(`
		// DeleteMany delete many "{{.model}}"'s by the given condition
		func DeleteMany(db {{.pkg}}.DB, where *WhereClause) error {
			// sql select query, primary key provided by sequence
			sqlstr := {{.tick}}DELETE FROM "{{.schema}}"."{{.table}}" WHERE {{.tick}} + where.condition
			{{.pkg}}.Log(sqlstr, where.params...)

			if _, e := db.Exec(sqlstr, where.params...); e != nil {
				return e
			}

			return nil
		}	
	`, V{
		"tick":    "`",
		"pkg":     pkg,
		"selects": selects,
		"scans":   scans,
		"returns": returns,
		"schema":  schema,
		"table":   table,
		"Model":   Model,
		"model":   model,
		"models":  models,
	})

	// find one
	lines += template(`
		// FindOne find one {{.model}} by a condition
		func FindOne(db {{.pkg}}.DB, where *WhereClause) (*{{.Model}}, error) {
			// sql select query, primary key provided by sequence
			sqlstr := {{.tick}}
			SELECT {{.selects}}
			FROM "{{.schema}}"."{{.table}}"
			WHERE {{.tick}} + where.condition
			{{.pkg}}.Log(sqlstr, where.params...)

			var {{.model}} {{.Model}}
			row := db.QueryRow(sqlstr, where.params...)
			if e := row.Scan({{.scans}}); e != nil {
				if e == pgx.ErrNoRows {
					return nil,  Err{{.Model}}NotFound
				}
				return nil, e
			}

			return &{{.model}}, nil
		}	
	`, V{
		"tick":    "`",
		"pkg":     pkg,
		"selects": selects,
		"scans":   scans,
		"returns": returns,
		"schema":  schema,
		"table":   table,
		"Model":   Model,
		"model":   model,
		"models":  models,
	})

	// insert
	lines += template(`
		// Insert a "{{.model}}" into the "{{.schema}}"."{{.table}}"
		func Insert(db {{.pkg}}.DB, {{.model}}Input *{{.Model}}Input) (*{{.Model}}, error) {
			// get all the non-nil columns and prepare them for the query
			_c, _i, _v := {{.pkg}}.Slice(getColumns({{.model}}Input), 0)

			// sql insert query, primary key provided by sequence
			sqlstr := {{.tick}}
			INSERT INTO "{{.schema}}"."{{.table}}" ({{.tick}}+strings.Join(_c, ", ")+{{.tick}})
			VALUES ({{.tick}}+strings.Join(_i, ", ")+{{.tick}})
			RETURNING {{.returns}}
			{{.tick}}
			{{.pkg}}.Log(sqlstr, _v...)

			var {{.model}} {{.Model}}
			row := db.QueryRow(sqlstr, _v...)
			if e := row.Scan({{.scans}}); e != nil {
				return nil, e
			}

			return &{{.model}}, nil
		}	
	`, V{
		"tick":    "`",
		"pkg":     pkg,
		"selects": selects,
		"scans":   scans,
		"returns": returns,
		"schema":  schema,
		"table":   table,
		"Model":   Model,
		"model":   model,
		"models":  models,
	})

	return lines, nil
}

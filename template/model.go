package template

import (
	gen "github.com/matthewmueller/go-gen"
	"github.com/matthewmueller/pogo/database"
)

// Model struct
type Model struct {
	Directory string
	Schema    *database.Schema
	Table     *database.Table
}

var model = gen.MustCompile("model", `
{{/*************************************************************************/}}
{{/* Variables */}}
{{/*************************************************************************/}}

{{ $tick := "`+"`"+`" }}
{{ $package := package .Directory }}
{{ $package := lowercase (camel .Table.Name) }}
{{ $Model := capitalize (singular .Table.Name) }}
{{ $model := lowercase (camel (singular .Table.Name)) }}
{{ $table := (join "." (wrap "\"" .Schema.Name) (wrap "\"" .Table.Name)) }}

{{/*************************************************************************/}}
{{/* Our Package */}}
{{/*************************************************************************/}}

package {{$package}}

{{/*************************************************************************/}}
{{/* Pogo marker */}}
{{/*************************************************************************/}}

// GENERATED BY POGO. DO NOT EDIT.

{{/*************************************************************************/}}
{{/* Errors */}}
{{/*************************************************************************/}}

// Err{{$Model}}NotFound returned if the {{$model}} is not found
var Err{{$Model}}NotFound = errors.New("{{$model}} not found")

{{/*************************************************************************/}}
{{/* This is our public model based */}}
{{/*************************************************************************/}}

// {{$Model}} struct in {{$tick}}{{$table}}{{$tick}}
type User struct {
	{{ range .Table.Columns -}}
	{{- $field := uncapitalize .Name -}}
	{{- $type := when .NotNull .GoType (pointer .GoType) -}}
	{{$field}} {{$type}} {{$tick}}json:"{{ .Name }},omitempty"{{$tick}}{{ if .Comment }}// {{ .Comment }}{{ end }}
	{{ end -}}
}

{{/*************************************************************************/}}
{{/* Opaque struct for inputs, interacted with via the fluent API */}}
{{/*************************************************************************/}}

// {{$Model}}Input is an opaque struct for {{$tick}}{{$table}}{{$tick}}
type {{$Model}}Input struct {
	{{ range .Table.Columns -}}
		{{- $field := uncapitalize .Name -}}
		{{- $type := pointer .GoType -}}
		{{$field}} {{$type}} {{$tick}}json:"{{ .Name }},omitempty"{{$tick}}
		{{ if .Comment -}}
			// {{ .Comment }}
		{{- end }}
	{{- end }}
}

{{/*************************************************************************/}}
{{/* Initialize the fluent API */}}
{{/*************************************************************************/}}

// New {{$Model}} input
func New() *{{$Model}}Input {
	return &{{$Model}}Input{}
}

{{/*************************************************************************/}}
{{/* Generate each of the fluent methods for the fluent parameter API      */}}
{{/*************************************************************************/}}

{{ range .Table.Columns }}
{{- $Field := camel .Name -}}
{{- $field := uncapitalize .Name -}}
// {{$Field}} sets the {{$tick}}{{.Name}}{{$tick}} field.
func ({{$model}} *{{$Model}}Input) {{$Field}}({{$field}} string) *{{$Model}}Input {
	{{$model}}.{{$field}} = &{{$field}}
	return {{$model}}
}
{{ end }}

{{/*************************************************************************/}}
{{/* Implement the Marshaler & Unmarshaler interfaces */}}
{{/*************************************************************************/}}

// MarshalJSON marshals the {{$tick}}{{$model}}{{$tick}} into JSON
func ({{$model}} *{{$Model}}Input) MarshalJSON() ([]byte, error) {
	return json.Marshal({{$model}})
}

// UnmarshalJSON unmarshals json to a {{$tick}}{{$model}}{{$tick}}
func ({{$model}} *{{$Model}}Input) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, {{$model}})
}

// MarshalJSON marshals the {{$tick}}{{$model}}{{$tick}} into JSON
func ({{$model}} *{{$Model}}) MarshalJSON() ([]byte, error) {
	return json.Marshal({{$model}})
}

// UnmarshalJSON unmarshals json to a {{$tick}}{{$model}}{{$tick}}
func ({{$model}} *{{$Model}}) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, {{$model}})
}

{{/*************************************************************************/}}
{{/* Implement the Stringer interface */}}
{{/*************************************************************************/}}

func ({{$model}} *{{$Model}}Input) String() string {
	return "{{$model}}"
}

func ({{$model}} *{{$Model}}) String() string {
	return "{{$model}}"
}

{{/*************************************************************************/}}
{{/* Private helper to get all the non-nil columns in our table */}}
{{/*************************************************************************/}}

// get all the non-nil columns
func getColumns({{$model}} *{{$Model}}Input) map[string]interface{} {
	columns := make(map[string]interface{})
	
	{{ range .Table.Columns }}
	{{ $field := uncapitalize .Name -}}
	if {{$model}}.{{$field}} != nil {
		columns["{{.Name}}"] = *{{$model}}.{{$field}}
	}
	{{ end }}

  return columns
}

{{/*****************************************************************************/}}
{{/* Public where helper for a couple of the methods */}}
{{/*****************************************************************************/}}

// WhereClause is a struct to handle where clauses
type WhereClause struct {
	condition string
	params    []interface{}
}

// Where specifies the conditions
func Where(condition string, params ...interface{}) *WhereClause {
	return &WhereClause{
		condition: condition,
		params:    params,
	}
}

{{/*************************************************************************/}}
{{/* pogo.$TABLE.Find(): find one row by it's primary key */}}
{{/*************************************************************************/}}

{{ range .Table.Columns -}}
{{ if .IsPrimaryKey -}}
{{ $field := uncapitalize .Name }}
// Find a {{$model}} by its "{{.Name}}"
func Find(db {{ $pkg }}.DB, {{.Name}} {{$field}}) (*{{$Model}}, error) {
	_{{ $p.Name }} := {{ decode .Settings.Package $p.Name $pt }}

	// sql select query, primary key provided by sequence
	sqlstr := {{ $tick }}
	SELECT {{ $cof }}
	FROM {{ $t }}
	WHERE "{{ $p.Name }}" = $1
	{{ $tick }}
	{{$pkg}}.Log(sqlstr, _{{ $p.Name }})

	cols := &columns{}
	row := db.QueryRow(sqlstr, _{{ $p.Name }})
  if e := row.Scan({{ $cog }}); e != nil {
    if e == pgx.ErrNoRows {
      return nil,  Err{{ $m }}NotFound
    }
    return nil, e
  }

	return &{{ $m }}{cols}, nil
}
{{- end }}
{{- end }}
`)

// // columns in {{ $tick }}{{ $t }}{{ $tick }}
// type columns struct {
//   {{ range .Table.Columns }}{{ $t := coerce $.Schema .DataType }}
//   {{ .Name | capitalize }} *{{ $t }} {{ $tick }}json:"{{ .Name }},omitempty"{{ $tick }} {{ if .Comment }}// {{ .Comment }}{{ end }}{{ end }}
// }

// {{/*************************************************************************/}}
// {{/* This contains our fluent parameter container */}}
// {{/*************************************************************************/}}

// // {{ $m }} model
// type {{ $m }} struct {
// 	columns *columns
// }

// {{/*************************************************************************/}}
// {{/* Helper to create the fluent API */}}
// {{/*************************************************************************/}}

// // New {{ $tick }}{{ $t }}{{ $tick }} API
// func New() *{{ $m }} {
// 	return &{{ $m }}{&columns{}}
// }

// {{/*************************************************************************/}}
// {{/* Generate each of the fluent methods for the fluent parameter API      */}}
// {{/* This is very messy right now because we have some custom accessors    */}}
// {{/* for uuid.                                                             */}}
// {{/*                                                                       */}}
// {{/* NOTE: This would probably be better solved at pgx level, but I spent  */}}
// {{/* far too long trying to get that working with scanning nil *uuid.UUID  */}}
// {{/* Fortunately, this isn't a big deal, because the API can remain stable */}}
// {{/*************************************************************************/}}

// {{ range .Table.Columns }}
// {{- $nu := .Name | capitalize -}}
// {{- $nc := .Name | camelize | mayberename -}}
// {{- $dt := coerceaccessor $.Schema .DataType -}}
// // {{ $nu }} sets the {{ $tick }}{{ .Name }}{{ $tick }}
// func ({{ $mv }} *{{ $m }}) {{ $nu }}({{ $nc }} {{ $dt }}) *{{ $m }} {
// 	{{ $mv }}.columns.{{ $nu }} = {{ decode $pkg $nc $dt }}
// 	return {{ $mv }}
// }

// // Get{{ $nu }} returns the {{ $tick }}{{ .Name }}{{ $tick }} if set
// func ({{ $mv }} *{{ $m }}) Get{{ $nu }}() ({{ $nc }} *{{ $dt }}) {
// 	return {{ encode $pkg $mv $nu $dt }}
// }
// {{ end }}

// {{/*************************************************************************/}}
// {{/* Implement the Marshaler & Unmarshaler interfaces */}}
// {{/*************************************************************************/}}

// // MarshalJSON marshals the {{ $tick }}{{ $mv }}{{ $tick }} into JSON
// func ({{ $mv }} *{{ $m }}) MarshalJSON() ([]byte, error) {
// 	return json.Marshal({{ $mv }}.columns)
// }

// // UnmarshalJSON unmarshals json to a {{ $tick }}{{ $mv }}{{ $tick }}
// func ({{ $mv }} *{{ $m }}) UnmarshalJSON(data []byte) error {
// 	return json.Unmarshal(data, {{ $mv }}.columns)
// }

// {{/*************************************************************************/}}
// {{/* Implement the Stringer interface */}}
// {{/*************************************************************************/}}

// func ({{ $mv }} *{{ $m }}) String() string {
// 	return "{{ $mv}}"
// }

// {{/*************************************************************************/}}
// {{/* Private helper to get all the non-nil columns in our table */}}
// {{/*************************************************************************/}}

// // get all the non-nil columns
// func getColumns({{ $mv }} *{{ $m }}) map[string]interface{} {
//   columns := make(map[string]interface{})
//   {{ range .Table.Columns }}{{ $col := .Name | capitalize }}
//   if {{ $mv }}.columns.{{ $col }} != nil {
//     columns["{{ .Name }}"] = *{{ $mv }}.columns.{{ $col }}
//   }{{ end }}

//   return columns
// }

// {{/*****************************************************************************/}}
// {{/* Public where helper for a couple of the methods */}}
// {{/*****************************************************************************/}}

// // WhereClause is a struct to handle where clauses
// type WhereClause struct {
// 	condition string
// 	params    []interface{}
// }

// // Where specifies the conditions
// func Where(condition string, params ...interface{}) *WhereClause {
// 	return &WhereClause{
// 		condition: condition,
// 		params:    params,
// 	}
// }

// {{/*************************************************************************/}}
// {{/* pogo.$TABLE.Find(): find one row by it's primary key */}}
// {{/*************************************************************************/}}

// {{ if $p }}
// // Find a {{ $mv }} by "{{ $p.Name }}"
// func Find(db {{ $pkg }}.DB, {{ $p.Name }} {{ $pt }}) (*{{ $m }}, error) {
// 	_{{ $p.Name }} := {{ decode .Settings.Package $p.Name $pt }}

// 	// sql select query, primary key provided by sequence
// 	sqlstr := {{ $tick }}
// 	SELECT {{ $cof }}
// 	FROM {{ $t }}
// 	WHERE "{{ $p.Name }}" = $1
// 	{{ $tick }}
// 	{{$pkg}}.Log(sqlstr, _{{ $p.Name }})

// 	cols := &columns{}
// 	row := db.QueryRow(sqlstr, _{{ $p.Name }})
//   if e := row.Scan({{ $cog }}); e != nil {
//     if e == pgx.ErrNoRows {
//       return nil,  Err{{ $m }}NotFound
//     }
//     return nil, e
//   }

// 	return &{{ $m }}{cols}, nil
// }
// {{ end }}

// {{/*************************************************************************/}}
// {{/* pogo.$TABLE.FindBy...(): find a row by its unique non-primary indexes */}}
// {{/*************************************************************************/}}

// {{ range $idx := $idxs }}
// {{ $cols := idxcolnames $idx }}
// {{ $idxmethod := map $cols mcapitalize | join "And" }}
// {{ $idxparams := idxparams $.Schema $idx }}
// {{ $indexvars := map $cols mcamelize | join ", " }}
// // FindBy{{ $idxmethod }} find a {{ $mv }} by {{ $cols | join "{{ $tick }} and {{ $tick }}" | printf "{{ $tick }}%s{{ $tick }}"}}
// func FindBy{{ $idxmethod }}(db {{ $pkg }}.DB, {{ $idxparams }}) (*{{ $m }}, error) {
// 	// sql select query, primary key provided by sequence
// 	sqlstr := {{ $tick }}
// 	SELECT {{ $cof }}
// 	FROM {{ $t }}
// 	WHERE {{ idxwhere $idx }}
// 	{{ $tick }}
// 	{{ $pkg }}.Log(sqlstr, {{ $indexvars }})

// 	cols := &columns{}
// 	row := db.QueryRow(sqlstr, {{ $indexvars }})
// 	err := row.Scan({{ $cog }})
// 	if err != nil {
// 		if err == pgx.ErrNoRows {
// 			return nil,  Err{{ $m }}NotFound
// 		}
// 		return nil, err
// 	}

// 	return &{{ $m }}{cols}, nil
// }
// {{ end }}

// {{/*************************************************************************/}}
// {{/* pogo.$TABLE.FindMany(): find many rows by a condition */}}
// {{/*************************************************************************/}}

// // FindMany find many {{ $tick }}{{ $mv }}{{ $tick }}s by a given condition
// func FindMany(db {{ $pkg }}.DB, where *WhereClause) ([]*{{ $m }}, error) {
// 	var _o []*{{ $m }}

// 	// sql select query, primary key provided by sequence
// 	sqlstr := {{ $tick }}
// 	SELECT {{ $cof }}
// 	FROM {{ $t }}
// 	WHERE {{ $tick }} + where.condition
// 	{{ $pkg }}.Log(sqlstr, where.params...)

//   rows, err := db.Query(sqlstr, where.params...)
//   if err != nil {
//     return _o, err
//   }
//   defer rows.Close()

//   for rows.Next() {
// 		cols := &columns{}
//     if e := rows.Scan({{ $cog }}); e != nil {
// 			if e == pgx.ErrNoRows {
// 				return _o, Err{{ $m }}NotFound
// 			}
// 			return _o, err
// 		}
//     _o = append(_o, &{{ $m }}{cols})
//   }
//   if rows.Err() != nil {
//     return _o, rows.Err()
//   }

// 	// ensure we return an empty array
// 	// rather than nil when we marshal
// 	if len(_o) == 0 {
// 		return make([]*{{ $m }}, 0), nil
// 	}

//   return _o, nil
// }

// {{/*************************************************************************/}}
// {{/* pogo.$TABLE.FindOne(): find exactly one row by a condition */}}
// {{/*************************************************************************/}}

// // FindOne find one {{ $mv }} by a condition
// func FindOne(db {{ $pkg }}.DB, where *WhereClause) (*{{ $m }}, error) {
// 	// sql select query, primary key provided by sequence
// 	sqlstr := {{ $tick }}
// 	SELECT {{ $cof }}
// 	FROM {{ $t }}
// 	WHERE {{ $tick }} + where.condition
// 	{{ $pkg }}.Log(sqlstr, where.params...)

// 	cols := &columns{}
//   row := db.QueryRow(sqlstr, where.params...)
//   if e := row.Scan({{ $cog }}); e != nil {
// 		if e == pgx.ErrNoRows {
//       return nil,  Err{{ $m }}NotFound
//     }
// 		return nil, e
// 	}

//   return &{{ $m }}{cols}, nil
// }

// {{/*************************************************************************/}}
// {{/* pogo.$TABLE.Insert(): insert a new row into the table */}}
// {{/*************************************************************************/}}

// // Insert a {{ $tick }}{{ $mv }}{{ $tick }} into the {{ $tick }}{{ $t }}{{ $tick }} table.
// func Insert(db {{ $pkg }}.DB, {{ $mv }} *{{ $m }}) (*{{ $m }}, error) {
// 	// get all the non-nil columns and prepare them for the query
// 	_c, _i, _v := {{ $pkg }}.Slice(getColumns({{ $mv }}), 0)

// 	// sql insert query, primary key provided by sequence
// 	sqlstr := {{ $tick }}
// 	INSERT INTO {{ $t }} ({{ $tick }} + strings.Join(_c, ", ") + {{ $tick }})
// 	VALUES ({{ $tick }} + strings.Join(_i, ", ") + {{ $tick }})
// 	RETURNING {{ $cof }}
// 	{{ $tick }}
// 	{{ $pkg }}.Log(sqlstr, _v...)

// 	cols := &columns{}
// 	row := db.QueryRow(sqlstr, _v...)
// 	if e := row.Scan({{ $cog }}); e != nil {
//     return nil, e
//   }

// 	return &{{ $m }}{cols}, nil
// }

// {{/*************************************************************************/}}
// {{/* pogo.$TABLE.Update(): update an existing row in the table */}}
// {{/*************************************************************************/}}

// // Update a {{ $mv }} by its {{ $tick }}{{ $p.Name }}{{ $tick }}
// func Update(db {{ $pkg }}.DB, {{ $p.Name }} {{ $pt }}, {{ $mv }} *{{ $m }}) (*{{ $m }}, error) {
// 	_{{ $p.Name }} := {{ decode .Settings.Package $p.Name $pt }}
// 	fields := getColumns({{ $mv }})

// 	// don't update the primary key
// 	delete(fields, "{{ $p.Name }}")

// 	// prepare the slices
// 	_c, _i, _v := {{ $pkg }}.Slice(fields, 1)

// 	// sql query
// 	sqlstr := {{ $tick }}UPDATE {{ $t }} SET ({{ $tick }} +
// 		strings.Join(_c, ", ") + {{ $tick }}) = ({{ $tick }} +
// 		strings.Join(_i, ", ") + {{ $tick }})
// 		WHERE "{{ $p.Name }}" = $1
// 		RETURNING {{ $cof }}{{ $tick }}

// 	// setup query
// 	values := append([]interface{}{ _{{ $p.Name }} }, _v...)
// 	{{ $pkg }}.Log(sqlstr, values...)

// 	// run the query
// 	cols := &columns{}
// 	row := db.QueryRow(sqlstr, values...)
// 	if e := row.Scan({{ $cog }}); e != nil {
// 		if e == pgx.ErrNoRows {
//       return nil,  Err{{ $m }}NotFound
//     }
//     return nil, e
//   }

// 	return &{{ $m }}{cols}, nil
// }

// {{/*****************************************************************************/}}
// {{/* pogo.$TABLE.UpdateBy...(): update a row by its unique non-primary indexes */}}
// {{/*****************************************************************************/}}

// {{ range $idx := $idxs }}
// {{ $cols := idxcolnames $idx }}
// {{ $idxmethod := map $cols mcapitalize | join "And" }}
// {{ $idxparams := idxparams $.Schema $idx }}
// // UpdateBy{{ $idxmethod }} find a {{ $m }}
// func UpdateBy{{ $idxmethod }}(db {{ $pkg }}.DB, {{ $idxparams }}, {{ $mv }} *{{ $m }}) (*{{ $m }}, error) {
// 	fields := getColumns({{ $mv }})

// 	// don't update the keys
// 	{{ range $idx.Columns -}}
// 	delete(fields, "{{ .Name }}")
// 	{{ end }}

// 	// prepare the slices
// 	_c, _i, _v := {{ $pkg }}.Slice(fields, {{ len $cols }})

// 	// sql query
// 	sqlstr := {{ $tick }}UPDATE {{ $t }} SET ({{ $tick }} +
// 		strings.Join(_c, ", ") + {{ $tick }}) = ({{ $tick }} +
// 		strings.Join(_i, ", ") + {{ $tick }}) {{ $tick }} +
// 		{{ $tick }}WHERE {{ idxwhere $idx }} {{ $tick }} +
// 		{{ $tick }}RETURNING {{ $cof }}{{ $tick }}

// 	// setup the query
// 	values := []interface{}{}
// 	{{ range .Columns }}values = append(values, {{ .Name | camelize }})
// 	{{ end }}
// 	values = append(values, _v...)
// 	{{ $pkg }}.Log(sqlstr, values...)

// 	// run the query
// 	cols := &columns{}
// 	row := db.QueryRow(sqlstr, values...)
// 	if e := row.Scan({{ $cog }}); e != nil {
// 		if e == pgx.ErrNoRows {
//       return nil, Err{{ $m }}NotFound
//     }
// 		return nil, e
// 	}

// 	return &{{ $m }}{cols}, nil
// }
// {{ end }}

// {{/*****************************************************************************/}}
// {{/* pogo.$TABLE.UpdateMany(): update many rows by the given condition */}}
// {{/*****************************************************************************/}}

// // UpdateMany rows in {{ $tick }}{{ $t }}{{ $tick }} by a given condition
// func UpdateMany(db {{ $pkg }}.DB, where *WhereClause, {{ $mv }} *{{ $m }}) ([]*{{ $m }}, error) {
// 	var _o []*{{ $m }}

// 	// prepare the slices
// 	_c, _i, _v := {{ $pkg }}.Slice(getColumns({{ $mv }}), len(where.params))

// 	// sql query
// 	sqlstr := {{ $tick }}UPDATE {{ $t }} SET ({{ $tick }} +
// 		strings.Join(_c, ", ") + {{ $tick }}) = ({{ $tick }} +
// 		strings.Join(_i, ", ") + {{ $tick }}) {{ $tick }} +
// 		{{ $tick }}WHERE {{ $tick }} + where.condition + {{ $tick }} {{ $tick }} +
// 		{{ $tick }}RETURNING {{ $cof }}{{ $tick }}

// 	// setup the query
//   values := []interface{}{}
//   values = append(values, where.params...)
//   values = append(values, _v...)
// 	{{ $pkg }}.Log(sqlstr, values...)

// 	// run query
//   rows, err := db.Query(sqlstr, values...)
//   if err != nil {
//     return _o, err
//   }
//   defer rows.Close()

//   for rows.Next() {
//     cols := &columns{}
//     if e := rows.Scan({{ $cog }}); e != nil {
// 			if e == pgx.ErrNoRows {
// 				return _o, Err{{ $m }}NotFound
// 			}
//       return _o, err
//     }
//     _o = append(_o, &{{ $m }}{cols})
//   }
//   if rows.Err() != nil {
//     return _o, rows.Err()
//   }

// 	// ensure we return an empty array
// 	// rather than nil when we marshal
// 	if len(_o) == 0 {
// 		return make([]*{{ $m }}, 0), nil
// 	}

//   return _o, nil
// }

// {{/*****************************************************************************/}}
// {{/* pogo.$TABLE.Delete(): delete a row using its primary index */}}
// {{/*****************************************************************************/}}

// // Delete a {{ $tick }}{{ $mv }}{{ $tick }} from the {{ $tick }}{{ $t }}{{ $tick }} table
// func Delete(db {{ $pkg }}.DB, {{ $p.Name }} {{ $pt }}) error {
// 	_{{ $p.Name }} := {{ decode .Settings.Package $p.Name $pt }}

// 	// sql query
// 	sqlstr := {{ $tick }}DELETE FROM {{ $t }} WHERE "{{ $p.Name }}" = $1{{ $tick }}
// 	{{ $pkg }}.Log(sqlstr, _{{ $p.Name }})

// 	// run query
// 	if _, e := db.Exec(sqlstr, _{{ $p.Name }}); e != nil {
//     if e == pgx.ErrNoRows {
//       return Err{{ $m }}NotFound
//     }
//     return e
//   }

// 	return nil
// }

// {{/*****************************************************************************/}}
// {{/* pogo.$TABLE.DeleteBy...(): delete a row by its unique non-primary indexes */}}
// {{/*****************************************************************************/}}

// {{ range $idx := $idxs }}
// {{ $cols := idxcolnames $idx }}
// {{ $idxmethod := map $cols mcapitalize | join "And" }}
// {{ $idxparams := idxparams $.Schema $idx }}
// {{ $indexvars := map $cols mcamelize | join ", " }}
// // DeleteBy{{ $idxmethod }} find a {{ $m }}
// func DeleteBy{{ $idxmethod }}(db {{ $pkg }}.DB, {{ $idxparams }}) error {
// 	// sql delete query
// 	sqlstr := {{ $tick }}DELETE FROM {{ $t }} WHERE {{ idxwhere $idx }}{{ $tick }}
// 	{{ $pkg }}.Log(sqlstr, {{ $indexvars }})

// 	if _, e := db.Exec(sqlstr, {{ $indexvars }}); e != nil {
//     if e == pgx.ErrNoRows {
//       return Err{{ $m }}NotFound
//     }
//     return e
//   }

// 	return nil
// }
// {{ end }}

// {{/*****************************************************************************/}}
// {{/* pogo.$TABLE.DeleteMany(): delete many rows by the given condition */}}
// {{/*****************************************************************************/}}

// // DeleteMany delete many {{ $tick }}{{ $mv }}{{ $tick }}'s by the given condition
// func DeleteMany(db {{ $pkg }}.DB, where *WhereClause) error {
// 	// sql select query, primary key provided by sequence
// 	sqlstr := {{ $tick }}DELETE FROM {{ $t }} WHERE {{ $tick }} + where.condition
// 	{{ $pkg }}.Log(sqlstr, where.params...)

//   if _, e := db.Exec(sqlstr, where.params...); e != nil {
//     return e
// 	}

//   return nil
// }

// {{/*****************************************************************************/}}
// {{/* pogo.$TABLE.Upsert(): upsert a row by its primary key */}}
// {{/*****************************************************************************/}}

// // Upsert the {{ $tick }}{{ $mv }}{{ $tick }} by its {{ $tick }}{{ $p.Name }}{{ $tick }}.
// func Upsert(db {{ $pkg }}.DB, {{ $mv }} *{{ $m }}) (*{{ $m }}, error) {
// 	// get all the non-nil columns and prepare them for the query
//   _c, _i, _v := {{ $pkg }}.Slice(getColumns({{ $mv }}), 0)

// 	// sql query
//   sqlstr := {{ $tick }}INSERT INTO {{ $t }} ({{ $tick }} + strings.Join(_c, ", ") + {{ $tick }}) {{ $tick }} +
// 	{{ $tick }}VALUES ({{ $tick }} + strings.Join(_i, ", ") + {{ $tick }}) {{ $tick }} +
//   {{ $tick }}ON CONFLICT ("{{ $p.Name }}") {{ $tick }} +
//   {{ $tick }}DO UPDATE SET ({{ $tick }} + strings.Join(_c, ", ") + {{ $tick }}) = ( EXCLUDED.{{ $tick }} + strings.Join(_c, ", EXCLUDED.") + {{ $tick }}) {{ $tick }} +
//   {{ $tick }}RETURNING {{ $cof }}{{ $tick }}
//   {{ $pkg }}.Log(sqlstr, _v...)

// 	// run query
// 	cols := &columns{}
// 	row := db.QueryRow(sqlstr, _v...)
// 	if e := row.Scan({{ $cog }}); e != nil {
// 		return nil, e
// 	}

// 	return &{{ $m }}{cols}, nil
// }

// {{/*****************************************************************************/}}
// {{/* pogo.$TABLE.UpsertBy...(): upsert a row by its non-unique indexes */}}
// {{/*****************************************************************************/}}

// {{ range $idx := $idxs }}
// {{ $cols := idxcolnames $idx }}
// {{ $idxmethod := map $cols mcapitalize | join "And" }}
// {{ $idxparams := idxparams $.Schema $idx }}
// {{ $idxparamlist := map $cols (mprintf "\"%s\"") | join ", " }}
// // UpsertBy{{ $idxmethod }} find a {{ $m }}
// func UpsertBy{{ $idxmethod }}(db {{ $pkg }}.DB, {{ $mv }} *{{ $m }}) (*{{ $m }}, error) {
// 	// get all the non-nil columns and prepare them for the query
//   _c, _i, _v := {{ $pkg }}.Slice(getColumns({{ $mv }}), 0)

//   // sql query
//   sqlstr := {{ $tick }}INSERT INTO {{ $t }} ({{ $tick }} + strings.Join(_c, ", ") + {{ $tick }}) {{ $tick }} +
// 	{{ $tick }}VALUES ({{ $tick }} + strings.Join(_i, ", ") + {{ $tick }}) {{ $tick }} +
//   {{ $tick }}ON CONFLICT ({{ $idxparamlist }}) {{ $tick }} +
//   {{ $tick }}DO UPDATE SET ({{ $tick }} + strings.Join(_c, ", ") + {{ $tick }}) = ( EXCLUDED.{{ $tick }} + strings.Join(_c, ", EXCLUDED.") + {{ $tick }}) {{ $tick }} +
//   {{ $tick }}RETURNING {{ $cof }}{{ $tick }}
//   {{ $pkg }}.Log(sqlstr, _v...)

// 	// run query
// 	cols := &columns{}
// 	row := db.QueryRow(sqlstr, _v...)
// 	if e := row.Scan({{ $cog }}); e != nil && e != pgx.ErrNoRows {
// 		return nil, e
// 	}

// 	return &{{ $m }}{cols}, nil
// }
// {{ end }}

// Generate the base template
func (m *Model) Generate() (string, error) {
	return model(m)
}

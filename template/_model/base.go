package model

import (
	"fmt"
	"sort"
	"strings"

	"github.com/matthewmueller/go-gen"
	"github.com/matthewmueller/pogo/database"
)

// Model struct
type Model struct {
	Package string
	Schema  *database.Schema
	Table   *database.Table
}

type Column struct {
}

// Generate template
func (m *Model) Generate() (string, error) {
	template := gen.MustCreate("model/base")

	// common variables
	pkg := m.Package
	Model := gen.Pascal(gen.Singular(m.Table.Name))
	model := gen.Lower(gen.Singular(m.Table.Name))
	models := gen.Lower(gen.Plural(m.Table.Name))
	schema := gen.Lower(gen.Snake(m.Schema.Name))
	table := gen.Lower(gen.Snake(m.Table.Name))

	// computed column lists
	var columnlist []string
	var ptrcolumnlist []string
	var setterlist []string
	var condlist []string
	var selectlist []string
	var scanlist []string
	var returnlist []string

	for _, col := range m.Table.Columns {
		if col.NotNull {
			columnlist = append(columnlist, gen.Camel(col.Name))
		} else {
			columnlist = append(columnlist, "*"+gen.Camel(col.Name))
		}

		ptrcolumnlist = append(ptrcolumnlist, "*"+gen.Camel(col.Name))

		setterlist = append(setterlist, template(`
			// {{.Name}} sets the "{{.name}}"
			func ({{.model}} *{{.Model}}Input) {{.Name}}({{.name}} {{.type}}) *{{.Model}}Input {
				{{.model}}.{{.name}} = &{{.name}}
				return {{.model}}
			}
		`))

		selectlist = append(selectlist, `"`+col.Name+`"`)

		scan := fmt.Sprintf("&%s.%s", model, gen.Pascal(col.Name))
		scanlist = append(scanlist, scan)

		returnlist = append(returnlist, `"`+col.Name+`"`)
	}
	sort.Strings(selectlist)
	sort.Strings(scanlist)
	sort.Strings(returnlist)

	selects := strings.Join(selectlist, ", ")
	scans := strings.Join(scanlist, ", ")
	returns := strings.Join(returnlist, ", ")

	return "", template(`
		package {{.pkg}}

		// GENERATED BY POGO. DO NOT EDIT.
		
		// Err{{.Model}}NotFound returned if the {{.model}} is not found
		var Err{{.Model}}NotFound = errors.New("{{.model}} not found")

		// {{.Model}}Input model for '{{.schema}}.{{.table}}'
		type {{.Model}}Input struct {
			{{.fields}}
		}

		// {{.Model}} model for "{{.schema}}"."{{.table}}"
		type {{.Model}} struct {
			{{.fields}}
		}

		// New "{{.schema}}"."{{.table}}" API
		func New() *{{.Model}}Input {
			return &{{.Model}}Input{}
		}	

		// {{.Name}} sets the "{{.name}}"
		func ({{.model}} *{{.Model}}Input) {{.Name}}({{.name}} {{.type}}) *{{.Model}}Input {
			{{.model}}.{{.name}} = &{{.name}}
			return {{.model}}
		}

		// MarshalJSON marshals the "{{.model}}" into JSON
		func ({{.model}} *{{.Model}}Input) MarshalJSON() ([]byte, error) {
			return json.Marshal({{.model}})
		}

		// UnmarshalJSON unmarshals json to a "{{.model}}"
		func ({{.model}} *{{.Model}}Input) UnmarshalJSON(data []byte) error {
			return json.Unmarshal(data, {{.model}})
		}

		// Stringer for "{{.Model}}Input"
		func ({{.model}} *{{.Model}}Input) String() string {
			return "{{.model}}"
		}

		func getColumns({{.model}} *{{.Model}}Input) map[string]interface{} {
			columns := make(map[string]interface{})
			
			{{.fields}}

			return columns
		}

		// WhereClause is a struct to handle where clauses
		type WhereClause struct {
			condition string
			params    []interface{}
		}

		// Where specifies the conditions
		func Where(condition string, params ...interface{}) *WhereClause {
			return &WhereClause{
				condition: condition,
				params:    params,
			}
		}
	`, map[string]interface{}{})

	return "", nil
}

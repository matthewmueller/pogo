package template

import (
	"fmt"
	"sort"
	"strings"

	gen "github.com/matthewmueller/go-gen"
	"github.com/matthewmueller/pogo/database"
)

var manyToMany = gen.MustCompile("many-to-many", `
	
`)

// ManyToMany struct
type ManyToMany struct {
	Package string
	Schema  *database.Schema
	Table   *database.Table
}

// Generate the base template
func (m *ManyToMany) Generate() (string, error) {
	type V map[string]interface{}

	template := gen.MustCreate("many-to-many")
	lines := ""

	// make all words singular
	parts := strings.Split(gen.Base(m.Table.Name), " ")
	for i, w := range parts {
		parts[i] = gen.Singular(w)
	}
	base := strings.Join(parts, " ")

	pkg := m.Package
	Model := gen.Pascal(base)
	model := gen.Camel(base)
	models := gen.Camel(base)
	schema := m.Schema.Name
	table := m.Table.Name

	// package
	lines += fmt.Sprintf("package %s\n", m.Package)

	// marker
	lines += "// GENERATED BY POGO. DO NOT EDIT.\n"

	// error handling
	lines += template(`
		// Err{{.Model}}NotFound returned if the {{.model}} is not found
		var Err{{.Model}}NotFound = errors.New("{{.model}} not found")
	`, V{
		"Model": Model,
		"model": model,
	})

	fields := ""
	for _, col := range m.Table.Columns {
		fields += fmt.Sprintf("%s *%s\n", gen.Camel(col.Name), col.GoType)
	}

	// user input struct
	lines += template(`
		// {{.Model}}Input model for '{{.schema}}.{{.table}}'
		type {{.Model}}Input struct {
			{{.fields}}
		}
	`, V{
		"Model":  Model,
		"schema": schema,
		"table":  table,
		"fields": fields,
	})

	fields = ""
	for _, col := range m.Table.Columns {
		if col.NotNull {
			fields += fmt.Sprintf("%s %s\n", gen.Pascal(col.Name), col.GoType)
		} else {
			fields += fmt.Sprintf("%s *%s\n", gen.Pascal(col.Name), col.GoType)
		}
	}

	// user struct
	lines += template(`
		// {{.Model}} model for "{{.schema}}"."{{.table}}"
		type {{.Model}} struct {
			{{.fields}}
		}
	`, V{
		"Model":  Model,
		"schema": schema,
		"table":  table,
		"fields": fields,
	})

	// new input struct
	lines += template(`
		// New "{{.schema}}"."{{.table}}" API
		func New() *{{.Model}}Input {
			return &{{.Model}}Input{}
		}	
	`, V{
		"Model":  Model,
		"schema": schema,
		"table":  table,
	})

	// setters
	for _, col := range m.Table.Columns {
		lines += template(`
		// {{.Name}} sets the "{{.name}}"
		func ({{.model}} *{{.Model}}Input) {{.Name}}({{.name}} {{.type}}) *{{.Model}}Input {
			{{.model}}.{{.name}} = &{{.name}}
			return {{.model}}
		}
	`, V{
			"Name":  gen.Pascal(col.Name),
			"name":  gen.Camel(col.Name),
			"type":  col.GoType,
			"Model": Model,
			"model": model,
			// "schema": schema,
			// "table":  table,
		})
	}

	// interfaces
	lines += template(`
		// MarshalJSON marshals the "{{.model}}" into JSON
		func ({{.model}} *{{.Model}}Input) MarshalJSON() ([]byte, error) {
			return json.Marshal({{.model}})
		}

		// UnmarshalJSON unmarshals json to a "{{.model}}"
		func ({{.model}} *{{.Model}}Input) UnmarshalJSON(data []byte) error {
			return json.Unmarshal(data, {{.model}})
		}

		func ({{.model}} *{{.Model}}Input) String() string {
			return "{{.model}}"
		}
	`, V{
		"Model": Model,
		"model": model,
	})

	fields = ""
	for _, col := range m.Table.Columns {
		fields += template(`
			if {{.model}}.{{.name}} != nil {
				columns["{{.column}}"] = *{{.model}}.{{.name}}
			}
		`, V{
			"column": col.Name,
			"name":   gen.Camel(col.Name),
			"model":  model,
		})
	}

	// get all the non-nil columns
	lines += template(`
		func getColumns({{.model}} *{{.Model}}Input) map[string]interface{} {
			columns := make(map[string]interface{})
			
			{{.fields}}

			return columns
		}
	`, V{
		"Model":  Model,
		"model":  model,
		"fields": fields,
	})

	// where clause
	lines += `
		// WhereClause is a struct to handle where clauses
		type WhereClause struct {
			condition string
			params    []interface{}
		}

		// Where specifies the conditions
		func Where(condition string, params ...interface{}) *WhereClause {
			return &WhereClause{
				condition: condition,
				params:    params,
			}
		}
	`

	var selectlist []string
	var scanlist []string
	var returnlist []string
	for _, col := range m.Table.Columns {
		selectlist = append(selectlist, `"`+col.Name+`"`)

		scan := fmt.Sprintf("&%s.%s", model, gen.Pascal(col.Name))
		scanlist = append(scanlist, scan)

		returnlist = append(returnlist, `"`+col.Name+`"`)
	}
	sort.Strings(selectlist)
	sort.Strings(scanlist)
	sort.Strings(returnlist)

	selects := strings.Join(selectlist, ", ")
	scans := strings.Join(scanlist, ", ")
	returns := strings.Join(returnlist, ", ")

	var columnlist []string
	var namelist []string
	var paramlist []string
	var wherelist []string
	var deletelist []string
	var appendlist []string
	for i, fk := range m.Table.ForeignKeys {
		for _, col := range m.Table.Columns {
			if fk.Name != col.Name {
				continue
			}

			columnlist = append(columnlist, col.Name)
			namelist = append(namelist, gen.Camel(col.Name))

			param := fmt.Sprintf("%s %s", gen.Camel(col.Name), col.GoType)
			paramlist = append(paramlist, param)

			where := fmt.Sprintf("\"%s\" = $%d", col.Name, i+1)
			wherelist = append(wherelist, where)

			delete := fmt.Sprintf("delete(fields, \"%s\")", col.Name)
			deletelist = append(deletelist, delete)

			a := fmt.Sprintf("append(values, \"%s\")", gen.Camel(col.Name))
			appendlist = append(appendlist, a)
		}
	}
	sort.Strings(columnlist)
	sort.Strings(paramlist)
	sort.Strings(wherelist)
	sort.Strings(deletelist)
	sort.Strings(appendlist)

	method := gen.Pascal(strings.Join(columnlist, " "))
	description := fmt.Sprintf("\"%s\"", strings.Join(columnlist, "\" and \""))
	columns := strings.Join(columnlist, ", ")
	params := strings.Join(paramlist, ", ")
	wheres := strings.Join(wherelist, " AND ")
	vars := strings.Join(namelist, ", ")
	deletes := strings.Join(deletelist, "\n")
	appends := strings.Join(appendlist, "\n")

	// find
	lines += template(`
		// Find a "{{.Model}}" by its {{.description}}
		func Find(db {{.pkg}}.DB, {{.params}}) (*{{.Model}}, error) {
			// sql select query, primary key provided by sequence
			sqlstr := {{.tick}}
			SELECT {{.selects}}
			FROM "{{.schema}}.{{.table}}"
			WHERE {{.wheres}}
			{{.tick}}
			{{.pkg}}.Log(sqlstr, {{.vars}})

			// run the query
			var {{.model}} {{.Model}}
			row := db.QueryRow(sqlstr, {{.vars}})
			if e := row.Scan({{.scans}}); e != nil {
				if e == pgx.ErrNoRows {
					return nil,  Err{{.Model}}NotFound
				}
				return nil, e
			}

			return &{{.model}}, nil
		}
	`, V{
		"tick":        "`",
		"pkg":         pkg,
		"method":      method,
		"description": description,
		"numcols":     len(columnlist),
		"columns":     columns,
		"params":      params,
		"wheres":      wheres,
		"vars":        vars,
		"deletes":     deletes,
		"appends":     appends,
		"selects":     selects,
		"scans":       scans,
		"returns":     returns,
		"schema":      schema,
		"table":       table,
		"Model":       Model,
		"model":       model,
		"models":      models,
	})

	// insert
	lines += template(`
		// Insert a "{{.model}}" into "{{.schema}}"."{{.table}}"
		func Insert(db {{.pkg}}.DB, {{.model}}Input *{{.Model}}Input) (*{{.Model}}, error) {
			// get all the non-nil fields and prepare them for the query
			_c, _i, _v := {{.pkg}}.Slice(getColumns({{.model}}Input), 0)

			// sql insert query, primary key provided by sequence
			sqlstr := {{.tick}}
			INSERT INTO {{.schema}}"."{{.table}} ({{.tick}} + strings.Join(_c, ", ") + {{.tick}})
			VALUES ({{.tick}} + strings.Join(_i, ", ") + {{.tick}})
			RETURNING {{.returns}}
			{{.tick}}
			{{.pkg}}.Log(sqlstr, _v...)

			// run the query
			var {{.model}} {{.Model}}
			row := db.QueryRow(sqlstr, _v...)
			if e := row.Scan({{.scans}}); e != nil {
				return nil, e
			}

			return &{{.model}}, nil
		}
	`, V{
		"tick":        "`",
		"pkg":         pkg,
		"method":      method,
		"description": description,
		"numcols":     len(columnlist),
		"columns":     columns,
		"params":      params,
		"wheres":      wheres,
		"vars":        vars,
		"deletes":     deletes,
		"appends":     appends,
		"selects":     selects,
		"scans":       scans,
		"returns":     returns,
		"schema":      schema,
		"table":       table,
		"Model":       Model,
		"model":       model,
		"models":      models,
	})

	// update
	lines += template(`
		// Update a "{{.Model}}" by its {{.description}}
		func Update(db {{.pkg}}.DB, {{.params}}, {{.model}}Input *{{.Model}}Input) (*{{.Model}}, error) {
			fields := getColumns({{.model}}Input)

			// don't update the foreign keys
			{{.deletes}}

			// prepare the slices
			_c, _i, _v := {{.pkg}}.Slice(fields, {{.numcols}})

			// sql query
			sqlstr := {{.tick}}UPDATE "{{.schema}}"."{{.table}}" SET ({{.tick}} +
				strings.Join(_c, ", ") + {{.tick}}) = ({{.tick}} +
				strings.Join(_i, ", ") + {{.tick}})
				WHERE {{.wheres}}
				RETURNING {{.returns}}{{.tick}}

			// setup the query
			values := []interface{}{}
			{{.appends}}
			values = append(values, _v...)
			{{.pkg}}.Log(sqlstr, values...)

			// run the query
			var {{.model}} {{.Model}}
			row := db.QueryRow(sqlstr, values...)
			if e := row.Scan({{.scans}}); e != nil {
				if e == pgx.ErrNoRows {
					return nil, Err{{.Model}}NotFound
				}
				return nil, e
			}

			return &{{.model}}, nil
		}
	`, V{
		"tick":        "`",
		"pkg":         pkg,
		"method":      method,
		"description": description,
		"numcols":     len(columnlist),
		"columns":     columns,
		"params":      params,
		"wheres":      wheres,
		"vars":        vars,
		"deletes":     deletes,
		"appends":     appends,
		"selects":     selects,
		"scans":       scans,
		"returns":     returns,
		"schema":      schema,
		"table":       table,
		"Model":       Model,
		"model":       model,
		"models":      models,
	})

	// delete
	lines += template(`
		// Delete a "{{.Model}}" by its {{.description}}.
		func Delete(db {{.pkg}}.DB, {{.params}}) error {
			// sql query
			const sqlstr = {{.tick}}
			DELETE FROM "{{.schema}}.{{.table}}"
			WHERE {{.wheres}}
			{{.tick}}
			{{.pkg}}.Log(sqlstr, {{.vars}})

			// run query
			if _, e := db.Exec(sqlstr, {{.vars}}); e != nil {
				if e == pgx.ErrNoRows {
					return Err{{.Model}}NotFound
				}
				return e
			}

			return nil
		}
	`, V{
		"tick":        "`",
		"pkg":         pkg,
		"method":      method,
		"description": description,
		"numcols":     len(columnlist),
		"columns":     columns,
		"params":      params,
		"wheres":      wheres,
		"vars":        vars,
		"deletes":     deletes,
		"appends":     appends,
		"selects":     selects,
		"scans":       scans,
		"returns":     returns,
		"schema":      schema,
		"table":       table,
		"Model":       Model,
		"model":       model,
		"models":      models,
	})

	out, err := gen.Format(lines)
	if err != nil {
		return "", err
	}

	return out, nil
}
